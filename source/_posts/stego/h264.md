---
title: h.264 码流分析
date: 2023-11-16 09:03:50
tags:
---

# 1. 基本介绍

**# 码流格式**

1. AnnexB

    `[start code]NALU | [start code]NALU | ...`

    `.h264` 文件（h264 裸流）使用这种格式。

2. AVCC

    `([extradata]) | ([length] NALU) | ([length] NALU) | ...`

    也称 AVC1 格式。没有起始码，每个帧最前面几个字节（通常4字节）是帧长度。这里的NALU一般没有`SPS PPS`等参数信息，参数信息属于额外数据extradata存在其他地方。
    比如ffmpeg中解析mp4文件后sps pps存在`streams[index]->codecpar->extradata;`中。也就是说这种码流通常只包含VCL类型NALU。

    这些extradata通常有如下格式（可以根据这个规则ffmpeg解析mp4文件的SPS和PPS）
    ```
    第1字节：version (通常0x01)
    第2字节：avc profile (值同第1个sps的第2字节)
    第3字节：avc compatibility (值同第1个sps的第3字节)
    第4字节：avc level (值同第1个sps的第3字节)
    第5字节前6位：保留全1
    第5字节后2位：NALU Length 字段大小减1，通常这个值为3，即NAL码流中使用3+1=4字节表示NALU的长度
    第6字节前3位：保留，全1
    第6字节后5位：SPS NALU的个数，通常为1
    第7字节开始后接1个或者多个SPS数据
        SPS结构 [16位 SPS长度][SPS NALU data]

    SPS数据后
    第1字节：PPS的个数，通常为1
    第2字节开始接1个或多个PPS数据
        PPS结构 [16位 PPS长度][SPS NALU data]
    ```

**# NALU**

以 AnnexB 为例说明。H264 码流 形式如下，

`[start code] [SPS] [start code] [PPS] [start code] [I Slice] [start code] [B Slice] [start code] [P Slice]`

以上除了 `[start code]` 之外每个部分都封装为 `NALU`，其中 `NAL` 又分为 VCL 和 non-VCL 两种，例如 `SPS, PPS` 等就是 non-VCL 。

一个 NALU 表示 `nal unit`，以 `I Slice NALU` 为例说明，其结构如下：

```
            +--------------+
            | I Slice NALU |
            +-------+------|
                    |
                    v
        +-------------+-----------+
        | NALU header | NALU data |
        +-------------+-----+-----+
                            |
                            v
        +--------------+------------+
        | Slice header | Slice data |
        +--------------+-----+------+
                             |
                             v
                    +----+----+-----+----+
                    | MB | MB | ... | MB |
                    +----+----+-----+----+
```

NALU header 占一个 byte。

**# 帧类型**

1. IDR 帧一定是 I 帧，反之不一定。IDR 帧之后的帧不能引用 IDR 之前的帧内容
2. I 帧包含了 SPS，PPS，I Slice（注意 IDR 也是一个 I 帧）
    
    实际上是 I 帧前面会有 SPS, PPS

3. P 帧包含 P Slice
4. B 帧包含 B Slice

**# SEI 补充增强信息**

例如以下一段数据

`00 00 01 06 05 ff ff ab dc 45 e9 ...`

起始码为 `00 00 01`，然后 `06` 是 nal unit 类型，查表可知是 SEI，

|NAL unit type| 含义 |
|--|--|
|1| 非 IDR 图像的编码条带|
|5| IDR 图像|
|6| SEI |
|7| SPS |
|8| PPS |
|11| 流结束符 |

`05` 是 SEI payload 类型值，当类型值为 `05` 时，指定处理方法为 `user_data_unregistered()`

计算 SEI 负载大小：持续读取 8bit，直到非 0xff 为止，然后把所读的值相加，累加和即为 SEI payload size。例如上述数据片段中，读到数据为 `ff ff ab` 后停止，负载大小为 `255+255+171=681`。

然后接下来 16 个 byte 表示 uuid，即 `dc 45 e9 ...` 等 16 个 byte 表示 uuid，然后剩下 `681-16=665` 个 byte 为 SEI 文本内容。这 665 个 byte 中最后一个 byte 为 `00`，这是结束符，然后跟一个 `80` byte，表示 RBSP trailing bits（拖尾）。

SEI 中通常用于添加：

1. 编码器参数

2. 视频版权信息

3. 摄像头参数

4. 其他与视频无关的信息

**# I Slice**

SEI 之后，数据为 `00 00 01 65 88 84 00 6f e9 92 f6 63 cf ff ...`

起始码 `00 00 01` 之后的一个 byte 为 `65` 这个 NALU header 表示这是一个 IDR 帧类型。

在 H264 码流中，帧以 Slice 方式呈现，即 没有帧只有 Slice。如何判断一帧包含了多少个 Slice，一帧的开始和结束分别对应哪个 Slice？

Slice header 中有个 `first_mb_in_slice` 字段，值为 0 则表示当前 slice 的第一个宏块在当前编码图像（当前帧）中的序号，这就意味着当前 slice 就是一帧的第一个 slice。一直这么找下去，直到下一个 `first_mb_in_slice=0` 出现，表示这是下一个帧的第一个 slice，那么这个 slice 的上一个 slice 就是一帧的最后一个 slice。

`first_mb_in_slice` 是以无符号指数哥伦布编码的，需要使用对应的解码方式才能得到，但是如果只要判断是否为 0，则不需要解码，只要通过如下方式判断即可：

`if slice_header[0] & 0x80 == 1 then first_mb_in_slice=0`

**# EBSP, RBSP, SODB**

1. EBSP 扩展字节序列载荷
2. RBSP 原始字节序列载荷
3. SODB 原始编码数据 String Of Data Bits

EBSP 完全等价于 NALU body，故 NALU 组成为

`NALU = NALU header + EBSP`

H264 文档中为 `NALU = NALU header + RBSP` ， EBSP 相较于 RBSP，多了一个防止竞争的字节：`0x03` 。

起始码为 `0x000001` 或者 `0x00000001`，当检测到 `0x000000` 也表示当前 NALU 结束。
如果 NALU data（NALU 去掉 header）中包含了 0x000001 或者 0x000000，该怎么办？

这就是 H264 的防竞争机制：

当检测到如下左侧的 4 个序列是，编码器在最后一个字节前，插入新的字节 `0x03`，

```
0x000000 -> 0x00000300
0x000001 -> 0x00000301
0x000002 -> 0x00000302
0x000003 -> 0x00000303
```

（`0x000002` 保留使用）。这样拿到 EBSP 数据时，如果检测到 `0x000003`，则去掉最后的 byte `0x03`，这样就得到 RBSP 。

`RBSP = SODB + RBSP尾部`

RBSP 尾部有几种，大多数为：

在 SODB 的最后一个 byte 的最后一个 bit 后，紧跟 `1` 的 bit，然后增加若干 `0` bit，对齐这个 byte。

还有 **条带 RBSP 尾部**：

默认与普通 RBSP 尾部相同，当 `entropy_coding_mode_flag=1` 时，即 当前采用的熵编码为 CABAC，并且 `more_rbsp_trailing_data()` 返回 true，尾部继续添加若干 0x0000，直到 `more_rbsp_trailing_data()` 返回 0。

**# 起始码**

有两种

1. `0x000001` 用在单帧多 slice 之间间隔（即，单帧多个 NALU 之间）
2. `0x00000001` 帧之间，或者 SPS PPS 等之前

AnnexB 码流格式每个 NALU 之前都有起始码，且通常会周期性的在关键帧之前重复 SPS 和 PPS


**# AVPacket**

AVPacket 是 ffmpeg 中的数据类，用于存储解封装后的压缩数据。而 AVFrame 是解码后保存的音视频帧。AVPacket 的 data 格式为

`size(4 byte) + NALU + size(4 byte) + NALU + ...`

包含一个或多个 NALU，size(4 byte) 表示 NALU 的大小。

对于视频而言，一个 AVPacket 通常只包含一个压缩视频帧；对于音频而言，一个 AVPacket 可能包含多个完整的音频压缩帧。AVPacket 也可以不包含压缩编码数据，而只包含 SideData，这种包称为空 Packet。

实际上对视频而言，一个 AVPacket 可能包含不到一帧压缩数据，可能要多个 AVPacket 才包含一帧。

**# Slice header**

**# SPS**

(1) profile_idc

标识当前H.264码流的profile。我们知道，H.264中定义了三种常用的档次profile：

基准档次：baseline profile;

主要档次：main profile;

扩展档次：extended profile;

在H.264的SPS中，第一个字节表示profile_idc，根据profile_idc的值可以确定码流符合哪一种档次。判断规律如下：

profile_idc = 66 → baseline profile;

profile_idc = 77 → main profile;

profile_idc = 88 → extended profile;

在新版的标准中，还包括了High、High 10、High 4:2:2、High 4:4:4、High 10 Intra、High

4:2:2 Intra、High 4:4:4 Intra、CAVLC 4:4:4 Intra等，每一种都由不同的profile_idc表示。

另外，constraint_set0_flag ~ constraint_set5_flag是在编码的档次方面对码流增加的其他一些额外限制性条件。

(2) level_idc

标识当前码流的Level。编码的Level定义了某种条件下的最大视频分辨率、最大视频帧率等参数，码流所遵从的level由level_idc指定。

当前码流中，level_idc = 0x1e = 30，因此码流的级别为3。

(3) seq_parameter_set_id

表示当前的序列参数集的id。通过该id值，图像参数集pps可以引用其代表的sps中的参数。

(4) log2_max_frame_num_minus4

用于计算MaxFrameNum的值。计算公式如下：

MaxFrameNum = 2^(log2_max_frame_num_minus4 + 4)

MaxFrameNum是frame_num的上限值，frame_num是图像序号的一种表示方法，在帧间编码中常用作一种参考帧标记的手段。

(5) pic_order_cnt_type

表示解码picture order count(POC)的方法。POC是另一种计量图像序号的方式，与frame_num有着不同的计算方法。该语法元素的取值为0、1或2。

(6) log2_max_pic_order_cnt_lsb_minus4

用于计算MaxPicOrderCntLsb的值，该值表示POC的上限。计算公式如下：

MaxPicOrderCntLsb = 2^(log2_max_pic_order_cnt_lsb_minus4 + 4)

(7) max_num_ref_frames

用于表示参考帧的最大数目。

(8) gaps_in_frame_num_value_allowed_flag

标识位，说明frame_num中是否允许不连续的值。

(9) pic_width_in_mbs_minus1

用于计算图像的宽度，单位为宏块个数。

(10) pic_height_in_map_units_minus1

使用PicHeightInMapUnits来度量视频中一帧图像的高度。PicHeightInMapUnits并非图像明确的以像素或宏块为单位的高度，而需要考虑该宏块是帧编码或场编码。

(11) frame_mbs_only_flag

标识位，说明宏块的编码方式。当该标识位为0时，宏块可能为帧编码或场编码；该标识位为1时，所有宏块都采用帧编码。根据该标识位取值不同，PicHeightInMapUnits的含义也不同，为0时表示一场数据按宏块计算的高度，为1时表示一帧数据按宏块计算的高度。

按照宏块计算的图像实际高度FrameHeightInMbs的计算方法为：

FrameHeightInMbs = ( 2 − frame_mbs_only_flag ) * PicHeightInMapUnits

(12) mb_adaptive_frame_field_flag

标识位，说明是否采用了宏块级的帧场自适应编码。当该标识位为0时，不存在帧编码和场编码之间的切换；当标识位为1时，宏块可能在帧编码和场编码模式之间进行选择。

(13) direct_8x8_inference_flag

标识位，用于B_Skip、B_Direct模式运动矢量的推导计算。

(14) frame_cropping_flag

标识位，说明是否需要对输出的图像帧进行裁剪。

(15) vui_parameters_present_flag

标识位，说明SPS中是否存在VUI信息。

二、SPS的存储位置
在H264码流中，都是以"0x00 0x00 0x01"或者"0x00 0x00 0x00 0x01"作为起始码的，找到起始码之后，使用开始码之后的第一个字节的低5位判断是否为7，也就是SPS类型标识，伪代码如下：

data[3] & 0x1f == 7
data[4] & 0x1f == 7

三、如何计算宽高信息
根据SPS信息计算视频宽高的常用公式如下：

width = (pic_width_in_mbs_minus1+1)*16;
height = (pic_height_in_map_units_minus1+1)*16;
复制
复制
但是这是针对宽高是16的整数倍的情况，如果宽高不是16整数倍时，frame_cropping_flag值为1，frame_mbs_only_flag为1，公式如下：(也可以认为这是统一公式)
```
width = ((pic_width_in_mbs_minus1 +1)*16) - frame_crop_left_offset*2 - frame_crop_right_offset*2;

height= ((2 - frame_mbs_only_flag)* (pic_height_in_map_units_minus1 +1) * 16) - \
(frame_crop_top_offset * 2) - (frame_crop_bottom_offset * 2);
```
四、获取帧率

用到 SPS 中的 VUI 信息，公式为

```
fps = (float)(time_scale) / (float)(num_units_in_tick*2)
```

DTS: (Decode Time Stamp) 用于视频的解码序列，在解码阶段使用

PTS: (Presentation Time Stamp) 用于视频的显示序列，在渲染阶段使用。若没有 B 帧，那么 DTS 与 PTS 输出顺序一样。