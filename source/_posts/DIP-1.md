---
title: 数字图像处理（一）
date: 2019-12-05 11:37:39
tags: DIP
mathjax: true
---

> 参考教材《数字图像处理》(Gonzalez)
# 1. 坐标变换
## 1.1 仿射变换
特点：
1. 平直性：原图中的直线段在仿射变换后的图像中依然是直线段。
2. 平行性：原图中平行的两个线段在仿射变换后的图中依然是平行的
   
一般形式：
$$(x,y)=\mathbf T[(v,w)]$$
其中 $(v,w)$ 是原图中的某点坐标，$(x,y)$ 是变换后图像中对应点的坐标
$$\begin{bmatrix}x & y & 1 \end{bmatrix}=\begin{bmatrix}v & w & 1 \end{bmatrix}\mathbf T=\begin{bmatrix}v & w & 1 \end{bmatrix}\begin{bmatrix}t_{11} & t_{12} & 0 \\ t_{21} & t_{22} & 0 \\ t_{31} & t_{32} & 1\end{bmatrix}$$

$$\begin{cases}x=t_{11} v + t_{21} w + t_{31} \\
y=t_{12} v + t_{22} w + t_{32} \end{cases} \qquad(1)$$

反向映射：
$$(v,w)=\mathbf T^{-1} [(x,y)]$$

### 1.1.1 恒等变换
$$\mathbf T = \begin{bmatrix} 1 & 0 & 0 \\ 0& 1&0 \\ 0&0&1\end{bmatrix}$$
### 1.1.2 尺度变换
$$\mathbf T = \begin{bmatrix} c_x & 0 & 0 \\ 0& c_y&0 \\ 0&0&1\end{bmatrix}$$
x 方向变为原来的 $c_x$ 倍，y 方向变为原来的 $c_y$ 倍。
### 1.1.3 旋转变换
$$\mathbf T = \begin{bmatrix} cos \theta & sin \theta & 0 \\ -sin \theta& cos \theta&0 \\ 0&0&1\end{bmatrix}$$
其中 $\theta$ 为（图像绕左上角顶点）顺时针旋转角度。
### 1.1.4 平移变换
$$\mathbf T = \begin{bmatrix} 1 & 0 & 0 \\ 0& 1&0 \\ t_x&t_y&1\end{bmatrix}$$
### 1.1.5 偏移变换
又称错切（shear）变换，分水平错切和垂直错切两种情况。水平错切：将每一点水平移动，移动长度和该点的纵坐标成比例，
$$(v,w) \rightarrow (v+mw,w)$$
$m>0$ 时向右移动，$m<0$ 时向左移动。
类似地可以得到垂直方向变换为，
$$(v,w) \rightarrow (v, vn+w)$$
于是错切变换矩阵为
$$\mathbf T=\begin{bmatrix} 1 & n & 0 \\ m & 1 & 0 \\ 0 & 0 & 1\end{bmatrix}$$

## 1.2 透视变换
透视变换是二维 $(x,y)$ 到三维 $(x,y,z)$，然后再到二维 $(x',y')$ 的映射，所以也称为投影变换。

事实上，二维可看作三维上的一个平面 $(x,y,1)$，前面的仿射变换则是将这个平面上的点 $(x,y,1)$ 经过 $3 \times 3$ 变换矩阵后依然位于这个平面内 $(x',y',1)$，而透视变换则是先变换到三维空间任意点上，然后从三维空间在变换到 $(x',y',1)$，故不难想象变换矩阵具有如下形式，
$$[x,y,1]=[v,w,1]T=[v,w,1]\begin{bmatrix} t_{11} & t_{12} & t_{13} \\t_{21} & t_{22} & t_{23} \\t_{31} & t_{32} & t_{33} \end{bmatrix}$$
其中 $t_{13}v+t_{23}w+t_{33}=1$。从变换矩阵也可以看出，仿射变换是一种特殊的透视变换。

正如下一节将要讲到的，需要知道输入图像和输出图像中分别 4 个约束点，才能确定透视变换的矩阵参数，这是因为 4 个约束点提供 8 个方程，加上自身的约束方程，共 9 个方程从而解出 9 个参数，可参考 opencv 的 python 教程中关于[透视变换的例子](https://docs.opencv.org/4.1.2/da/d6e/tutorial_py_geometric_transformations.html)。


# 2. 图像配准
有时候知道输入图像和经过某种变换后的输出图像，要求变换函数，这就是图像配准。主要方法是使用约束点（控制点），根据输入图像和输出图像上的一组 n 个约束点来估计变换函数，例如已知是仿射变换，那么只需要一组 3 个约束点（6个方程解6个参数），根据式 $(1)$ 即可求出参数；如果变换函数模型是双线性模型，那么有
$$x=c_1v+ c_2w+c_3vw + c_4 \\ y=c_5v+c_6w+c_7vw+c_8$$
即，需要 4 个约束点得到变换函数参数。

还有其他更加复杂的策略，略。

# 3. 图像内插
假设要求变换后图像中 $(x,y)$ 的像素值，根据反向映射得到原图对应点位置为 $(i+u,j+v)$（整数+小数的形式），$0\le u,v < 1$
## 3.1 最近邻内插
对 $u,v$ 分别采用四舍五入，得到原来图像对应像素位置 $(\lfloor i+u+\frac 1 2\rfloor,\lfloor j+v+\frac 1 2 \rfloor)$
## 3.2 双线性内插
使用 4 个最近邻即 $(i,j), (i+1,j),(i,j+1),(i+1,j+1)$ 根据下式进行确定，
$$f(i+u,j+v)=(1-u)(1-v)f(i,j)+(1-u)v f(i,j+1)+u(1-v)f(i+1,j)+uvf(i+1,j+1)$$

## 3.2 双三次内插
使用 16 个最近邻点，一种确定权重因子的方法是使用 BiCubic 函数，
$$W(x)=\begin{cases} (a+2)|x|^3 - (a+3)|x|^2+1 & |x| \le 1 \\ a|x|^3-5a|x|^2+8a|x|-4a & 1 <|x|<2 \\ 0 & \text{otherwise} \end{cases}$$
其中， $x$ 是水平（垂直）方向上的距离，a 通常取 $a=-0.5$。

为了表示方便，坐标使用 $(x,y)$ 而非前面的 $(i,j)$ 表示。图像上目标点 $(x,y)$ 的 $4\times4$ 邻域的点 $(x_i,y_j), \ i,j=0,1,2,3$，按下式进行双三次插值，
$$f(x,y)=\sum_{i=0}^3\sum_{j=0}^3 f(x_i,y_j) W(x-x_i) W(y-y_j)$$

# 4. 灰度变换
这里仅讨论部分灰度变换的方法。
## 4.1 直方图均衡
假设灰度范围为 $[0,L-1]$，变换形式为
$$s=T(r)$$
表示将灰度 `r` 变换为 `s`。
这里假定变换函数单调增（若非特别说明，不一定是严格单调增），否则灰度变换后产生认为缺陷。

我们可以将 `r` 看作输入图像的表示灰度的随机变量，`s` 为输出图像的表示灰度的随机变量，令 $p_r(r), \ p_s(s)$ 分别表示 `r` 和 `s` 的概率密度函数，那么
$$p_s(s)=p_r(r) \frac {dr} {ds} \qquad(2)$$

其中 $T(r)=s, \ r_1 \le r \le r_2$，非严格单调增时 $r_1<r_2$，严格单调增时 $r_1=r_2$。

使用如下变换函数来实现直方图均衡，
$$s=T(r)=(L-1)\int_0^r p_r(w) dw \qquad(3)$$
其中 积分项是归一化的，所以增加 $(L-1)$ 因子将灰度放大到合适的范围内。

对 (3) 式求导，
$$\frac {ds} {dr} = \frac {dT(r)} {dr} = (L-1) \frac d {dr} \left[\int_0^r p_r(w)dw \right] = (L-1)p_r(r) \qquad(4)$$

将 (4) 式代入 (2) 式，
$$p_s(s)=p_r(r) \frac {dr} {ds} = \frac 1 {L-1} \qquad(5)$$

这说明， 随机变量 `s` 是均匀分布的。

数字图像处理中常采用离散化处理，此时变换函数为，
$$s=T(r)=(L-1) \sum_{0}^r p_r(r) \qquad(3')$$
其中 $p_r(r)=n_r/N$，$n_r$ 为灰度 `r` 的像素数量，`N` 为图像总像素数量。
此时 
$$1=s - (s-1) = (L-1)\sum_0^{r_2}p_r(r) - (L-1)\sum_0^{r_1}p_r(r)=(L-1)\sum_{r_1}^{r_2}p_r(r)$$
于是，
$$p_s(s) = \sum_{r_1}^{r_2}p_r(r)=\frac 1 {L-1}$$
注意，上式中由于 $r$ 取不到 $r_1$，故可能会出现近似等于 $1/(L-1)$。

## 4.2 直方图匹配
指定输出图像的直方图的形状。令 `r`  和 `z` 分别表示输入和输出图像的灰度随机变量，`s` 为一个均匀分布的灰度随机变量，有
$$s=T(r)=(L-1)\int_0^r p_r(r) dw \qquad(6)
\\\\ s=G(z)=(L-1)\int_0^z p_z(t) dt \qquad(7)$$

于是，
$$z=G^{-1}(s)$$
此时要求变换函数 $G$ 是严格单调增，否则不存在反函数。

由于输入图像给定，容易计算出 $p_r(r)$，而指定输出图像的直方图形状，即 $p_z(z)$ 已知，根据 (7) 式可得 $G$（每个 z 到 s 的映射），于是直方图匹配步骤如下：
1. 计算 $p_r(r)$，然后计算 `s`
2. 根据式 (7) 计算 $G(z)$
3. 求反函数 $G^{-1}(s)$，根据 `s` 计算出 `z`

实际处理过程为：对输入图像做直方图均衡得到 `s` 灰度的图，然后对此图中每个像素执行反映射 $z=G^{-1}(s)$（s 到 z 的映射），得到最终输出图像。

## 4.3 局部直方图处理
对每个位置的邻域计算直方图，然后进行均衡化或者应用其他匹配变换函数，用于修改这个邻域中心的灰度，然后平移邻域（一个像素位置或者移到另一个非重叠区域）。

## 4.4 直方图统计
令 `r` 为表示灰度的离散随机变量，归一化的直方图为 $p(r)$，应用概率相关的知识，`r` 的 n 阶（中心）矩定义为，
$$\mu_n(r)=\sum_{i=0}^{L-1} (r_i-m)^n p(r_i)$$
其中 `m` 是期望（或称平均灰度）$m=\sum_0^{L-1} r_i p(r_i)$

二阶矩（灰度方差）为
$$u_2(r)=\sum_{i=0}^{L-1}(r_i-m)^2 p(r_i)$$
通常用 $\sigma^2$ 表示，单独列出二阶矩是因为比较重要。

实际给定一个图像时，可以直接计算样本均值和样本方差，无需计算直方图，
$$m=\frac 1 {MN} \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} f(x,y)
\\\\ \sigma^2=\frac 1 {MN} \sum_{x=0}^{M-1} \sum_{y=0}^{N-1} [f(x,y)-m]^2$$
以上方差计算有时候使用 $MN-1$ 作为分母，以获得一个无偏估计，实际中，使用 $MN$ 作为分母的偏差可忽略不计。

考虑点 $(x,y)$ 的邻域 $S_{xy}$，仿照上面全局统计量可写出局部均值和局部方差如下，
$$m_{s_{xy}}=\sum_{i=0}^{L-1}r_i p_{s_{xy}} (r_i)
\\\\ \sigma_{s_{xy}}^2 = \sum _{i=0}^{L-1} (r_i - m_{S_{xy}})^2 p_{s_{xy}}(r_i)$$

有时候只需要对图像上暗区进行增强，亮区保持不变，所以需要先判断当前邻域属于暗区还是亮区，记全局均值为 $m_G$，如果 $m_{s_{xy}} \le k_0 m_G$，其中 $0< k_0 < 1.0$，那么属于暗区，对其进行局部增强。

如果想增强低对比度的局部区域，那么判断方法为 $\sigma_{s_{xy}} \le k_2 \sigma_G$。当然一般还会设置一个阈值下限，例如对比度为 0 的恒定区域，其实是没必要增强的，所以 $k_1 \sigma_G \le \sigma_{s_{xy}} \le k_2 \sigma_G$。对于满足增强条件的点而言，增强操作可以是将像素值乘以一个常数 `E` ，这样这个点相对于图像上其他不需要增强的点，像素得以增大（或减小）。

总结增强方法如下，
$$g(x,y)=\begin{cases} E \cdot f(x,y) & m_{s_{xy}} \le k_0 m_G, \ k_1 \sigma_G \le \sigma_{s_{xy}} \le k_2 \sigma_G 
\\\\ f(x,y) & \text{otherwise} \end{cases}$$