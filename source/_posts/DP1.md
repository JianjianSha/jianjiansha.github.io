---
title: DP1
date: 2019-08-07 17:29:56
tags: math, DP
category: math
mathjax: true
---
我计划开启一系列动态规划的方法介绍，主要参考 《Dynamic Programming · A Computational Tool》这本书。

# 简介

动态规划用于解决一类优化问题，顺序地做出决策，每一次决策使得问题转变为对一个子问题的优化，直到问题解决，这个决策序列就是原始问题的最优解。我们也可以将 问题/子问题 看作状态，决策就是状态间的转移，问题得到解决就对应着`结束状态`。

## 优化原理

> 一个最优决策满足：无论问题初始状态和初始决策是什么，剩余的决策序列构成做出初始决策之后问题状态的最优解。

这类似于最短路径算法：在一个指定了起点和终点的有权路径图中，无论之前选择了什么路径，我们必须保证从当前节点起，剩余的路径选择必须是最优的。这是一种递归的处理方式，要解这个问题，直觉告诉我们似乎可以采用逆推法，这个直觉很重要，因为下文将会用到它。  
_注：这里我们讲 “类似于” 是因为最短路径问题可以看作动态规划的一种特例，因为最短路径问题是有时序的，且问题的所有常规解（也包含最优解）对应的决策集中决策数量可能会有所不同_

### 顺序决策过程
考虑具有如下形式的优化问题：$opt_{d \in \Delta} \{H(d)\}$，其中 d 为决策，决策空间为 $\Delta$，H 为目标函数，H(d) 的最优解记为 $d^{\ast}$：$d^{\ast}=\arg opt_d \{H(d)\}$。动态规划问题则要求寻找有序决策集 $\{d_1,...,d_n\}$，使得目标函数 $h(d_1,...,h_n)$ 取得最优 $H^{\ast}$。

我们可以枚举 $\{d_1,...,d_n\}$ 所有可能的取值，然后代入目标函数进行计算，这就是 “暴力” 解法，但是这只在决策空间较小时有效，在决策空间很大时，这种方法效率非常低不可取，所以此时我们需要按顺序做出决策 $d_1,...,d_n$，使得
$$\begin{aligned}H^{\ast}&=opt_{(d_1,...,d_n)\in \Delta} \{h(d_1,...,d_n)\}
\\\\ &=opt_{d_1 \in D_1} \{...\{opt_{d_n \in D_n}\{h(d_1,...,d_n)\}\}...\} \quad(1.1)\end{aligned}$$

其中 $(d_1,...,d_n) \in \Delta=D_1 \times ... \times D_n$。通常，第 i 个决策空间依赖于前面所有的决策：$d_i \in D_i(d_1,...,d_{i-1})$，于是式 (1.1) 可改写为
$$\begin{aligned}H^{\ast}&=opt_{(d_1,...,d_n)\in \Delta} \{h(d_1,...,d_n)\}
\\\\ &=opt_{d_1 \in D_1} \{...\{opt_{d_n \in D_n(d_1,...,d_{n-1})}\{h(d_1,...,d_n)\}\}...\} \quad(1.2)\end{aligned}$$

式 (1.2) 的优化操作是一个嵌套结构，根据前面所提的那个直觉，可以由内向外解决问题。解最内层的优化问题，此时前序所有决策均看作已知，可得到最优 $d_n$，记作 $d_n^{\ast}(d_1,...,d_{n-1})$。向外逆推，直到解出最外层优化问题 $opt_{d_1 \in D_1} \{h(d_1,d_2^{\ast},...,d_n^{\ast} \}$ 的解 $d_1^{\ast}$。

如果改变决策顺序目标函数的最优解相同，如
$$\begin{aligned} &opt_{d_1 \in D_1} \{opt_{d_2 \in D_2(d_1)} \{... \{opt_{d_n \in D_n(d_1,...,d_{n-1})} \{h(d_1,...,d_n)\}\}...\}\}
\\\\ = \ & opt_{d_n \in D_n} \{opt_{d_{n-1} \in D_{n-1}(d_n)} \{... \{opt_{d_1 \in D_n(d_2,...,d_n)} \{h(d_1,...,d_n)\}\}...\}\} \end{aligned}$$

那么决策空间 $D_i$ 可能会跟之前有所不同，因为此时 $D_i$ 依赖于 $(d_{i+1},...,d_n)$，所以问题求解的效率会随着决策顺序的变化而有所改变。