---
title: Dynamic Programming (2)
date: 2019-08-14 14:36:05
p: dp/DP2
tags: 
    - math
    - DP
mathjax: true
---
上一篇文章 [Dynamic Programming (1)](2019/08/07/DP1) 介绍了动态规划的原理，以及几种常见模型的 DPFE。这篇文章则主要介绍一些实际应用。

## 最佳分配问题 ALLOT
最佳分配问题简称为 ALLOT，描述了如何讲有限资源分配给一些用户，损失（或者利益，损失对应最小化，利益对应最大化）与用户以及分配到的资源量有关。ALLOT 也可以看作是背包问题 KSINT 的一个变种。

<!-- more -->

假设有 M 单位的资源要分配给 N 个用户，记 C(k,d) 表示分配 d 单位资源给用户 k 时的损失，分配决策按阶段进行，即第一阶段分配 $d_1$ 单位资源给用户 1，第二阶段分配 $d_2$ 单位资源给用户 2，依次进行，定义状态 (k,m) 为阶段 k 时剩余 m 单位资源，阶段 k 分配之前的资源量为 m，阶段 k 的分配损失为 C(k,d)，下一阶段状态为 (k+1,m-d)，于是根据 [Dynamic Programming (1)](2019/08/07/DP1) 中式 (1.19) 可知 DPFE 为
$$f(k,m)=\min_{d \in \\{0,...,m\\}} \{C(k,d)+f(k+1,m-d)\} \quad (2.1)$$
目标是求 f(1,M)，基本条件为 f(N+1,m)=0，其中 $m \ge 0$，这表示资源可以不用全部瓜分完。

现在假设有 M=4，N=3，且
$$(C_{k,d})_{k\in \{1,2,3\};d\in \{0,...,4\}}=\begin{pmatrix}\infty & 1.0 & 0.8& 0.4 & 0.0 \\\\ \infty & 1.0& 0.5 & 0.0 & 0.0 \\\\ \infty & 1.0 & 0.6 & 0.3 & 0.0 \end{pmatrix}$$
那么，f(1,M)=1.0+0.5+1.0=2.5，最佳分配序列为 $d_1=1,d_2=2,d_3=1$。我们可以根据式 (2.1) 逐步展开计算，下面是代码实现，
```python
def allot(cache=True):
    M=4
    N=3
    max_float=1e8
    cost=[[max_float, 1.0, 0.8, 0.4, 0.0],
          [max_float, 1.0, 0.5, 0.0, 0.0],
          [max_float, 1.0, 0.6, 0.3, 0.0]]
    
    if cache:
        cache_dict = {}
    def allot_inner(k,m):
        if cache and (k,m) in cache_dict:
            return cache_dict[(k,m)]
        if k>= N: return [], 0

        min_f=max_float
        min_ds = []
        for d in range(m+1):
            ds,f=allot_inner(k+1,m-d)
            temp=cost[k][d]+f
            if min_f > temp:
                min_f = temp
                min_ds = [d]+ds
        if cache and k > 1:
            cache_dict[(k,m)]=(min_ds,min_f)
        return min_ds, min_f
    ds, f=allot_inner(0,M)
    print("min cost:",f,"opt allotments:", ds)
```



## 所有结点对的最短路径问题 APSP

在图中寻找从任一起点 s 到任一终点 t 之间的最短路径，记图中结点数量为 N，为简单起见，我们假设任意结点对之间没有非正长度的环，并且没有自环（self-loop）。

可以利用 [Dynamic Programming (1)](2019/08/07/DP1) 中的最短路径模型，将 (s,t) 看作变量，求得一系列的最短路径值，然后再求最小值即可，但是这其中肯定存在一些重复计算，所以这里我们讨论更高效率的计算方法。

__Relaxation__ 

定义 F(k,p,q) 为从 p 到 q 之间的最短路径长度，k 表示从 p 到 q 最多走 k 步（从一个节点到下一个节点为一步）。借助 [Dynamic Programming (1)](2019/08/07/DP1) 中式 (1.27)，DPFE 为
$$F(k,p,q)=\min \{F(k-1,p,q), \min_{r \in succ(p)} \{b(p,r)+F(k-1,r,q)\}\} \quad(2.2)$$
其中 r 是 p 的直接后继节点。基本条件为:
1. $F(k,p,q)=0, k \ge 0, p=q$，表示当 p 就是 q 时，最多走 k 步，最短路径长度为 0。
2. $F(0,p,q)=\infty, p \ne q$， 表示当 p 不为 q 时，最多走 0 步，最短路径长度为无穷大。

虽然我们假定没有自环，但是我们依然可以令 $b(p,p)=0$（实际路径中我们可以去掉环即可），那么式 (2.2) 可简化为
$$\begin{aligned}F(k,p,q)&=\min \{F(k-1,p,q)+b(p,p), \min_{r \in succ(p)} \{b(p,r)+F(k-1,r,q)\}\} \\\\ &=\min_{r \in succ(p)\cup \{p\}} \{b(p,r)+F(k-1,r,q)\} \qquad(2.3) \end{aligned}$$


__Floyd-Warshall__ 

式 (2.2) 这个 DPFE 是一种分而治之的思想：从 p 到 q 最多走 k 步的路径，可以分为从 p 走一步到 r 以及从 r 最多走 k-1 步到 q 两个子路径。还有一种替代方案是从 p 到 r 并且从 r 到 q，其中 p 到 r 的步数不再固定为 1，但是从 p 出发，到达 q 总共最多经过 k 个点，r 就是这 k 个中间点，不妨记这 k 个点为 $\{1,2,...,k\}$，那么求从 p 到 q 并使用 $\{1,2,...,N\}$ 作为可能的中间点的最短路径就是 p 到 q 的全局最短路径。DPFE 为
$$F(k,p,q)=\min \{F(k-1,p,q), F(k-1,p,k)+F(k-1,k,q)\} \qquad(2.4)$$

为了便于理解，我们作如下说明：
1. 将 N 个节点编号为 $V=\{1,2,...,N\}$，$p,q \in V$
2. $F(k,p,q)$ 表示从 p 到 q 且以 $\{1,2,...,k\}$ 作为可能的中间节点
3. 问题的求解目标为 $F(N,p,q)$
4. 如何理解式 $(2.4)$？
   - p 到 q 的路径不经过中间点 k，即，使用 $\{1,2,...,k-1\}$ 作为可能的中间节点
   - 或者 p 到 q 的路径经过中间点 k，即，分为两个子路径 p 到 k 和 k 到 q，这两个子路径均使用 $\{1,2,...,k-1\}$ 作为可能的中间节点
5. 式 $(2.4)$ 这个递归操作需要条件 k>0。k=0 时为基本条件 $F(0,p,q)=0, p=q$，以及 $F(0,p,q)=b(p,q), p\ne q$。前者表示当 p q 为同一节点时，不使用任何中间节点，损失为 0；后者表示当 p q 不同时，不使用任何中间节点，损失为 $b(p,q)$，需要注意这里 q 是 p 的直接后继，如果不是，那么有 $F(0,p,q)=\infty, p \notin succ(p) \cup \{p\}$
6. 中间点序列 $\{1,2,...,k\}$ 可能会包含 p 和 q，如果包含了的话，由于我们假定所有的环都是正的，所以再求序列最小值的，带环的路径均会被过滤掉，而自环 $b(p,p)=0$，不会影响最短路径的长度，如果路径中出现自环，去掉即可（去掉连续重复的节点，只保留一个）。

式 (2.2) 中 r 是 p 的后继节点，最多可取 $N-1$ 个节点（假设图中其他节点均为 p 的后继节点，就对应 $N-1$），k 最大为 $N-1$ 步，p 和 q 均各有 N 个取值，所以式 (2.2) 的时间复杂度为 $O(N^4)$，类似地，式 (2.4) 的时间复杂度为 $O(N^3)$。

实际中要解决 APSP 问题，可以根据式 (2.2) 求出矩阵序列 $\{F^{(1)},F^{(2)},...,F^{(N-1)}\}$，任一矩阵 $F^{(k)}$ 维度为 $N \times N$，$F_{p,q}^{k}$ 表示从 p 到 q 最多走 k 步的最短路径长度，然后求 $\min_{p,q} F_{p,q}^{(N-1)}$ 就是 APSP 的解。

__矩阵乘法__

为了借鉴矩阵乘法的思想，我们首先将式 (2.2) 作变换，
$$\begin{aligned} F(k,p,q)&=\min \{F(k-1,p,q), \min_{r \in succ(p)} \{b(p,r)+F(k-1,r,q)\}\}
\\\\ &= \min_{r \in succ(p)} \{b(p,p)+F(k-1,p,q), b(p,r)+F(k-1,r,q)\}
\\\\ &= \min_{r \in succ(p) \cup \{p\}} \{b(p,r)+F(k-1,r,q)\}
\\\\ &= \min_{r \in \{1,2,...,N\}} \{b(p,r)+F(k-1,r,q)\} \qquad(2.5) \end{aligned}$$
其中，$b(p,r)$ 是事先给定的任意两节点之间的距离，若两节点之间没有边 edge 相连，则距离为 $\infty$，这里称所有节点对之间的距离组成的矩阵为权重矩阵 $W_{N \times N}$。根据式 (2.2) 的基本条件，不难得知 $F^{(0)}$ 矩阵对角线全 0，其余元素均为 $\infty$：

$$F^{(0)}=\begin{bmatrix}0 & \infty & \cdots & \infty
\\\\                    \infty & 0  & \cdots & \infty
\\\\                    \vdots & \vdots & \ddots & \vdots
\\\\                    \infty & \infty & \cdots & 0 \end{bmatrix}_{N \times N}$$

$$W=\begin{bmatrix}0 & w_{12} & \cdots & w_{1N}
\\\\                    w_{21} & 0  & \cdots & w_{2N}
\\\\                    \vdots & \vdots & \ddots & \vdots
\\\\                    w_{N1} & w_{N2} & \cdots & 0 \end{bmatrix}_{N \times N}$$

根据式 (2.5)，已知 $F^{(k-1)}$ 求 $F^{(k)}$ 的代码为
```python
import sys
F_k=[[None]*N]*N
for p in range(0,N):
  for q in range(0,N):
    F_k[p][q]=sys.info.float_max
    # F_k[p][q]=0
    for r in range(0,N):
      F_k[p][q]=min(F_k[p][q],W[p][r]+F_k_1[r][q])
      # F_k[p][q]=F_k[p][q]+W[p][r]*F_k_1[r][q])
```
从上面代码片段可见，与矩阵乘法（注释部分）完全一个模样，而我们的目的是为了计算 $F^{(N-1)}$，中间的其他 $F^{(k)}$ 矩阵如无必要，可以不用计算出来，比如下面，
$$\begin{aligned} F^{(1)}&=W \circ F^{(0)}=W
\\\\ F^{(2)}&=W \circ F ^ {(1)}=W ^ 2
\\\\ F^{(3)}&=W \circ F ^ {(2)}=W ^ 3
\\\\ &\vdots
\\\\ F^{(N-1)}&=W \circ F ^ {(N-2)}=W ^ {(N-1)} \end{aligned} \quad(2.6)$$

$\circ$ 表示某种运算符，比如矩阵乘法或者这里的最小值计算，我们改为如下序列计算，
$$\begin{aligned} F^{(1)}&=W
\\\\ F ^ {(2)}&=W ^ 2=W \circ W
\\\\ F ^ {(4)}&=W ^ 4=W ^ 2 \circ W ^ 2
\\\\ &\vdots
\\\\ F^{2 ^ {\lceil log(N-1) \rceil}}&=W ^ {2^{\lceil log(N-1) \rceil}} =W ^ {2^{\lceil log(N-1) \rceil-1}} \circ W ^ {2 ^ {\lceil log(N-1) \rceil-1}} \end{aligned} \quad(2.7)$$
注意上面 $2^{\lceil log(N-1) \rceil}$ 中的向上取整 $\lceil \cdot \rceil$ 很重要，这保证了 $2 ^ {\lceil log(N-1) \rceil} \ge N-1$，从而 $F ^ {2 ^ {\lceil log(N-1) \rceil}} \le F^{(N-1)}$ （element-wise comparison）。

因为结合顺序无关紧要，才使得我们可以从式 (2.6) 可以改写为式 (2.7)，例如
$$\begin{aligned}F^{(4)} &=W \circ F^{(3)}
\\\\ &=W \circ (W \circ F^{(2)})
\\\\ &=\cdots 
\\\\ &=W \circ(W \circ (W \circ W)) 
\\\\ &\stackrel{*}=(W \circ W) \circ (W \circ W)
\\\\ &=W^2 \circ W^2
\end{aligned}$$
将 $\circ$ 替换为 $\min$，即 $\min (W, \min(W, \min(W,W)))=\min(\min(W,W), \min(W,W))$，注意这里的 $\min$ 不是 element-wise operator，就跟矩阵乘法不是矩阵点乘一样。当然，以上内容只是帮助理解，不是式 (2.6) 可以变换为式 (2.7) 的严格证明。

好了，有了式 (2.7) 就可以更快的计算出 $F^{(M)}, M \ge N-1$，由于 $F^{(k)}$ 单调减，并收敛于 $F^{(N-1)}$，于是 $F^{(M)}$ 就是全局最短路径长度矩阵。

使用矩阵乘法加速的算法代码为
```python
import sys

def fast_apsp():
  k=1
  F_prev=W
  while k<N-1:
    F_next=[[sys.info.float_max]*N]*N
    for p in range(0,N):
      for q in range(0,N):
        for r in range(0,N):
          F_next[p][q]=min(F_next[p][q], F_prev[p][r]+F_prev[r][q])
    F_prev=F_next
    k*=2
  return F_prev
```

__Floyd-Warshall__ 的代码

考虑式 (2.4)，注意 $F^{(k)}$ 中的 k 表示路径可以经过中间节点 $\{1,2,...,k\}$，所以 $F^{(0)}$ 表示不经过任何中间节点的两点之间最短路径长度矩阵，所以根据基本条件不难得到
$$F^{(0)}=W=\begin{bmatrix}0 & w_{12} & \cdots & w_{1N}
\\\\                    w_{21} & 0  & \cdots & w_{2N}
\\\\                    \vdots & \vdots & \ddots & \vdots
\\\\                    w_{N1} & w_{N2} & \cdots & 0 \end{bmatrix}_{N \times N}$$

根据式 (2.4)，不难写出原始的 __Floyd-Warshall__ 算法的代码为
```python
F_prev=F_0
def floyd_warshall():
  for k in range(0,N):
    F_next=[[None]*N]*N
    for p in range(0,N):
      for q in range(0,N):
        F_next[p][q]=min(F_prev[p][q], F_prev[p][k]+F_prev[k][q])
    F_prev=F_next
  return F_prev
```

## 最优字母基数编码树问题 ARC

ARC 是霍夫曼编码树问题的一个变体。霍夫曼树要满足的条件是节点权值*路径长度，求和最小。比如常见的霍夫曼编码，节点权值对应词频，路径对应单个词的编码长度，加权求和就是编码后的序列总长度最小。构造霍夫曼树可以直接使用贪心算法，给定一个具有权值的节点序列，找出具有最小权值的两个节点，构造出一个子树，这两个节点为子树的子节点，子树的父节点权值为这两个子节点的权值之和，然后将这两个字节点从节点序列中移除，并插入新构造的父节点到节点序列，重复这个过程，直到节点序列中只剩一个节点。这是一个自底向上的构造过程。

ARC为，给定一个具有构造成本（权值）的节点序列，目标是构造一棵成本最小的树，整棵树的总成本为所有内部节点（internal nodes，包括 root）的成本之和，内部节点的损失为以此内部节点为根节点的子树中所有叶节点的成本之和。给定 $S=(w_0,w_1,...,w_{n-1})$ 为有序序列表示叶节点的权值，定义 $(i,j)$ 的态为 $(w_i,...,w_j)$，那么
$$f(i,j)=\min_{}\{c(i,j,d)+f(i,d)+f(d+1,j)\}, \quad i<j \qquad(2.8)$$
其中 $f(i,j)$ 表示以节点 $(i,...,j)$ 为叶节点的子树总成本， $c(i,j,d)=\sum_{k=i}^j w_k$ 表示这个子树的根节点的成本，这里我们限制为二叉树，所以不难理解式 (2.8)，树的总成本为左子树的总成本与右子树的总成本以及树根节点成本三者之和。d 用于划分，其中 $(i,...,d)$ 为左子树的叶节点，$(d+1,...,j)$ 为右子树的叶节点，无论怎么划分（即选择任何 d 的有效值），以 $(i,...,j)$ 为叶节点的子树的根节点成本 $c(i,j,d)$ 均保持不变。

最后，目标是计算 $f(0,n-1)$，基本条件为 $f(i,i)=0, \ \forall i \in \{0,1,...,n-1\}$。

构造 ARC 比构造 Huffman 树多一个限制，那就是给定节点序列后，只能结合两个相邻节点构造一个子树。例如，$S=(1,2,3,4)$，最优树为 $(((1,2),3),4)$，$f(S)=3+6+10=19$（三个内部节点成本之和），再例如 $S=(2,3,3,4)$，那么最优树为 $((2,3),(3,4))$，$f(S)=5+7+12=24$。

  
## 装配线平衡问题 ASMBAL
一个产品装配需要经过一系列的处理，每个处理步骤均有代价/损失，并且从一个处理站到另一个处理站之间也存在代价。这里举一个简单的例子进行说明，一个处理站看作一条处理线，一次处理为一个阶段 stage，转移发生在从 阶段 k，处理线 i 的节点到另一个位于阶段 k+1 处理线 j 的节点上。处理线之间的切换损失为 c(k,i,j)，通常 c(k,i,i)=0，即不切换处理线，那么切换损失应为 0，除了切换损失，每个节点自身还存在损失，初始状态 s 和终止状态 t 处于标记为 0 的处理线上，这只是为了说明初始时刻和终止时刻产品不应该在任何处理线上，初始决策的损失为 c(0,0,j)，最终决策的损失为 c(N,j,0)（j 为某个处理线）。 

某种可行的处理使用一个节点表示，记节点标号为 0~13 共 14 个节点，其中特别地 0 和 13 分别表示起始状态和终止状态，即表示不用处理。假设 14 个节点自身的损失分别为
$$v=(0,7,8,9,5,3,6,4,8,5,4,7,0)$$
处理线之间的切换损失如下图，
![](/images/DP2_fig1.png)

也可以写成 14x14 的毗邻矩阵。可见，总共有两条处理线。

在阶段 k，从 i 线到 j 线的损失由两部分组成 $R(k,i,j)=v(k,i)+c(k,i,j)$，DPFE 为
$$f(k,i)=\min_j \{R(k,i,j)+f(k+1,j)\}$$
其中 $f(k,i)$ 表示从阶段 k 并处于线 i 上开始到最终态的损失，问题的目标就是求 $f(0,0)$，基本条件为 $f(k,i)=0, k > N$，N 为总阶段数，图中为 N=6。计算过程如下：
$$\begin{aligned} f(0,0)=\min \{R(0,0,0)+f(1,0), R(0,0,1)+f(1,1)\}
\\\\ f(1,0)=\min \{R(1,0,0)+f(2,0), R(1,0,1)+f(2,1)\}
\\\\ f(1,1)=\min \{R(1,1,0)+f(2,0), R(1,1,1)+f(2,1)\}
\\\\ \cdots \ (omitted)
\end{aligned}$$

## 最佳分派问题 ASSIGN
集合 B 中的每个成员需要唯一地被赋值为集合 A 中的成员，如何 A 是有序的，那么这个过程也可以看作是 A 的一种排列，例如 $\{1,2,3\}$ 的一种排列为 $\{3,2,1\}$（总共有 3! 种排列）。集合 $A=(a_0,a_1,...,a_{n-1})$ 的某个排列 $B=(b_0,b_1,...,b_{n-1})$ 可按如下过程得到：在阶段 i，赋值 $a_j$ 给 $b_i$，对应的损失为 $c(i,j)$。由于赋值必须是唯一的，所以每个阶段需要跟踪集合 A 中还有多少尚未使用的成员。具体而言，我们记状态为 $(k,S)$，表示阶段 k 集合 A 中尚未使用的成员集合为 S，阶段 k 时选择成员 d，相应的损失记为 $C(k,S,d)$，下一状态为 $(k+1,S-\{d\})$，DPFE 为
$$f(k,S)=\min_{d \in S} \{C(k,S,d)+f(k+1,S-\{d\})\}$$
求解目标为 $f(1,S^{\ast})$，基本条件为 $f(k,S)=0, \ k=n+1 \ or \ S=\emptyset$

## 最佳二叉搜索树问题 BST
假设包含 n 个数据的集合 $X=\{x_0,...,x_{n-1}\}$，并且是 __有序__ 的，每个数据 $x_i$ 的被访问概率为 $p(x_i)$，或简写为 $p_i$，且有 $\sum_{i=0}^{n-1}p_i=1$，目标是建立一棵最小损失的二叉搜索树，其中树的损失定义为
$$\sum_{i=0}^{n-1}(p_i \text{level}(x_i))$$
$\text{level}(x_i)$ 表示 $x_i$ 所在节点的深度。需要注意的是，节点不仅可存储在叶节点中，还可以存储在内部节点中。下面我们讨论如何使用 DP 来解决这个问题。

### 方法一
定义状态 S 为待安排到树中的元素集合，由于构造树是一个递归过程，易知 DPFE 为
$$f(S)=\begin{cases} \min_{\alpha \in S} \{f(S_l)+f(S_r)+r(\alpha, S)\} & S \ne \emptyset
\\\\ 0 & S=\emptyset \end{cases}$$
其中 $S_l = \{x \in S: x < \alpha\}, \ S_r = \{x \in S: x > \alpha\}$，决策代价 $r(\alpha, S)=\sum_{x \in S} p(x)$，根节点深度为 1。这个 DPFE 非常简单，不多说。

以上 $S_l,\ S_r$ 的划分保证了二叉树是 __有序__ 的。（若不需要保持有序，此问题与霍夫曼编码相同）

上式可改写为
$$f(S)=\begin{cases} \min_{\alpha \in S} \{f(S_l)+f(S_r)+r(\alpha, S)\} & |S|>1
\\\\ p(x) & S=\{x\} \end{cases}$$

### 方法二
定义状态为一对整数 $(i,j)$，分别表示数据的起始下标和截止下标，在此范围内的数据是需要被安排进树的，已知数据集合为 $X=\{x_0,...,x_{n-1}\}$，那么 DPFE 为
$$f(i,j)=\begin{cases} \min_{k \in \{i,...,j\}} \{f(i,k-1)+f(k+1,j)+\sum_{l=i}^j p_l\} & i \le j
\\\\ 0 & i > j \end{cases}$$
$(i,j)$ 表示待安排进树的节点下标的起止范围，即将从此范围中选择下标为 k 的数据作为当前节点，或称子树根节点，这个子树的所有节点对应数据下标范围为 $(i,j)$, 其中$(i,k-1)$ 用于被安排进当前子树的左子树，$(k+1,j)$ 用于被安排进当前子树的右子树，无论当前选择哪个决策 k，$(i,j)$ 范围内的数据的概率在当前层 level 均需被计算一次，因为是从上到下构造树的，所以每到达一个 level，所有到达这个 level 的数据其访问概率需要被计算一次，在 $f(i,j)$ 中，$(i,j)$ 范围内的数据均到达当前 level，属于待安排进树的数据，所以当前决策损失为累加所有到达当前 level 的数据的访问概率，即 $\sum_{l=i}^j p_l$。

与方法一同样地可改写上式为
$$f(i,j)=\begin{cases} \min_{k \in \{i,...,j\}} \{f(i,k-1)+f(k+1,j)+\sum_{l=i}^j p_l\} & i < j
\\\\ p_i & i = j \end{cases}$$

## 最佳覆盖问题 COV
假设有 k 个不同大小的灌木需要在严寒中被保护起来，k 个灌木按大小排序，标号为 0 的灌木尺寸最小，假设灌木的保护措施就是制造覆盖，将其覆盖起来进行保护，大小为 i 的覆盖其制造成本为 $c_i$。由于技术限制，只能制造不超过 n 种尺寸的覆盖，且 $n \le k$，已知大的覆盖能用于保护小的灌木，目标是选择 n 种覆盖尺寸，使得能覆盖所有的灌木，且成本最小。

使用 DP 解决上述问题，为了方便，我们假设灌木尺寸按从小到达排好序，编号为 $0,1,...,k-1$，编号为 $l$ 的灌木尺寸为 $s_l$，其对应的覆盖制造成本为 $c_{s_l}$，简记为 $c_l$，这里为了使问题简单，我们不考虑使用多个较小尺寸的覆盖来保护较大尺寸的灌木，即，每个灌木只使用单个覆盖。一种显然的想法是，从大到小来制造覆盖，因为大尺寸的覆盖总能保护小尺寸的灌木，令 $j$ 表示当前还可以制造多少种尺寸的覆盖，$l$ 表示当前未得到保护的最大尺寸灌木编号，于是 DPFE 为
$$f(j,l)=\begin{cases} \min_{d \in \{j-2,...,l-1\}} \{(l-d)c_l+f(j-1,d)\} & j>1
\\\\ (l+1)c_l & j=1 \end{cases}$$
d 表示灌木尺寸范围的起始下标（exclusive），也就是说当前决策是制造尺寸为 $s_l$ 的覆盖，用于保护 $\{d+1,...,l\}$ 范围内的灌木。显然 d 最大为 $l-1$，此时当前决策所制造的覆盖只用于保护编号为 $l$ 的灌木，d 最小为 $j-2$，这是因为当前决策所制造的覆盖最多能用于保护灌木的编号为 $\{j-1,...,l\}$，此时剩余尚未保护的灌木编号 $\{0,1,...,j-2\}$ 共 $j-1$ 种尺寸，正好剩余可以制造的覆盖尺寸也是 $j-1$ 种，两者一一对应。

再看基本条件，$f(j,l)=(l+1)c_l, j=1$，表示当前只能制造一种尺寸的覆盖时，那只能制造当前尚未得到保护的最大灌木的尺寸的覆盖，当前最大尺寸的灌木编号为 $l$，由于只有这一种尺寸的覆盖可以制造，其必须保护 $0,...,l$ 范围内的灌木。

## 时限调度问题 DEADLINE
有一个进程集合，其中每个进程的执行时间均为单位时间，同时每个进程也各自有一个最后期限，如果在最后期限之前完成，则具有收益，否则收益为 0，现在要选择一个最优进程子集，放置在单处理器上执行，并且收益要最大。这个问题当然也可以使用贪心算法来解决，那些收益较大的进程我们总希望能被执行，无论是先执行还是后执行，反正只要在其最后期限之前被执行即可，那么不如优先执行这些收益最大的进程，即， __每一步优先执行收益最大的进程__。

假设进程编号为 $S^{\ast}=\{0,1,2,3,4\}$，对应收益为 $p=\{10,15,20,1,5\}$，截止期限为 $t=\{1,2,2,3,3\}$。贪心算法的代码如下：
```python
import numpy as np
t=np.array([1,2,2,3,3])
p=np.array([10,15,20,1,5])
m=0   # 总收益
n=t.shape[0]  # 最多决策数

for i in range(n):
  idx=np.where(t>0)[0]
  if idx.shape[0]==0:
    break   # 全部超出最后期限，决策结束
  c=np.max(p[idx])  # 尚未超出期限的进程的最大收益，当前最优决策的收益（贪心策略）
  if c < 0:
    break
  m+=c
  idx=np.argmax(p[idx])+idx[0]  # 当前决策的进程的编号
  p[idx]=-1e8                   # 标记收益为负，表示后续决策不再考虑此进程
  t-=1                          # 更新进程的最后期限
print('最大收益为', sep=' ')
print(m)    # 40
```

使用 DP 解决这个问题，定义状态为 $(k,S)$，其中 k 为阶段编号，S 为所有尚未执行的进程集合，每一步的决策 d 是从 S 中选出，决策后的下一状态为 $(k+1,S-\{d\})$，根据最后期限从近到远对进程进行排序，DPFE 为
$$f(k,S)=\max_{d \in S}\{c(d|S)+f(k+1,S-\{d\})\}$$
其中，当决策 d 的最后期限大于等于阶段 k 时（k 从 1 开始计算）$c(d|S)=w_d$ ，否则 $c(d|S)=0$。目标是求 $f(1,S^{\ast})$，基本条件为 $f(k,S)=0, k=n+1 \ or \ S=\emptyset$，其中 n 为进程数。使用上述例子，代码如下
```python
t=[1,2,2,3,3]
p=[10,15,20,1,5]
S=[0,1,2,3,4]
n=len(t)
def profit(k,d):
  return p[d] if t[d]>=k else 0

def deadline(k,S):
  return 0 if len(S)==0 or k==n+1 else \
    max([profit(k,S[i])+deadline(k+1,S[:i]+S[i+1:]) for i in range(len(S))])

print(deadline(1, S))   # 40
```

## 折现利润问题 DPP
假设一个湖中第一年开始时有 $b_1$ 条鱼，第 t 年开始时的鱼数为 $b_t$，在第 t 年中售出 $x_t$ 条鱼，收益为 $r(x_t)$，捕鱼成本为 $c(x_t,b_t)$，鱼可以再生，再生长率为 s，表示某一年年初的鱼数量是上一年年底鱼数量的 s 倍，计划展望期为 $1,...,T$，即最多 T 年卖完所有鱼，其中货币年贬值率为 y，决策为 $x_t$ 表示 第 t 年卖出多少鱼，要求最大净收益，状态为 $(t,b)$，其中 t 表示年份，b 表示第 t 年初的鱼数，DPFE 为
$$f(t,b)=\begin{cases} \max_{x_t \in \{0,...,b\}} \{r(x_t)-c(x_t,b)+\frac 1 {1+y} f(t+1, \lfloor s(b-x_t) \rfloor)\} & t \le T
\\\\ 0 & t=T+1 \end{cases}$$


## 编辑长度问题 EDP
编辑长度问题通常用于字符串的非精确匹配问题。记 $\Sigma$ 为一有限字符集，给定两个字符串 $x\in \Sigma^m, \ y \in \Sigma^n$，或者写为 $x=x_1\cdots x_m, \ y=y_1 \cdots y_n$，任务是将 x 转变为 y，并且只能使用如下三种编辑操作：
- 删除操作 D。从某字符串中删除一个字符，损失为 $c(D)$
- 插入操作 I。向某字符串中插入一个字符，损失为 $c(I)$
- 替换操作 R。将某字符串中某个字符替换为另一个字符，损失为 $c(R)$，如果替换前后字符相同，则 $c(R)=0$
  
要求一个编辑序列，使得 x 转变为 y，且具有最小损失，这里损失为所有操作的损失之和。DPFE 为
$$f(i,j)=\begin{cases} jI & i=0
\\\\ iD & j=0
\\\\ \min \{f(i-1,j)+c(D),f(i,j-1)+c(I),f(i-1,j-1)+c(R)\} & i>0,j>0 \end{cases}$$
其中 $f(i,j)$ 表示从 $X_i$ 到 $Y_j$ 需要的操作损失，$X_i$ 为 x 的前 i 个字符形成的子串，$Y_j$ 为 y 的前 j 个字符形成的子串，当 i=0 时，向 $X_i$ 插入 j 个字符得到 $Y_j$，当 j=0 时，将 $X_i$ 删除 i 个字符得到 $Y_j$，当 i>0 且 j>0 时，从 $X_i$ 变换到 $Y_j$，总共可以有以下三种决策/操作，取损失最小的决策：
- 删除 $X_i$ 的第 i 个字符，然后从 $X_{i-1}$ 变换到 $Y_j$，两部分损失分别为 $c(D)$ 和 $f(i-1,j)$
- 从 $X_i$ 变换到 $Y_{j-1}$，然后再在末尾插入一个字符得到 $Y_j$，两部分的操作损失分别为 $f(i,j-1)$ 和 $c(I)$
- 两个子串的最后一个字符，使用替换，$x_i \rightarrow y_j$，然后再从 $X_{i-1}$ 变换到 $Y_{j-1}$ 即可得到 $X_i$ 变换到 $Y_j$ 的过程，两部分的损失分别为 $f(i-1,j-1)$ 和 $c(R)$

还可以写成如下形式的 DPFE
$$f(X_i,Y_j)=\begin{cases} jI & i=0
\\\\ iD & j=0
\\\\ \min_{d \in \{D,I,R\}} \{f(t(X_i,Y_j,d))+c(d)\} & i>0,j>0
\end{cases}$$
其中变换定义为
$$t(X_i,Y_j,D)=(X_{i-1},Y_j)
\\\\ t(X_i,Y_j,I)=(X_i,Y_{j-1})
\\\\ t(X_i,Y_j,R)=(X_{i-1},Y_{j-1})$$
