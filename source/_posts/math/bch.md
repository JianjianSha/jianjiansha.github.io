---
title: BCH编码
date: 2024-03-23 17:48:14
tags:
    - math
    - coding
---

**# 伽罗瓦域**

伽罗瓦域 $GF(p ^ m)$，有 $p ^ m$ 个元素，$p$ 是素数，以 $p=2$ 为例，根据本原多项式 $P(x)$ 构造元素，步骤：

1. 初始集合 $\lbrace 0, 1, x \rbrace$

2. 将集合最后一个元素乘以 $x$，如果结果的阶大于等于 $m$，则将结果 $\mod P(x)$，将结果加入集合

    实际上 $x ^ {m+i+1} \mod P(x) = [(x ^ {m+i} \mod P(x)) \cdot x] \mod P(x)$

3. 直到集合中有 $2 ^ m$ 个元素，此时最后一个元素乘以 $x$ 后再 $\mod P(x)$ 的值等于 1 。

例如对 $GF(2 ^ 3)$ ，本原多项式为 $P(x) = x ^ 3 + x + 1$

|幂表示|多项式表示|向量表示| 值表示 |最小多项式|
| -- | -- | -- |--| -- |
|$a ^ 0$| $1$ | 001 | 1 | $x+1$|
|$a ^ 1$| $a$ | 010 | 2 | $x^3 + x+1$|
|$a ^ 2$| $a^2$ | 100 | 4 | $x^3 + x+1$|
|$a ^ 3$| $a+1$ | 011 | 3 | $x^3 + x ^ 2+1$|
|$a ^ 4$| $a^2+a$ | 110 | 6 | $x^3 + x+1$|
|$a ^ 5$| $a^2+a+1$ | 111 | 7 | $x^3 + x ^ 2+1$|
|$a ^ 6$| $a^2+1$ | 101 | 5 | $x^3 + x ^ 2+1$|
|$a ^ 7$| $1$ | 001 | 1 | $x+1$|

<center>表 1</center>

结论：

1. 多项式表示就是幂表示 $\mod P(x)$ 的结果。
2. $a ^ i = a ^ {i+7}$，其中 $7 = 2 ^ m - 1$
3. 根据本原多项式构造出 $GF(2 ^ 3)$ 中的元素就是多项式表示这一列，$a ^ 7$ 这一行不算，$a ^ i, i >= 2 ^ m - 1$ 都不算，重复了
4. 本原多项式阶数为 $m$，在 $GF(2 ^ m)$ 中定义了 $2 ^ m - 1$ 个非零元素（即，多项式表示这一列）
5. 三个最小多项式满足以下关系（注意是经过了 mod 2 处理，即 $x ^ i + x ^ i = 0, \forall i >= 0$）

    $x ^ 7 + 1 = (x ^ 3 + x ^ 2 + 1) (x ^ 3 + x + 1)(x + 1)$
6. $\lbrace a ^ i, \ i = 0, ..., 6\rbrace$ 是单项式，通过本原多项式与多项式表示建立联系
7. 每一行 $a ^ i, \ i >= 0$ 是对应的最小多项式 $M(x)$ 的根，$M(x)$ 的阶数决定它有几个根。

    例如 $M(x) = x ^ 3 + x ^ 2 + x$，一个根为 $x=a ^ 5$，那么

    $$M(a ^ 5) = (a ^ 5) ^ 3 + (a ^ 5) ^ 2 + 1 = a ^ {15} + a ^ {10} + 1$$

    由于 $a ^ 7 = 1$，那么 $a ^ {7k} = \prod _ {i=1} ^ k 1 = 1$，所以 $a ^ {15} = a ^ {15} / 1 = a ^ {15} / a ^ {14} = a$，类似地 $a ^ {10} = a ^ 3 = a + 1$，这里最后一步进行了 $\mod P(x)$ 操作，于是

    $$M(a ^ 5) = a + a + 1 + 1 = 0$$

**# 最小多项式**

假设 $a$ 是 $GF(p^m)$ 域中的一个元素，$a$ 关于 $GF(p^m)$ 的最小多项式是具有最小阶数的多项式，满足

$$p(a)=0$$

且 $p(x)$ 位于 $GF(p)[x]$ 。

性质：

1. 记 $p(x)$ 的阶数为 $d$，有 $d | m$（表示 $m$ 能被 $d$ 整除）
2. 如果 $f(a)=0$，那么 $p(x)|f(x)$
3. $p(x)$ 是 $GF(p)[x]$ 中的素多项式（不可约）
4. 如果 $a$ 是 $GF(p^m)$ 中的基本元，那么其最小多项式 $p(x)$ 是一个本原多项式。（这里要求 $a \ne 1$ ？）

最小多项式 $p(x)$ 的关于根 $a$ 的共轭根为

$$\lbrace a, a ^ p, a ^ {p ^ 2}, \ldots, a ^ {p ^ {d-1}} \rbrace$$

考虑一个最小多项式 $x ^ 3 + x + 1$，其一个根为 $a ^ 1$，用 3 bit 表示为 $(001)$，那么旋转这三个 bits，

$$(001) \rightarrow (010) \rightarrow (100)$$

得到 $a ^ 1, a ^ 2, a ^ 4$，它们共享相同的最小多项式。

考虑最小多项式 $x ^ 3 + x ^ 2 + 1$，一个根 $a ^ 3$，即 $(011)$，旋转为

$$(011) \rightarrow (101) \rightarrow (110)$$

$a ^ 3, a ^ 5, a ^ 6$ 共享相同的最小多项式。

**# 获取本原多项式**

在 $GF(2 ^ m)$ 上，m 阶本原多项式 $P(x)$ 的充要条件是：

1. $P(x)$ 不可约（即，不可因式分解）
2. $P(x)$ 整除 $x ^ {2 ^ m - 1} + 1$，即 $(x ^ {2 ^ m - 1} + 1) \mod P(x) = 0$
3. $P(x)$ 不能整除 $x ^ k + 1, \forall k=1,2,...,2^m - 2$


以 $GF(2 ^ 3)$ 为例，$x ^ 7 + 1 = (x ^ 3 + x ^ 2 + 1)(x ^ 3 + x + 1)(x + 1)$，显然这三个因式均满足条件 `1, 2`，但是 $(x+1)$ 不满足条件 `3`，验证 $(x ^ 3 + x ^ 2 + 1)$ 是否满足条件 `3`：

显然对于 $k < 3$ 的情况肯定满足。当

1. $k=3$，$(x ^ 3 + 1) \mod (x ^ 3 + x ^ 2 + 1) = x ^ 2$
2. $k=4$，$(x ^ 4 + 1) \mod (x ^ 3 + x ^ 2 + 1) = x ^ 2 + x$
3. $k=5$，$(x ^ 5 + 1) \mod (x ^ 3 + x ^ 2 + 1) = x$
4. $k=4$，$(x ^ 6 + 1) \mod (x ^ 3 + x ^ 2 + 1) = x ^ 2 + x + 1$

所以 $P(x)=x ^ 3 + x ^ 2 + 1$ 是一个本原多项式。

类似地可以验证 $P(x)=x ^ 3 + x + 1$ 也是一个本原多项式。

使用 matlab 验证如下，可以看出结果一致。

```matlab
gfprimfd(3, 'all', 2)
%% ans = 
%%      1   1   0   1
%%      1   0   1   1
```

**# 创建 BCH 生成多项式**

BCH 若要纠正 $t$ 个错误，那么从 $\lbrace a ^ i | i=1,2,...,2t\rbrace$ 中选择对应的最小多项式，去掉重复的最小多项式，然后将剩下的最小多项式相乘。

例如上面的例子中，若 $t=1$，那么选择 $a ^ 1, a ^ 2$ 的最小多项式，均为 $x ^ 3 + x + 1$，于是 BCH 生成多项式为

$$G(x) = x ^ 3 + x + 1$$

用二进制表示这个生成多项式为 $(1011)$ 。

若 $t=2$，那么选择 $a ^ 1, a ^ 2, a ^ 3, a ^ 4$ 的最小多项式，去重后得到 

$$G(x) = (x ^ 3 + x + 1)(x ^ 3 + x ^ 2 + 1)$$

这个生成多项式可以纠正 2 个错误，但是由于此时的消息 bit 数只有 1 bit，所以没必要纠正 2 个错误，这种 BCH 编码设计没有意义。

要纠正 1 个错误，生成多项式 $G(x)$ 中就要有 1 个最小多项式因子，要纠正 2 个错误，那么 $G(x)$ 中就要有 2 个最小多项式，编码后的码长为 $2 ^ m - 1$，而 $m$ 个 bits 的数值取值范围可覆盖 $0 \sim 2 ^ m - 1$，故每增加 1 个错误纠正能力，就要相应地增加 $m$ 个校验 bits，所以消息 bit 数为

$$k = 2 ^ m - 1 - m\cdot t$$

**# BCH 编码**

有了生成多项式 $G(x)$ 后，BCH 编码有两种方法。记消息为 $I(x)$

**1. 非系统编码**

编码后码字为 $C(x) = I(x) \cdot G(x)$，即 多项式相乘，这种编码，需要在错误纠正后根据 $I(x) = C(x) / G(x)$ 得到消息数据。

**2. 系统编码**

编码步骤为：

1. $C(x) = I(x) \cdot x ^ {n-k}$

    其中 $n, k$ 分别为码字长度和消息长度。这一步得到阶数为 $n$ 的多项式。

2. $C(x) = C(x) + C(x) \mod G(x)$

    这一步确保了码字能被 $G(x)$ 整除。

在码字经过传输，纠正错误后，直接取左边的 $k$ 个 bits 可得消息数据。

**# 错误纠正**

以 BCH(7, 4) 为例，码字长度 $n=7$，消息长度 $k=4$，码字经过传输引入了 1 bit 错误，记为

$$R(x) = C(x) + E(x)$$

其中 $R(x)$ 为接收的码字，$E(x)$ 表示错误。

根据 $R(x) \mod G(x) = E(x) \mod G(x)$ 的值，可以定位到错误位置，如下表

|$E(x)$|二进制表示|$E(x)\mod G(x)$|二进制表示|数值表示(Syndrome)|错误位置
|--|--|--|--|--|--|
|$0$|0000000|$0$|000|0|-|
|$x^0=1$|0000001|$1$|001|1|G
|$x^1$|0000010|$x$|010|2|F|
|$x^2$|0000100|$x ^ 2$|100|4|E|
|$x^3$|0001000|$x+1$|011|3|D
|$x^4$|0010000|$x ^ 2 + x$|110|6|C|
|$x^5$|0100000|$x ^ 2 + x + 1$|111|7|B|
|$x^6$|1000000|$x ^ 2 + 1$|101|5|A|

<center>表 2</center>

表中第二列是第一列错误多项式的二进制表示，注意根码字一样是 7 位，第三列 $E(x) \mod G(x)$ 的多项式表示，第四、五列则是对应的二进制表示和数值表示，第五列称作综合值 (Syndrome) 。第六列表示错误位置，对于 7 位码字从左到右每个位置依次标记为 A~G，当然也可以标记为 1~7 。

根据接收到的码字，我们根据接收到的码字 $R(x)$ 可以计算出第 5 列 Syndrome 值，然后查表可知错误位置。

对于 4 位消息，总共有 $2 ^ 4 - 1=15$ 种 cases，如下列出，第一列为序号，第二列为消息，第三列为编码后（这里采用的系统编码）的校验码

|序号|消息|校验码|
|--|--|--|
|1|0000|000|
|2|0001|011|
|3|0010|101|
|4|0100|111|
|5|0101|100|
|6|0110|001|
|7|0111|010|
|8|1000|101|
|9|1001|110|
|10|1010|011|
|11|1011|000|
|12|1100|010|
|13|1101|001|
|14|1110|100|
|15|1111|111|

<center>表 3</center>

我们以消息 $1100$ 为例，编码后码字为 $1100010$，

假设错误为 $0100000$，即错误发生在左起第二位，那么接收码字为 $1000010$，计算 $R(x) \mod G(x)$ 为

$$\begin{aligned} & \quad \ \ 1011 \\ 1011) &\overline{ 1000010} \\ & 1011 \\ & \overline {001101} \\ & \quad 1011 \\ & \quad \overline {01100} \\ & \quad \ \ 1011 \\ & \quad \quad \overline {111}
\end{aligned}$$

故 syndrome 值为 $7$，根据表 2 可知错误位置发生在 B 位置，也就是左起第二个位置。

这里 $E(x)$ 可看作二进制向量。

实际上，这里的例子中，只纠正 1 个错误即 $t=1$，此时生成多项式 $G(x)$ 就是所选的最小多项式，即表 1 中 $a ^ 1, a ^ 2$ 的最小多项式。如果 $G(x)$ 中有 $t>1$ 个最小多项式因子，那么如何纠正这 $t > 1$ 个错误呢？

我们需要将接收的码字 $R(x)$ 分别对 $G(x)$ 中的每个最小多项式取模，得到 $t > 1$ 个余式，每个最小多项式有对应的根，将根代入余式，得到 syndrome 值，然后可以得到错误位置。下面我们以码字长度 $n=7$，最大可纠正 $t=2$ 个错误为例说明，当然前面说了，此时消息长度 $k=n - 3 \cdot t = 1$，纠正 2 个错误没有意义，所以这里仅仅是为了便于说明举例，毕竟 $n=7$ 足够小。

$t=2$ 时，生成多项式为 $G(x) = (x ^ 3 + x + 1)(x ^ 3 + x ^ 2 + 1)=\sum _ {i=0} ^ 6 x ^ i$，注意这是经过了 $\mod 2$ 处理，二进制表示是 $1111111$ (7 个 1)，根据上文系统编码的步骤，可得

|index|消息|校验码|
|--|--|--|
|1| 0|000000|
|2| 1| 111111|

例如消息 $1$，编码后码字 $1111111$，错误为 $0101000$，那么接收的码字为 $R=1111111+0101000=1010111$，

1. $R(x) \mod (x ^ 3 + x + 1)=(1010111) \mod (1011)=100$，由于此最小多项式的根为 $a$，那么综合值为 $a ^ 2$

2. $R(x) \mod (x ^ 3 + x ^ 2 + 1) = 110$，此最小多项式根为 $a^3$ （根据 表 1 可知），那么综合值为 $(a ^ 3 ) ^ 2 + a ^ 3=a ^ 6 + a ^ 3 = (a ^ 2 + 1) + (a + 1) = a ^ 2 + a = a ^ 4$

    上式推导中，根据表 1，$a ^ 6 = a ^ 2 + 1, a ^ 3 = a + 1$，然后 $\mod 2$，得到 $a ^ 2 + a$，根据表 1 得到单项 $a ^ 4$

我们也可以根据校验矩阵来得到 syndrome 的值。校验矩阵为

$$H=\begin{bmatrix}a ^ 6 & a ^ 5 & \cdots & a ^ 0
\\ (a ^ 2) ^ 6 & (a ^ 2) ^ 5 & \cdots & (a ^ 2) ^ 0
\\ \vdots
\\ (a ^ {2t}) ^ 6 & (a ^ {2t}) ^ 5 & \cdots & (a ^ {2t}) ^ 0\end{bmatrix} \tag{1}$$

这里根据 $t=2$，考虑 $a, a ^2, ..., a ^ 4$ 这 4 行，$a, a ^ 2, a ^ 4$ 互相共轭，$a, a ^ 3$ 不互相共轭，所以实际上只需要考虑 $a, a ^ 3$ 对应的两行，故

$$H=\begin{bmatrix} a ^ 6 & a ^ 5 & \cdots & a ^ 0
\\ (a ^ 3) ^ 6 & (a ^ 3) ^ 5 & \cdots & (a ^ 3) ^ 0\end{bmatrix}$$

那么综合值为

$$S = R \cdot H ^ {\top}$$

根据接收向量 $R=[1 \ 0 \ 1 \ 0 \ 1 \ 1 \ 1]$， 于是，

$$\begin{aligned} S _ 1 &= a ^ 6 + a ^ 4 + a ^ 2 + a + 1
\\ &=(a ^ 2 + 1) + (a ^ 2 + a) + a ^ 2 + a + 1
\\ & \stackrel{\mod 2}=a ^ 2
\end{aligned} \tag{2}$$

$$\begin{aligned} S _ 2 &= a ^ {18} + a ^ {12} + a ^ 6 + a ^ 3 + 1
\\ & \stackrel{/ x ^ 7}=a ^ 4 + a ^ 5 + a ^ 6 + a ^ 3 + 1
\\ &= a ^ 4 + (a ^ 2 + a + 1) + (a ^ 2 + 1) + a + 1 + 1
\\ & \stackrel{\mod 2}=a ^ 4
\end{aligned} \tag{3}$$

在 $t=1$ 时，我们根据 syndrome 值查表就直到错误位置。在 $t=2$ 时，错误位置与 syndrome 值的对应关系已经与表 2 不同。如何计算出错误位置呢？

记错误向量为 $E=[0 \ 0 \ \cdots 1 \ 0 \ \cdots \ 0 \ 1 \ 0 \ \cdots]$，其中两个错误位置 $i, j$ 处元素值为 1（**从右往左计数下标**，$i,j >= 0$） ，那么 syndrome 为

$$R \cdot H ^ {\top} = (C + E) \cdot H ^ {\top} = E \cdot H ^ {\top}=\begin{bmatrix} a ^ i \\ a ^ {3i}\end{bmatrix} + \begin{bmatrix} a ^ j \\ a ^ {3j}\end{bmatrix}=\begin{bmatrix} a ^ i + a ^ j \\ a ^ {3i} + a ^ {3j}\end{bmatrix}=\begin{bmatrix} z _ 1 \\ z _ 2\end{bmatrix}$$

上式推导使用了 $C \cdot H ^ {\top} = \mathbf 0$，其中 $C$ 是发送码字。构造错误定位多项式

$$S(x) = (x + a ^ i) (x + a ^ j)=x ^ 2 + (a ^ i + a ^ j) x + (a ^ i \cdot a ^ j)$$

$S(x)$ 的根就是错误定位器，毕竟知道了 $a ^ i, a ^ j$ 就知道了 $i, j$ 的值。

根据推导

$$z _ 2 = a ^ {3i} + a ^ {3j} = (a ^ i + a ^ j)(a ^ {2i} + a ^ i a ^ j + a ^ {2j})=z _ 1 \cdot (z _ 1 ^ 2 + a ^ i a ^ j)$$

所以 $a ^ i a ^ j = z _ 2 / z _ 1 + z _ 1 ^ 2$ 代入 $S(x)$ 得

$$S(x) = x ^ 2 + z _ 1 x + (z _ 2 / z _ 1 + z _ 1 ^ 2)$$

结论：

1. 如果 $z _ 1 = z _ 2 = 0$，也就是说，$S(x)=x^2$，此时 $R \cdot H ^ {\top} = \mathbf 0$，说明没有错误发生，即， $R = C$
2. 如果 $z _ 1 \ne 0, z _ 2 = z _ 1 ^ 3$，$S(x)=x(x + z _ 1)$，此时有一个错误，位于 $z _ 1$ 处。
3. 如果 $z _ 1 \ne 0, z _ 2 \ne z _ 1 ^ 3$，此时有两个错误，位于 $a ^ i$ 和 $a ^ j$ 处。

在前面的例子中，我们已经计算出 syndrome 值为 $z _ 1 = a ^ 2, z _ 2 = a ^ 4$，写为

$$a ^ i + a ^ j = a ^ 2
\\ a ^ i a ^ j = a ^ 4 + a ^ 2=a$$

上式方程组对称，不妨令 $i < j$。解上式方程组，$a ^ i (a ^ 2 + a ^ i) = a$，等号左侧化简，得 $a ^ {2 + i} + a ^ {2i}=a$

根据表 1，依次代入 $i=0, 1, 2, ..., 6$，发现 $i=3$ 和 $i=5$ 满足条件，于是可以求得 $j$ 的值，

$$\begin{cases} i = 3 \\ j = 5 \end{cases}, \quad \begin{cases} i = 5 \\ j = 3 \end{cases}$$

根据 $i < j$，可知 $i=3, j=5$，注意这是从右往左计数下标，且下表从 0 开始计数，所以在 $B, D$ 两个位置处发生错误。

**# BCH 解码**

码字长度 $n$，消息长度 $k$，最大可纠正错误数 $t$，

1. 接收码字与校验矩阵相乘，得到 syndrome 向量 $S = R \cdot H ^ {\top}$

    $R$ 的 size 为 $1 \times n$，$H$ 的 size 为 $2t \times n$，于是 $S$ 的 size 为 $1 \times 2t$ 。
2. for $v = t, t - 1, ..., 0$:

    计算 $M=\begin{bmatrix} S _ 1 & \cdots & S _ v \\ S _ 2 & \cdots & S _ {v+1} \\ \vdots \\ S _ v & \cdots & S _ {2v}\end{bmatrix}$

    if $\det(M) = 0$: continue

    $\begin{bmatrix} \Lambda _ v \\ \Lambda _ {v-1} \\ \vdots \\ \Lambda _ 1\end{bmatrix} = M ^ {-1} \begin{bmatrix} -S _ {v+1} \\ -S _ {v+2} \\ \vdots \\ S _ {2v}\end{bmatrix}$

    解定位函数 $\Lambda(x) = 1 + \sum _ {i=1} ^ v \Lambda _ i x ^ i =  \prod _ {i=1}^v (1-X _ v x)$ 的根，其中 $X _ 1, X _ 2, \cdots, X _ v$ 是错误位置。
    
    解以下方程得到错误值 $\mathbf Y$，

    $$\begin{bmatrix} X _ 1 & X _ 2 & \cdots & X _ v \\ X _ 1 ^ 2& X _ 2 ^ 2 & \cdots & X _ v ^ 2 \\ \vdots \\ X _ 1 ^ v & X _ 2 ^ v & \cdots & X _ v ^ v\end{bmatrix}\begin{bmatrix} Y _ 1 \\ Y _ 2 \\ \cdots \\ Y _ v \end{bmatrix}=\begin{bmatrix} S _ 1 \\ S _ 2 \\ \cdots \\ S _ v \end{bmatrix}$$

**# 例1**

以上述例子 BCH(7, 1) 为例，消息 $1$，编码后码字 $1111111$，错误为 $0101000$，那么接收的码字为 $R=1111111+0101000=1010111$，最大可纠正位数 $t=2$，校验矩阵为前面 (1) 式，那么 syndrome 向量为

$$S=\begin{bmatrix}a ^ 6 + a ^ 4 + a ^ 2 + a + 1 
\\ a ^ {12} + a ^ 8 + a ^ 4 + a ^ 2 + 1 
\\ a ^ {18} + a ^ {12} + a ^ 6 + a ^ 3 + 1 
\\ a ^ {24} + a ^ {16} + a ^ 8 + a ^ 4 + 1 
\end{bmatrix}=\begin{bmatrix}a ^ 6 + a ^ 4 + a ^ 2 + a + 1 
\\ a ^ 5 + a ^ 1 + a ^ 4 + a ^ 2 + 1 
\\ a ^ 4 + a ^ 5 + a ^ 6 + a ^ 3 + 1 
\\ a ^ 3 + a ^ 2 + a ^ 1 + a ^ 4 + 1 
\end{bmatrix}=\begin{bmatrix}a ^ 2 
\\ a ^ 4 
\\ a ^ 4
\\ a 
\end{bmatrix}$$

令 $v=2$，那么

$$\det(M) = \begin{vmatrix} S _ 1 & S _ 2 \\ S _ 2 & S _ 3 \end{vmatrix}=\begin{vmatrix} a ^ 2 & a ^ 4 \\ a ^ 4 & a ^ 4 \end{vmatrix}=a ^ 6 - a ^ 8=a ^ 6 - a=a ^ 5 \ne 0 $$

计算出 $M ^ {-1}=\frac 1 {\det (M)}\begin{bmatrix} S _ 3 & -S _ 2 \\ -S _ 2 & S _ 1 \end{bmatrix} = \begin{bmatrix} a ^ 6 & -a ^ 6 \\ -a ^ 6 & a ^ 4 \end{bmatrix}$，于是

$$\Lambda = M ^ {-1}\begin{bmatrix} -a ^ 4 \\ - a  \end{bmatrix}=\begin{bmatrix}a ^ 3 + a ^ 0 \\ a ^ 3 + a ^ 5\end{bmatrix} = \begin{bmatrix}a \\ a ^ 2\end{bmatrix}$$

定位函数 $\Lambda(x) = 1 + a ^ 2 x + a x ^ 2=1 + (a ^ 3 + a ^ 5) x + a ^ 8 x ^ 2=(1+a ^ 3 x)(1+a ^ 5 x)$，故

$$X _ 1 = a ^ 3 , \ X _ 2 = a ^ 5$$

即，在从右往左 index 为 $3$ 和 $5$ 两个地方发生错误（index 从 0 开始计数）。

**# Berlekamp 迭代算法**

计算 syndrome 向量 $S = R \cdot H ^ {\top}$，错误多项式为 $\Lambda(x) = 1 + \sum _ {i=1} ^ v \Lambda _ i x ^ i =  \prod _ {i=1}^v (1- a ^ {j_i} x)$ ，这里 $a ^ {j_i}$ 给出了错误位置 $j_i$，那么 syndrome 可表示为

$$\begin{aligned}S _ 1 &= a ^ {j_1} + a ^ {j_2} + \ldots +  a ^ {j_v}
\\ S _ 2 &= (a ^ {j_1})^2 + (a ^ {j_2}) ^ 2 + \ldots + (a ^ {j_v}) ^ 2
\\ \vdots
\\ S _ {2t} &= (a ^ {j_1})^{2t} + (a ^ {j_2}) ^ {2t} + \ldots + (a ^ {j_v}) ^ {2t}
\end{aligned}$$

令 $\beta _ i = a ^ {j _ i}$，那么展开错误多项式 $\Lambda(x)$ 可得

$$\begin{aligned} \Lambda _ 1 &= \beta _ 1 + \beta _ 2 + \ldots + \beta _ v 
\\ \Lambda _ 2 &= \beta _ 1 \beta _ 2 + \beta _ 2 \beta _ 3 + \ldots + \beta _ {v-1} \beta _ v 
\\ \vdots 
\\ \Lambda _ v &= \beta _ 1 \beta _ 2 \ldots \beta _ v
\end{aligned}$$

于是有如下牛顿恒等式，

$$\begin{aligned} & S _ 1 + \Lambda _ 1 = 0
\\& S _ 2 + \Lambda _ 1 S _ 1 + 2 \Lambda _ 2 = 0
\\& S _ 3 + \Lambda _ 1 S _ 2 + \Lambda _ 2 S _ 1 + 3 \Lambda _ 3 = 0
\\ & \ldots
\\ & S _ v + \Lambda _ 1 S _ {v-1} + \ldots + \Lambda _ {v-1} S _ 1 + v \Lambda _ v = 0
\\ & S _ {v+1} + \Lambda _ 1 S _ v + \ldots + \Lambda _ {v-1} S _ 2 + \Lambda _ v S _ 1 = 0
\end{aligned}$$

二进制情况下，当 $i$ 为偶数时， $i \Lambda _i = 0$ 。

Berlekamp 迭代：

1. 求最低次多项式函数 $\Lambda ^ {(1)} (x)$（上标表示迭代次数），使得其系数满足第一个牛顿恒等式 $S _ 1 + \Lambda _ 1 = 0$

    显然，满足第一个牛顿恒等式，那么必然有 $\Lambda _ 1 = S _ 1$，所以错误多项式 $\Lambda ^ {(1)}(x) = 1 + \Lambda _ 1 x = 1 + S _ 1 x$，这里我们只要求最低次数多项式，所以 $\Lambda ^ {(1)}(x)$ 中 $\Lambda _ i , i > 1$ 全部为零即可。

2. 检验 $\Lambda ^ {(1)}(x)$ 是否满足第二个牛顿恒等式 $S _ 2 + \Lambda S _ 1 + 2 S _ 2=0$：

    1. 满足，则取 $\Lambda ^ {(2)}(x) = \Lambda ^ {(1)}(x)$
    2. 不满足，则对 $\Lambda ^ {(1)}(x)$ 增加一个修正项，构成 $\Lambda ^ {(2)}(x)$，使得 $\Lambda ^ {(2)}(x)$ 的系数满足前两个牛顿恒等式。

3. 迭代一直进行到获得 $\Lambda ^ {(2t)}(x)$，$\Lambda ^ {(2t)}(x)$ 就是最终的 $\Lambda ^ {(2t)}(x)$


这里迭代 $2t$ 次，而牛等恒等式却只有 $v+1$ 个，可能有的人不理解，按这个迭代，迭代 $v+1$ 次不就满足所有牛顿恒等式了吗，为什么还要迭代 $2t$ 次呢？实际上，第 $u$ 次迭代求得的多项式 $\Lambda ^ {(u)}(x)$ 的阶数为 $j$，则需要满足前 $j$ 个牛顿恒等式，而根据 $i \Lambda _ i = 0$ 可知，第 $\Lambda ^ {(u)}(x)$ 的阶数最大为 $\lfloor (u+1)/2 \rfloor$，当 $u=2t$ 时，$\Lambda ^ {(2t)}(x)$ 的阶数最大为 $t$，当实际上有 $t$ 个错误时取得这个最大阶数，因为 $\Lambda ^ {(2t)}(x)$ 的阶数就表示发生错误的数量。

这里，牛顿恒等式有 $v+1$ 个，而未知数 $\Lambda _ i$ 有 $v$ 个，$v$ 表示实际发生的错误数量，$v \le t$，所以我觉得只需要前 $v$ 个牛顿恒等式，最后一个等式是冗余的。

记第 $u$ 步确定的错误多项式为

$$\Lambda ^ {(u)}(x) = 1 + \Lambda _ 1 x + \Lambda _ 2 x ^ 2 + \ldots + \Lambda _ {l _ u} x ^ {l _ u}$$

其中 $l _ u$ 是阶次（最高幂次）。

第 $u$ 步差值为

$$d _ {u} = S _ {u+1} + \Lambda _ 1 S _ u + \Lambda _ 2 S _ {u-1} + \ldots + \Lambda _ {l _ u} S _ {u +1- l _ u}$$

迭代步骤为：

1. $d _ u =0$， $\Lambda ^{(u+1)}(x) = \Lambda ^{(u)}(x)$，$l _ {u+1} = l _ u$

2. $d _ u \ne 0$，寻找前面第 $\rho$ 次迭代，满足 $d _ {\rho} \ne 0$，且 $\rho - l _ {\rho}$ 最大，

    $$\Lambda ^{(u+1)}(x) = \Lambda ^{(u)}(x) + d _ {u} d _ {\rho} ^ {-1} x ^ {u-\rho} \Lambda ^ {(\rho)}(x)$$

    $$l _ {u+1} = \max (l _ u, l _ {\rho} + u - \rho) \tag{*}$$

    $\Lambda ^{(u+1)}(x)$ 阶次为两个单项式中 $x$ 的幂次最大者

    根据测试发现 (*) 式可能存在错误，应该改为 $l _ {u+1} = \max (l _ u, u+1-l_u)$。

迭代步骤 $u$ 范围为 $[0, 2t]$，
初始条件为 $\Lambda ^ {(0)}(x) = 1$，其阶次为 $l _ 0 = 0$， $d _ 0 = S _ 1$ 。


迭代结束后得到 $\Lambda(x)$ 错误多项式，那么要求其根，只要将 $a ^ 0, a ^ 1, a ^ 2, \ldots, a ^ {n-1}$ 代入 $\Lambda (x)$，如果结果为 0，那么就是根。

[代码实现](https://github.com/JianjianSha/bch)