<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="mask-rcnn, SJJ">
    <meta name="description" content="论文 Mask R-CNN

Introduction
这是一篇实例分割的文章。实例分割结合了目标检测和语义分割，这看似是需要一个复杂的模型才能完成的任务，实际上本文提出的 Mask R-CNN 出奇的简单灵活且高效。
Mask R-CNN">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>mask-rcnn | SJJ</title>
    <link rel="icon" type="image/png" href="/medias/logo.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">SJJ</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/resume" class="waves-effect waves-light">
      
      <i class="fas fa-file" style="zoom: 0.6;"></i>
      
      <span>简历（英）</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/jianli" class="waves-effect waves-light">
      
      <i class="fas fa-file" style="zoom: 0.6;"></i>
      
      <span>简历（中）</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">SJJ</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/resume" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-file"></i>
			
			简历（英）
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/jianli" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-file"></i>
			
			简历（中）
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/jianjiansha/jianjiansha.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/jianjiansha/jianjiansha.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/22.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">mask-rcnn</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/object-detection/">
                                <span class="chip bg-color">object detection</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-07-08
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>论文 <a target="_blank" rel="noopener" href="https://arxiv.org/abs/1703.06870">Mask R-CNN</a></p>
<span id="more"></span>
<h1>Introduction</h1>
<p>这是一篇实例分割的文章。实例分割结合了目标检测和语义分割，这看似是需要一个复杂的模型才能完成的任务，实际上本文提出的 Mask R-CNN 出奇的简单灵活且高效。</p>
<p>Mask R-CNN 是对 Faster R-CNN 的扩展，增加了一个分支用于预测每个 RoI 的分割掩模（segmentation masks），如图 1，这个分支与原先的分类和回归分支并列。mask 分支在 RoI 上以 pixel-to-pixel 方式预测得到一个 segmentation mask，有语义分割背景的话，不难想象 mask 分支应是一个全卷积网络 FCN。如何构建这个 mask 分支则至关重要。<br>
<img src="/images/mask-rcnn_fig1.png" alt=""></p>
<p>Faster R-CNN 的网络输入和输出之间不是点与点对齐，这是由于 RoIPool 层在抽取特征时使用了离散化空间坐标（坐标值必须为整数，RoI 坐标从输入 image 平面映射到 feature map 时，坐标变为原来的 1/16，并四舍五入取整），而 mask 分支是 pixel-wise 的，所以必须要解决这个不对齐问题，为此我们提出了 RoIAlign 层以保持准确的空间位置，这个改动虽小，但效果却十分明显：提高了大约 10%~50% 的 mask 准确度。</p>
<p>另外，有必要将分类预测和 binary mask 预测解耦，每个分类独立进行 binary mask 预测，并根据 RoI 分类分支来确定目标分类。相反在语义分割 FCN 方法中，每个像素位置均进行多分类，这就耦合了分割和分类，如果用在实例分割任务中则表现较差。</p>
<h1>Mask R-CNN</h1>
<p>Faster R-CNN 中每个候选区域均对应两个输出：分类标签和坐标偏差。Mask R-CNN 则在此基础上增加第三个输出：目标 binary mask，与前两个输出不同的是，此输出需要非常精确的目标空间位置，这是 Mask R-CNN 的关键点之一。</p>
<p><strong>Faster R-CNN:</strong> 简单的回顾一下 Faster R-CNN，这是一个 two-stage 目标检测器，其中第一个 stage 为 RPN，用于生成 proposals，第二个 stage 其本质就是 Fast R-CNN，使用 RoIPooling 从每个 proposal 中提取固定长度的特征并进行分类和 bbox 回归。</p>
<p><strong>Mask R-CNN:</strong> 在 Faster R-CNN 基础上增加第二个 stage 的输出，即为每个 RoI 生成 binary mask。</p>
<p>训练时，每个 RoI 的损失为 $L=L_{cls}+L_{box}+L_{mask}$，其中分类损失 $L_{cls}$ 和回归损失 $L_{box}$ 均与 Fast/Faster R-CNN 中相同，<br>
$$L_{cls}=L_{cls}(p,u)=-\log p_u \tag{1}$$<br>
上式为 log loss，proposal 对应的 gt 分类为 u，$p_u$ 为 proposal 分类为 u 对应的置信度（分类得分）。<br>
$$L_{loc}=L_{loc}(t ^ u,v)=\sum_{i \in {x,y,w,h}} smooth_{L_1}(t_i ^ u,v_i)\tag{2}$$<br>
上式为 smooth L1 loss，$t_u$ 为在分类 u 下的 bbox 的四个偏移值，v 表示 gt box 相对 proposal 的偏移 target。<br>
<strong>mask 分支会为每个 RoI 生成 $Km ^ 2$ 维输出向量</strong>，然后对这个输出向量应用 pixel-wise sigmoid，表示 K 个 binary mask，每个 mask 分辨率为 $m \times m$（m 值参见下文图 4），这里 K 表示所有分类数量，定义 $L_{mark}$ 为平均二值交叉熵损失，记 RoI 的 gt 分类为 k，$L_{mark}$ 仅由第 k 个 binary mask 计算得到，其他 K-1 个 binary mask 均不参与 $L_{mark}$ 的计算，<br>
$$L_{mark}=-\frac 1{m ^ 2} \sum _ {i=1} ^ {m ^ 2} \sum _ {j=0} ^ 1 [t _ i=j] \cdot \log f(s _ i ^ j)=-\frac 1{m ^ 2} \sum _ {i=1} ^ {m ^ 2} [t _ i \cdot \log f(s _ i) + (1-t _ i) \cdot \log (1-f(s _ i))]\tag{3}$$<br>
其中 $f(\cdot)$ 表示 sigmoid。</p>
<p><strong>Mask Representation:</strong> 对单个 RoI 而言，无论其大小，对应的分类和 bbox 偏移这两个输出都是固定长度，可由 fc 层输出得到，而 mask 则以 pixel-to-pixel 方式表征 RoI 中目标的空间布局，所以适合使用卷积。事实上，我们正是使用了全卷积网络 FCN 来为每个 RoI 生成 $m \times m$ 空间尺寸的 mask。然而需要注意的是，pixel-to-pixel 的方式要求 RoI 特征能如实地保留每个像素的空间对应关系，于是我们提出 RoIAlign 来解决这个问题。</p>
<p><strong>RoIAlign:</strong> RoIPool 是从 RoI 中抽取固定长度特征（例如 $7\times 7$）的标准方法，首先将浮点数 RoI 量化成整数粒度的 feature map，然后将量化后的 RoI 切分得到一系列空间 bins ，每个空间 bin 的大小也是浮点数，所以每个空间 bin 的位置也需要量化，然后将其中的像素值聚合得到这个空间 bin 的值，一般使用最大值池化进行聚合。</p>
<p>可见前后有两次量化过程，第一次量化是在将 RoI 的坐标 x 从输入 image 平面上映射到特征平面上，在 Faster R-CNN 中，这个特征的 stride 为 16，所以 RoI 在特征平面上的坐标为 $[x/16]$，其中 $[\cdot]$ 表示四舍五入成整数；第二次量化是在计算空间 bin 位置时，假设 RoI 为 $(x_1,y_1,x_2,y_2)$（通常均为浮点数，因为 RPN 中对 anchor 位置进行偏移得到 RoI），一共将 RoI 划分为 7x7 个空间 bins，经过第一次量化后特征平面上 RoI 表示为，<br>
$$x_1’=[x_1/16] \quad y_1’=[y_1/16]<br>
\quad x_2’=[x_2/16]<br>
\quad y_2’=[y_2/16]\tag{4}$$<br>
RoI 的大小 和 空间 bin 的大小分别为<br>
$$w’=x_2’-x_1’+1<br>
\quad h’=y_2’-y_1’+1<br>
\\ w ^ b=w’/7 \quad h ^ b=h’/7$$<br>
对于第 (i,j) 个 bin，其位置为<br>
$$x_1 ^ b=\lfloor j \cdot w ^ b\rfloor \quad y_1 ^ b=\lfloor i \cdot h ^ b\rfloor \quad x_2 ^ b=\lceil (j+1) \cdot w ^ b\rceil \quad y_2 ^ b=\lceil (i+1) \cdot h ^ b\rceil\tag{5}$$</p>
<p>其中 $0 \le i&lt;7, \ 0\le j&lt;7$。（当然还需要对 bin 的位置是否越界进行检查，这里略）</p>
<p>坐标 $x _ 1 ^ b, y _ 1 ^ b, x _ 2 ^ b, y _ 2 ^ b$ 是基于 feature map 的，这个 feature 的 size 为输入图像 size 的 $1/16$ 。</p>
<p>两次量化使得 RoI 与抽取到的特征不对齐，这对 pixel-to-pixel 的 mask 而言是非常不利的，所幸 RoIAlign 可以解决这个问题。使用 RoIAlign 代替 RoIPool，避免量化操作，如图 3，<br>
<img src="/images/mask-rcnn_fig3.png" alt=""></p>
<center>图 3. RoIAlign 示意图，图中黑矩形框表示 backbone 输出 feature maps 上的一个 RoI，具有 2x2 个 bin，实际是 7x7 个 bin，这里仅作示例</center>
<p>特征平面上的 RoI 的位置为 $x/16$，其中每个 bin 采样 4 个位置点，采样位置处的值通过双线性插值计算得到，然后每个 bin 的值使用这四个采样位置的值进行聚合得到（max 或者 average 聚合）。整个过程 <strong>没有任何量化操作</strong>。实验的最终结果对采样位置不敏感，对采样位置的数量也不敏感。</p>
<p><strong>Network Architecture:</strong> Mask R-CNN 网络组成包括 1. 用于抽取特征的 backbone，2. network head，用于 bbox 分类和回归，以及 mask 预测。</p>
<p>Backbone 网络的命名法：我们使用了 ResNet 和 ResNeXt（深度为 50 或101）。Faster R-CNN 中使用 ResNet 的 4-th stage 的最后一个 conv 的输出作为特征，这里记为 C4。于是，当 ResNet 为 ResNet-50 时，我们称 backbone 为 ResNet-50-C4。</p>
<p>我们也研究了其他的 backbone 例如 FPN，FPN 使用 top-down 结构以及横向连接生成 feature pyramid。使用 ResNet-FPN 作为 backbone 时，Mask R-CNN 的准确率以及响应速度均有提升。</p>
<p>对于 Network head，如图 4，<br>
<img src="/images/mask-rcnn_fig4.png" alt=""></p>
<center>图 4. 检测 heads </center>
<p>ResNet-C4 作为 backbone 时，后面的 head 结构包含 ResNet 的 5-th stage（即，具有 9 个 conv 的 res5）。ResNet-FPN 作为 backbone 时，由于 backbone 已经包含了 res5，故后面的 head 结构较为简单高效。<br>
图 4 左边部分，res5 表示 ResNet 的 5-th stage，为简单起见，作用到 $7x7$ 的 RoI feature maps 上的第一个 conv 的 stride 为 1，而原始 ResNet 中对应的这个 conv 由于作用在（conv4_x 输出的）$14x14$ feature maps 上，这个 conv 的 stride 为 2，这一点有所不同。</p>
<h1>Experiments</h1>
<p>实验部分略，请阅读原文。</p>
<h1>Appendix</h1>
<p>有关 mask 分支，这里详细说明一下处理过程。如图 4，mask 分支输出大小为 $(R,K,m,m)$，根据 bbox 回归得到预测 box 的坐标数据，数据块大小为 $(R,4)$，其中 R 为检测到的所有预测 box 的数量，K 为目标分类数量，$mxm$ 为 mask 的空间大小。对于第 i 个 目标，$0 \le i &lt; R$，记预测 box 位置为 $(x_1,y_1,x_2,y_2)$，对于第 k 个分类，记对应的 mask map 为 $M_i ^ k$，</p>
<ol>
<li>计算第 i 个 box 的宽高<br>
$w=x_2-x_1, \ h=y_2-y_1$</li>
<li>将 mask map resize 到 box 宽高的大小 <pre class="line-numbers language-python" data-language="python"><code class="language-python">mask<span class="token operator">=</span>cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>M_i_k<span class="token punctuation">,</span> <span class="token punctuation">(</span>w<span class="token punctuation">,</span>h<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>将 mask map 二值化，因为 mask 是 pixel-wise sigmoid 之后的值，介于 (0,1) 之间，所以需要二值化处理 <pre class="line-numbers language-python" data-language="python"><code class="language-python">mask<span class="token operator">=</span>np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>mask<span class="token operator">></span><span class="token number">0.5</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li>将 binary mask 映射到原始输入 image 平面。记原始输入 image 的宽高为 (W,H)，于是得到分割 mask <pre class="line-numbers language-python" data-language="python"><code class="language-python">im_mask<span class="token operator">=</span>np<span class="token punctuation">.</span>zero<span class="token punctuation">(</span><span class="token punctuation">(</span>H<span class="token punctuation">,</span>W<span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>
im_mask<span class="token punctuation">[</span>y1<span class="token punctuation">:</span>y2<span class="token punctuation">,</span>x1<span class="token punctuation">:</span>x2<span class="token punctuation">]</span><span class="token operator">=</span>mask<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ol>
<h1>实例分割</h1>
<p>参考以下源码。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/facebookresearch/detectron2">code</a></p>
<p>实例分割训练命令，</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./train_net.py --num-gpus <span class="token number">8</span> <span class="token punctuation">\</span>
  --config-file <span class="token punctuation">..</span>/configs/COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_1x.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="backbone">backbone</h2>
<p>backbone 使用 <code>resnet_fpn</code>。</p>
<p>以 resnet50 为例，结构如下，</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stem -<span class="token operator">></span> res2 -<span class="token operator">></span> res3 -<span class="token operator">></span> res4 -<span class="token operator">></span> res5

<span class="token comment"># stem: conv7x7+maxpool</span>
<span class="token comment"># resx: stage x</span>
<span class="token comment"># stem/resx: stride 均为 2</span>
<span class="token comment"># stem 和 res2 冻结网络参数。参数使用 ImageNet 上预训练模型参数</span>
<span class="token comment"># resx 的输出 channel: 256, 512, 1024, 2048</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>resnet 输出特征为 res2, res3, res4, res5 的输出特征（4 个 scale 的特征）</p>
<p>然后构造 FPN 网络，其中 bottom-up 结构就是上面构造的 resnet 结构，FPN 结构示意图为，</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">                           +-<span class="token operator">></span> mp -<span class="token operator">></span> P6
                           <span class="token operator">|</span>
res5 -<span class="token operator">></span> lat5 ---+--<span class="token operator">></span> out5 -+-------<span class="token operator">></span> P5
 ^              <span class="token operator">|</span> <span class="token punctuation">(</span>nearest，下同<span class="token punctuation">)</span>
 <span class="token operator">|</span>              <span class="token function">v</span>
res4 -<span class="token operator">></span> lat4 --<span class="token operator">></span>O--<span class="token operator">></span> out4 ---------<span class="token operator">></span> P4
 ^              <span class="token operator">|</span>
 <span class="token operator">|</span>              <span class="token function">v</span>
res3 -<span class="token operator">></span> lat3 --<span class="token operator">></span>O--<span class="token operator">></span> out3 ---------<span class="token operator">></span> P3
 ^              <span class="token operator">|</span>
 <span class="token operator">|</span>              <span class="token function">v</span>
res2 -<span class="token operator">></span> lat2 --<span class="token operator">></span>O--<span class="token operator">></span> out2 ---------<span class="token operator">></span> P2
 ^
 <span class="token operator">|</span>
stem
 ^
 <span class="token operator">|</span>                                        <span class="token punctuation">(</span>FPN<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>FPN 输出 multi scale 特征平面，记为 <code>P2, P3, P4, P5, P6</code>，top-down 采样 nearest 插值，P6 是经过 <code>maxpool</code> 的输出。<code>O</code> 表示两个 tensor 执行 elementwise 相加，<code>+</code> 表示作为两个 layer 的输入，例如 <code>lat5</code> 的输出，作为 <code>out5</code> 和 <code>nearest</code> 的输入。</p>
<p>经过横向连接 <code>latx</code> layer，输出 channel size 全部都是 <code>256</code> ，避免了 top-down merge 时的 padding。</p>
<h2 id="proposal-generator">proposal_generator</h2>
<p>proposal_generator 使用 <code>RPN</code>。</p>
<p><code>P2, P3, P4, P5, P6</code> 5 个 scale 的特征平面，分别对应的 anchor size 基准是 <code>32, 64, 128, 256, 512</code>，每个 anchor 的 aspect ratio 为 <code>0.5, 1, 2</code>，所以每个 scale 的特征平面上每个 point 处有 <code>3</code> 个 anchors。</p>
<h2 id="rpn-head">rpn_head</h2>
<p>rpn_head 使用 <code>StandardRPNHead</code> 。</p>
<p>对每个 scale 的特征平面，先使用 <code>conv1x1</code> 进行调整，输出 channel 不变，仍是 <code>256</code>，然后再分别经过：</p>
<ol>
<li><code>conv1x1</code> 输出 objectness 预测，输出 channel 为 <code>3</code>，分别对应 3 个 anchors，预测每个 anchor 处是否有目标</li>
<li><code>conv1x1</code> 输出每个 anchor 预测的目标坐标 offset，输出 channel 为 <code>3*4=12</code></li>
</ol>
<p><strong>注意</strong> rpn_head 中的 3 个 conv layer 对所有 scales 共享，代码如下，</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">pred_objectness_logits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   pred_anchor_deltas <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
   <span class="token keyword">for</span> x <span class="token keyword">in</span> features<span class="token punctuation">:</span>   <span class="token comment"># 遍历 P2,3,4,5,6</span>
      t <span class="token operator">=</span> self<span class="token punctuation">.</span>conv<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
      pred_objectness_logits<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>objectness_logits<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span>
      pred_anchor_deltas<span class="token punctuation">.</span>append<span class="token punctuation">(</span>self<span class="token punctuation">.</span>anchor_deltas<span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token keyword">return</span> pred_objectness_logits<span class="token punctuation">,</span> pred_anchor_deltas<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="RPN-损失">RPN 损失</h2>
<p>对于某个 image，假设其中包含 <code>M</code> 个 gt boxes，由于有 5 个 scales 特征平面，每个特征平面的 size 均不同，所以每个特征平面的 anchors 也不同，总共的 anchors 数量为 $\sum _ {i=1} ^ 5 h _ i \times w _ i \times 3$，为了方便表示记 anchors 总数为 $N$。</p>
<p>计算 gt boxes 与 anchors 的 IoU 矩阵，shape 为 $M \times N$，对矩阵每列求最大值，得到每个 anchor 的最大 IoU 值，考察这个 IoU 值范围：</p>
<ol>
<li>$(-\infty, 0.3]$，anchor label 为 <code>0</code>  （负样本）</li>
<li>$(0.3, 0.5]$，anchor label 为 <code>-1</code>     （难例，忽略）</li>
<li>$(0.5, +\infty)$，anchor label 为 <code>1</code>  （正样本）</li>
</ol>
<p>此外，还考虑了其他匹配，即，对 IoU 矩阵按行求最大值，最大值如果 <code>&gt;0</code>，此位置对应的 anchor label 也是 <code>1</code> 。</p>
<p>每个 image 取 256 个样本，其中一半是正样本，即，随机选择 128 个 label 为 <code>1</code> 的 anchors 为正样本，随机选择 128 个 label 为 <code>0</code> 的 anchors 为负样本。这 <code>256</code> 个样本用于计算 RPN loss 。</p>
<p><strong>计算 loss</strong></p>
<p>现在，整理预测值和 target 。</p>
<p>objectness 预测值是一个具有 5 个 tensor 的 list，对应 5 个 scale，每个 tensor 的 shape 为 $ (B, 3, h _ i, w _ i), \ i=1,2,3,4,5$ </font>，其中 $B$ 是 batch size， $3$ 是指特征平面上每个 pixel 处使用 3 个 anchors 预测。坐标 offset 即 $(t _ x, t _ y, t _ w, t _ h)$ 的预测值也是一个具有 5 个 tensor 的 list，每个 tensor 的 shape 为 $(B, 3*4, h _ i, w _ i)$ ，经过 flatten 和 concatenate，这两个 list 分别转为两个 tensor，shape 分别为 $\color{cyan}(B, N)$ 和 $\color{cyan}(B, N, 4)$ 。</p>
<p>anchors 也是具有 5 个 tensor 的 list，每个 tensor shape 为 $(h _ i \times w _ i \times 3, 4)$ ，concatenate 之后 shape 为 $\color{cyan} (N, 4)$。</p>
<p>对于单个 image 而言，分类 target 的 shape 为 $(N, )$，其中 $N$ 是 5 个 scale 特征平面的 anchor 总数，坐标 x1y1x2y2 的 target shape 为 $(N, 4)$。每个 anchor 对应一个 objectness label 值（<code>0</code> 负例，<code>1</code> 正例，<code>-1</code> 忽略），每个 anchor 使用与其具有最大 IoU 的那个 gt box 的坐标作为 target 。target 通过这种表示方法，即使每个 image 的 gt boxes 数量不等，但是 target shape 是相同的。</p>
<p>所以一个 batch 的 分类 target shape 为 $\color{cyan} (B, N)$，坐标 target 为 $\color{cyan} (B, N, 4)$ 。</p>
<p>anchor boxes 和 gt boxes 坐标均需要 scale 到基于输入图像 size 。根据 anchor boxes 和 gt boxes 计算坐标 offset 即 $(t _ x, t _ y, t _ w, t _ h)$ 的 target，其 shape 为 $\color{cyan} (B, N, 4)$ ，当然了这里面计算了所有样本的 target （包括正例、负例和被忽略的 anchor）。</p>
<p><strong>计算正例的坐标回归损失</strong></p>
<p>使用 smoothL1 损失。根据分类 target <code>=1</code> 可以得到正例 mask，从而筛选出正例坐标 offset 的预测值，和正例对应的坐标 offset 的 target。</p>
<p><strong>计算分类损失</strong></p>
<p>使用 binary cross entropy 损失。计算正例和负例（label 为 <code>0</code> 和 <code>1</code>，不包括 <code>-1</code>）。</p>
<p>两种损失均分别求和，然后再除以 <code>B * 256</code>，因为每个 image 中正负例数量之和为 <code>256</code> 。</p>
<p>由于 RPN 用于生成 proposals，所以这两个损失记作 <code>proposal_losses</code> 。</p>
<h3 id="获取-proposals">获取 proposals</h3>
<p>根据坐标 offset 的预测值和 anchor 计算出预测 boxes 的坐标。坐标 offset 预测值 shape 为 $(B, N, 4)$，anchors shape 为 $(N, 4)$，所以先 expand 为 $(B, N, 4)$，然后再计算，预测 boxes shape 也是 $(B, N, 4)$ 。</p>
<p><strong>筛选 proposals</strong></p>
<p>每个 scale 独立进行以下操作，</p>
<ol>
<li>
<p>当前处理第 <code>i</code> 个 scale 。根据分类预测值，选择 top $K _ 1=2000$ 个 proposals</p>
</li>
<li>
<p>对这 top $K _ 1$ 个 proposals ，记录对应的分类预测值，以及坐标值</p>
</li>
</ol>
<p>将所有 scales 的 top $K _ 1$ 的 proposals 值 concatenate，那么分类得分 shape 为 $(B, 5 K _ 1)$，坐标 shape 为 $(B, 5 K _ 1, 4)$ 。</p>
<p>每个 image 独立进行以下操作，</p>
<ol>
<li>
<p>对第 <code>b</code> 个 image，有 $5 K _ 1$ 个 proposals，筛选分类得分和坐标值正常（非 inf）的 proposals，然后将坐标值 <code>clip</code> 到这个 image size 范围内，然后筛选 size <code>&gt; 0</code> 的 proposals</p>
</li>
<li>
<p>执行 NMS</p>
</li>
<li>
<p>根据预测得分取 NMS 之后 top $K _ 2=1000$ 的 proposals</p>
</li>
</ol>
<p>那么每个 image 均得到 top $K _ 2$ 的 proposals。于是，得到一个 list，其中每个 element 表示一个 image 的 $K _ 2$ 个 proposals。</p>
<h2 id="ROI-head">ROI head</h2>
<p>对于目标检测任务，ROI head 有分类和坐标回归两个分支。对于实例分割任务，还需要一个 mask 分支。</p>
<p><strong>样本分配</strong></p>
<p>对于 RPN 输出的每个图像的 $K _ 2$ 个 proposals，首先将每个 image 的 gt boxes 也作为 proposals，由于 proposal 有 objectness 预测值，所以 gt box 也设置一个 objectness 值，即 logit 值（非归一化得分），令 gt box 的 objectness 概率为 $1-\epsilon$，那么其 logit 值为</p>
<p>$$\log \frac {1-\epsilon}{\epsilon}$$</p>
<p>根据 sigmoid 函数可恢复其 objectness 概率</p>
<p>$$\sigma \left(\log \frac {1-\epsilon}{\epsilon}\right)=\frac 1 {1+\exp \left(-\log \frac {1-\epsilon}{\epsilon}\right)}=\frac 1 {1 + \frac {\epsilon}{1-\epsilon}}=1-\epsilon \tag{6}$$</p>
<p>然后根据一个策略进行样本分配（确定正负样本）。分配策略为：</p>
<ol>
<li>计算 gt boxes 与 proposals 的 IoU 矩阵</li>
<li>按列求最大值，即，为每个 proposal 求最大 IoU</li>
<li>最大 IoU <code>&gt;0.5</code>，那么 proposal 为正样本；否则为负样本</li>
<li>为每个 proposal 分配分类 label：最大 IoU 对应的 gt box 的分类，范围为 $[0, C-1]$</li>
<li>将负样本的分类 label 设置为 $C$，表示是背景。</li>
<li>每个样本的坐标 target 为最大 IoU 对应的 gt box。</li>
</ol>
<p>每个 image 取 <code>512</code> 个样本，其中 <code>1/4</code> 为正样本，所以从上述正 proposals 中随机选择 <code>128</code> 个作为正样本，从负 proposals 中随机选择 <code>384</code> 个作为负样本。这 <code>512</code> 个样本用于后面计算 loss 。</p>
<p>ROI_head 子网络的输入来自 FPN 的输出的 <code>P2,P3,P4,P5</code>，注意这里没有使用 <code>P6</code>，P6 仅用于 RPN 子网络。</p>
<h3 id="ROIPool">ROIPool</h3>
<p>由于每个 proposal 大小不等，而我们最终要为每个 proposal 输出 <code>C+1</code> 个分类预测以及 <code>4</code> 个坐标预测，所以需要使用 ROIPool 将 size 不等的 proposal 下采样为 size 相等的特征，这里采样 <code>7x7</code> 的 size 。</p>
<p><strong>分配 proposals 到 scale level</strong></p>
<p>每个 image 有 <code>512</code> 个 propopsals 样本，每个 proposal 应该对应到哪个 scale level 呢？记 scale level 为 <code>2,3,4,5</code>（注 ROI_head 中不使用 P6 特征），那么分配策略为：</p>
<ol>
<li>
<p>计算 proposal 的面积 $S=w \times h$，然后计算其平方根 $s=\sqrt S$</p>
</li>
<li>
<p>一个预先设定的基准边长 $s _ 0 = 224$，对应的 scale level 为 $4$，那么为 proposal 分配的 scale level 为</p>
<p>$$l=\lfloor 4 + \log _ 2 \frac {s}{s _ 0}\rfloor \tag{7}$$</p>
</li>
<li>
<p>为了保证 scale level 位于 $[2,5]$ 之间，取 $l=\max(2, \min(l, 5))$</p>
</li>
</ol>
<p><strong>ROIAlign</strong></p>
<p>输入特征是 <code>P2,P3,P4,P5</code>，RPN 输出的 proposals 也已经按 scale level 进行了分配，那么就每一个 scale level 单独处理 ROI 对齐。</p>
<p>以 <code>P2</code> 为例进行说明。</p>
<p>记 <code>P2</code> 特征平面 size 为 $(h, w)$，下采样率为 $d=4$，将 proposal 的坐标（当前是基于输入图像 size）转换到基于特征平面 size，即</p>
<p>$$x _ 1 = x _ 1 / 4, \ y _ 1 = y _ 1 / 4, \ x _ 2 = x _ 2 / 4, \ y _ 2=y _ 2 / 4$$</p>
<p>调整之后就可以得到 proposal 的 size 为 $w = x _ 2 - x _ 1, \ h = y _ 2 - y _ 1$ 。</p>
<p>现在要将 proposal 划分为 <code>7x7</code> 的 bins，那么每个 bin 的 size 则为 $w _ b = w/7, \ h _ b = h / 7$ 。</p>
<p>以前的 ROIPooling 方法参考上面的 (4) 式和 (5) 式，经过了两次量化，显然精确度下降，而实力分割对坐标精确度要求较高，所以不能按上面的方法进行 ROIPooling ，而是按图 3 所示，对每个 bin 采样 <code>n</code> 个点，每个点位于特征平面某个 grid cell 内，记某个点坐标为 $(x, y)$，$x, y$ 均为浮点数且没有经过任何量化，那么取周围四个点 $(\lfloor x \rfloor, \lfloor y \rfloor), \ (\lfloor x \rfloor+1, \lfloor y \rfloor), \ (\lfloor x \rfloor, \lfloor y \rfloor+1), \ (\lfloor x \rfloor+1, \lfloor y \rfloor+1)$，然后使用双线性插值得到 $(x, y)$ 处的值。</p>
<p>代码中没有采样 <code>n</code> 个点，而是对 bin 内所有点进行了双线性插值。</p>
<details><summary>bin 内采样点双线性插值源码解读</summary>
代码位于 `torchvision` 项目的 `ops/roi_align.py` 文件中的 `roi_align` 函数。
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">roi_align</span><span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> boxes<span class="token punctuation">,</span> output_size<span class="token punctuation">,</span> spatial_scale<span class="token punctuation">,</span> sampling_ratio<span class="token punctuation">,</span> aligned<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> Tensor<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>参数说明：</p>
<ol>
<li><code>input</code>，当前某个 scale level 的输入特征，由 FPN 输出提供。shape 为 $(B, 256, h, w)$，其中 $B$ 是训练的 batch size 。</li>
<li><code>boxes</code>，分配到当前 scale level 的 proposals，shape 为 $(K, 5)$，其中 $K$ 是整个 batch 中分配到此 level 的 proposals 数量（整个 batch 中所有 level 的 proposals 数量为 $512\times B$），维度 $5$ 依次表示 proposal 所在 image 的 batch index，以及 $x _ 1, y _ 1, x _ 2, y _ 2$</li>
<li><code>output_size</code>，ROIPooling 之后的 spatial size，这里是 $7 \times 7$</li>
<li><code>spatial_scale</code>，下采样率的倒数，例如对于 <code>P2</code>，值为 $1/4$</li>
<li><code>sampling_ratio</code>，指定每个 bin 内采样点数量，如果此值 <code>&lt;=0</code>，那么对 bin 内所有点采样</li>
<li><code>aligned</code>，是否对齐。此参数后面会解释。</li>
</ol>
<p>来看具体实现代码。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">_<span class="token punctuation">,</span> _<span class="token punctuation">,</span> height<span class="token punctuation">,</span> width <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 输入特征的 size</span>

ph <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>pooled_height<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token builtin">input</span><span class="token punctuation">.</span>device<span class="token punctuation">)</span>  <span class="token comment"># [PH] 	bin 的 y 轴 index：0~6</span>
pw <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>pooled_width<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token builtin">input</span><span class="token punctuation">.</span>device<span class="token punctuation">)</span>  <span class="token comment"># [PW]	bin 的 x 轴 index：0~6</span>

roi_batch_ind <span class="token operator">=</span> rois<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># [K]  K 个 proposals 所在 image 的 batch index</span>
offset <span class="token operator">=</span> <span class="token number">0.5</span> <span class="token keyword">if</span> aligned <span class="token keyword">else</span> <span class="token number">0.0</span>

<span class="token comment"># proposal box 左上右下坐标映射到特征平面，然后位移 -0.5，这个位移保证 bin 内采样点从 0 处开始采样</span>
roi_start_w <span class="token operator">=</span> rois<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> spatial_scale <span class="token operator">-</span> offset  <span class="token comment"># [K]	</span>
roi_start_h <span class="token operator">=</span> rois<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> spatial_scale <span class="token operator">-</span> offset  <span class="token comment"># [K]</span>
roi_end_w <span class="token operator">=</span> rois<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">*</span> spatial_scale <span class="token operator">-</span> offset  <span class="token comment"># [K]</span>
roi_end_h <span class="token operator">=</span> rois<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">*</span> spatial_scale <span class="token operator">-</span> offset  <span class="token comment"># [K]</span>
roi_width <span class="token operator">=</span> roi_end_w <span class="token operator">-</span> roi_start_w  <span class="token comment"># [K]</span>
roi_height <span class="token operator">=</span> roi_end_h <span class="token operator">-</span> roi_start_h  <span class="token comment"># [K]</span>

bin_size_h <span class="token operator">=</span> roi_height <span class="token operator">/</span> pooled_height  <span class="token comment"># [K]</span>
bin_size_w <span class="token operator">=</span> roi_width <span class="token operator">/</span> pooled_width  <span class="token comment"># [K]</span>
exact_sampling <span class="token operator">=</span> sampling_ratio <span class="token operator">></span> <span class="token number">0</span>		<span class="token comment"># False，使用全部采样</span>

<span class="token comment"># y 方向采样点数量为 bin 的 height，x 方向采样点数量为 bin 的 width</span>
<span class="token comment"># 由于 bin 的 width 和 height 均非整数，所以向上取整，得到采样点数量</span>
<span class="token comment"># 例如 bin size 为 2.2 x 2.2 ，那么采样点数量为 3x3</span>
roi_bin_grid_h <span class="token operator">=</span> sampling_ratio <span class="token keyword">if</span> exact_sampling <span class="token keyword">else</span> torch<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>bin_size_h<span class="token punctuation">)</span>  <span class="token comment"># [K]</span>
roi_bin_grid_w <span class="token operator">=</span> sampling_ratio <span class="token keyword">if</span> exact_sampling <span class="token keyword">else</span> torch<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span>bin_size_w<span class="token punctuation">)</span>  <span class="token comment"># [K]</span>

count <span class="token operator">=</span> torch<span class="token punctuation">.</span>clamp<span class="token punctuation">(</span>roi_bin_grid_h <span class="token operator">*</span> roi_bin_grid_w<span class="token punctuation">,</span> <span class="token builtin">min</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># [K]	每个 proposal 对应的 bin 内采样点数量</span>
iy <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>height<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token builtin">input</span><span class="token punctuation">.</span>device<span class="token punctuation">)</span>  <span class="token comment"># [IY]		# 特征平面 y 坐标: 0 ~ h-1</span>
ix <span class="token operator">=</span> torch<span class="token punctuation">.</span>arange<span class="token punctuation">(</span>width<span class="token punctuation">,</span> device<span class="token operator">=</span><span class="token builtin">input</span><span class="token punctuation">.</span>device<span class="token punctuation">)</span>  <span class="token comment"># [IX]		# 特征平面 x 坐标: 0 ~ w-1</span>
ymask <span class="token operator">=</span> iy<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> roi_bin_grid_h<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span>  <span class="token comment"># [K, IY]	# 掩码，过滤掉不属于 bin 的点</span>
xmask <span class="token operator">=</span> ix<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> roi_bin_grid_w<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span>  <span class="token comment"># [K, IX]	# 后面会详细解释这个掩码</span>

<span class="token keyword">def</span> <span class="token function">from_K</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">:</span>				<span class="token comment"># 维度适配调整</span>
	<span class="token keyword">return</span> t<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span>

<span class="token comment"># 计算采样点坐标，对应下文 (11) 式</span>
y <span class="token operator">=</span> <span class="token punctuation">(</span>
	from_K<span class="token punctuation">(</span>roi_start_h<span class="token punctuation">)</span>
	<span class="token operator">+</span> ph<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> from_K<span class="token punctuation">(</span>bin_size_h<span class="token punctuation">)</span>
	<span class="token operator">+</span> <span class="token punctuation">(</span>iy<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">*</span> from_K<span class="token punctuation">(</span>bin_size_h <span class="token operator">/</span> roi_bin_grid_h<span class="token punctuation">)</span>
<span class="token punctuation">)</span>  <span class="token comment"># [K, PH, IY]</span>
x <span class="token operator">=</span> <span class="token punctuation">(</span>
	from_K<span class="token punctuation">(</span>roi_start_w<span class="token punctuation">)</span>
	<span class="token operator">+</span> pw<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span> <span class="token operator">*</span> from_K<span class="token punctuation">(</span>bin_size_w<span class="token punctuation">)</span>
	<span class="token operator">+</span> <span class="token punctuation">(</span>ix<span class="token punctuation">[</span><span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">)</span> <span class="token operator">*</span> from_K<span class="token punctuation">(</span>bin_size_w <span class="token operator">/</span> roi_bin_grid_w<span class="token punctuation">)</span>
<span class="token punctuation">)</span>  <span class="token comment"># [K, PW, IX]</span>

<span class="token comment"># 采样点坐标在特征平面上不是整型数值，所以采用双线性插值</span>
val <span class="token operator">=</span> _bilinear_interpolate<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> roi_batch_ind<span class="token punctuation">,</span> y<span class="token punctuation">,</span> x<span class="token punctuation">,</span> ymask<span class="token punctuation">,</span> xmask<span class="token punctuation">)</span>  <span class="token comment"># [K, C, PH, PW, IY, IX]</span>
output <span class="token operator">=</span> val<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># remove IY, IX ~> [K, C, PH, PW]</span>
output <span class="token operator">/=</span> count<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">]</span>	<span class="token comment"># 求均值</span>
<span class="token comment"># output 就是 ROIpooling 的输出，shape 为 (K, C, PH, PW)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>确定采样点坐标</strong></p>
<p>以 y 坐标为例说明。已知 当前 scale level 的下采样率为 $d$，proposal 坐标为 $x _ 1, y _ 1, x _ 2, y _ 2$，那么转换到基于特征平面，roi 坐标为</p>
<p>$$x _ 1 ^ r = x _ 1/d, \quad y _ 1 ^ r = y _ 1/ d, \quad x _ 2 ^ r = x _ 2 /d, \quad y _ 2 ^ r = y _ 2 / d \tag{8}$$</p>
<p>roi 的 top size 即 y 轴起始坐标为 $y _ 1 ^ r$ 。每个 bin 的 size 为 $h ^ b = (y _ 2 ^ r - y _ 1 ^ r) / 7$，那么这个 roi 内各个 bin 的 y 轴起始坐标为 $y _ 1 ^ b = y _ 1 ^ r + i\cdot h ^ b$，其中 $i=0,1,\ldots, 6$ 是 bin 的 y 方向 index。</p>
<p>正如代码注释所说的那样，在这里的策略中，采样点数量为 $\lceil w ^ b \rceil \times \lceil h ^ b \rceil$，且所有采样点均匀分布于 bin 内，于是 bin 内各个采样点 y 坐标（基于 bin 而非基于特征平面）为</p>
<p>$$y ^ p = 0.5+k, \quad k = 0,1,\ldots, \lceil h ^ b \rceil - 1 \tag{9}$$</p>
<p>(9) 式这个采样点坐标是基于向上取整的 bin size，所以为了精确性，将坐标映射回原来的 bin size，</p>
<p>$$y ^ p := y ^ p \cdot \frac {h ^ b}{\lceil h ^ b \rceil} \tag{10}$$</p>
<p>其中 $y ^ p / \lceil h ^ b \rceil$ 是归一化的 y 坐标，然后乘以 $h ^ b$ 就恢复到基于 bin height 的坐标。</p>
<p>于是基于特征平面坐标系，采样点的 y 坐标为</p>
<p>$$y _ g ^ p = y _ 1 ^ r + y _ 1 ^ b + y ^ p \tag{11}$$</p>
<p>如图 5 所示，红色点是第一个采样点即，最左上角区域的采样点，那么将来使用双线性插值的时候则是使用红色点所在 cell 的四个角点，而这个 bin 的左上角实际上是位于蓝色点所在 cell，故如果想要对齐（参数 <code>aligned=True</code>），应该使用蓝色点所在 cell 的四个角点进行插值，这种对齐可以通过将 roi 坐标位移 $(-0.5, -0.5)$ 得到，这样所有的坐标包括 roi，bin，采样点坐标，整体全部都位移了 $(-0.5, -0.5)$ ，于是 (8) 式 roi 坐标改为</p>
<p>$$x _ 1 ^ r = x _ 1/d-0.5, \quad y _ 1 ^ r = y _ 1/ d-0.5, \quad x _ 2 ^ r = x _ 2 /d-0.5, \quad y _ 2 ^ r = y _ 2 / d-0.5 \tag{8}$$</p>
<p><img src="/images/mask-rcnn_fig5.png" alt=""></p>
<center>图 5.</center>
<p>计算采样点坐标的代码中，<code>y</code> 有 3 个维度，分别表示 proposal(roi)，bin 和采样点。<code>iy</code> 的范围是 $[0, h-1]$（$h$ 是特征平面 height），这里 <code>iy</code> 应该对应 (9) 式中的 $k$，而 $k$ 范围是 $[0, \lceil h \rceil -1)$，所以对于超出当前 bin 范围的采样点进行过滤，方法见代码中的 <code>ymask = iy[None, :] &lt; roi_bin_grid_h[:, None]</code>，正好就是将范围缩小到 $[0, \lceil h \rceil -1)$ 。</p>
<p><strong>双线性插值</strong></p>
<p>采样点 $(x, y)$ 的值使用所在 cell 的四个角点进行双线性插值，四个角点坐标为</p>
<p>$$(\lfloor x \rfloor, \lfloor y \rfloor), \ (\lfloor x \rfloor+1, \lfloor y \rfloor), \ (\lfloor x \rfloor, \lfloor y \rfloor+1), \ (\lfloor x \rfloor+1, \lfloor y \rfloor+1)$$</p>
<p>4 个权重为</p>
<p>$$\begin{aligned}w _ 1 &amp;= (1+\lfloor x \rfloor - x) (1+\lfloor y \rfloor - y)<br>
\\ w _ 2 &amp;= (x-\lfloor x \rfloor) (1+\lfloor y \rfloor - y)<br>
\\ w _ 3 &amp;= (1+\lfloor x \rfloor - x) (y-\lfloor y \rfloor)<br>
\\ w _ 2 &amp;= (x-\lfloor x \rfloor) (y-\lfloor y \rfloor)\end{aligned} \tag{12}$$</p>
<p>代码中变量 <code>val</code> 的 shape 为 <code>[K, C, PH, PW, IY, IX]</code>，分别表示 proposal(roi)，channel(=256)，bin y 坐标，bin x 坐标，采样点 y 坐标，采样点 x 坐标。</p>
<p>将每个 bin 内的所有采样点求均值就得到 ROIPooling 的输出，shape 为 <code>(K, 256, 7, 7)</code> 。</p>
</details>
<p>每个 scale level 的 ROIPooling 输出 shape 为 <code>(K, 256, 7, 7)</code>，其中 <code>K</code> 是某个 level 的 proposals 数量，组合起来就是 <code>(512B, 256, 7, 7)</code>，其中 <code>B</code> 是训练的 batch size 。</p>
<h2 id="box-head">box head</h2>
<p>ROIPooling 之后，得到特征，其 shape 为 <code>(512B, 256, 7, 7)</code>，其中 <code>B</code> 是训练 batch size，每个 image 中选择 <code>512</code> 个 proposals 样本（正负样本比例 <code>1:3</code>，根据 RPN 输出 objectness 得分排序，选择 top $K _ 1$，然后 NMS，然后选择 top $K _ 2$，然后将 gt boxes 也加入 proposals，然后根据 IoU 阈值分配正负样本，最后选择计算适量正负样本）。</p>
<p>现在这个特征分别经过 box head ，进行坐标回归预测，和分类预测。</p>
<p>box head 由 若干 conv + 若干 FC 构成，代码中 FC 输出 channel 为 <code>1024</code>，所以 box head 输出的特征 shape 为 <code>(512B, 1024)</code> 。</p>
<p>box head 的输出特征分别经过一个 FC 将 channel 调整为 <code>C+1</code> 和另一个 FC 将 channel 调整为 <code>C*4</code>，前者用于预测分类，后者预测 box 坐标，每个分类单独预测 box 坐标。</p>
<p><strong>box head 损失</strong></p>
<p>坐标损失使用 smooth L1，分类损失使用交叉熵损失。</p>
<p>proposals 数量为 <code>512*B</code>，分类预测值 shape 为 <code>(512B, C+1)</code>，分类 target 的 shape 为 <code>(512B, )</code>，正例 proposal 为最大 IoU 对应的 gt box 分类，负例 proposal 为 <code>C</code> 。</p>
<p>计算正例 proposals 的坐标回归损失，由于坐标预测维度是 <code>C*4</code>，所以先根据正例 proposals 的分类 target 提取对应的 box 预测，得到预测数据的 shape 为 <code>(N, 4)</code>，其中 <code>N</code> 是正例数量。</p>
<p>正例的坐标 target 需要根据正例 proposals 的坐标和对应的 gt boxes 坐标计算得到，如下所示，</p>
<p>$$\begin{aligned} t _ x &amp;= \frac {x _ g - x _ p}{w _ p}, \quad t _ y = \frac {y _ g - y _ p}{h _ p}<br>
\\ t _ w &amp;= \log \frac {w _ g}{w _ p}, \quad t _ h = \log \frac {h _ g}{h _ p}<br>
\end{aligned} \tag{13}$$</p>
<p>其中下标 $g$ 表示 gt box，$p$ 表示 proposal。（RPN 中其实也是类似处理得到坐标回归 target，把 $p$ 改成 $a$ 表示 anchor box）</p>
<p><strong>注意</strong></p>
<p>所有 <strong>正例</strong> proposals 的坐标回归损失求和，然后 <strong>除以总的 proposals 数量</strong> 求平均，为什么不是除以正例数量，源码注释解释了原因：为了给每个正例相等的训练影响，这里正例是指全数据集中的正例。考虑以下两种 mini batch 的情况：</p>
<ol>
<li>仅有一个正例</li>
<li>有 100 个正例</li>
</ol>
<p>如果除以正例数量，那么情况 <code>1</code> 的正例梯度是情况 <code>2</code> 中正例梯度的 100 倍，所以导致学习影响不均衡。</p>
<h2 id="mask-head">mask head</h2>
<p>实例分割比目标检测多了一个 mask head。与 box head 类似，mask head 也是将 FPN 的输出特征（仅使用 <code>P2,P3,P4,P5</code>，P6 特征不用）使用 proposals 进行 ROIPooling ，这里 proposals 与 box head 中的完全相同，只是 ROIPooling 输出 spatial size 为 <code>14x14</code>，因为 <code>7x7</code> 太小，损失了太多信息。</p>
<p>mask head 完成处理过程如下：</p>
<ol>
<li>
<p>使用与 box head 相同的 proposals，即每个 image 取 512 个 proposals，其中 <code>128</code> 个正例</p>
</li>
<li>
<p>提取正例 proposals，数量为 <code>128*B</code>，这里 <code>B</code> 是训练的 batch size。使用 ROIPooling 将 <code>128*B</code> 个正例 proposals 的特征池化为 <code>14x14</code> 的 size，即特征 shape 为 $(128B, 256, 14, 14)$</p>
<p>这里使用 proposal boxes 而非 proposals 对应的 gt boxes 对特征进行框定，然后再进行池化。</p>
</li>
<li>
<p>经过 <code>4</code> 个 conv3x3 ，输出 shape 不变，为 $(128B, 256, 14, 14)$</p>
</li>
<li>
<p>经过 <code>1</code> 个转置卷积，用于增大输出特征的 spatial size，输出的 shape 为 $(128B, 256, 28, 28)$</p>
<p>代码为，</p>
 <pre class="line-numbers language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>deconv <span class="token operator">=</span> ConvTranspose2d<span class="token punctuation">(</span>
	<span class="token comment"># feat_in: 256, feat_out: 256</span>
	cur_channels<span class="token punctuation">,</span> conv_dims<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">0</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>计算输出 spatial size 时，将输入输出 size 置换即可，例如求 h，</p>
<p>$$h _ i = \frac {h _ o + 2p - k} {s} + 1$$</p>
<p>代入 $h _ i = 14, \ s = 1, \ p = 0, \ k = 2$，解得 $h _ o = 28$</p>
</li>
<li>
<p>经过 <code>1</code> 个 conv1x1，输出 channel 为 $C$，预测特征平面上每个 pixel 的分类得分，数据 shape 为 $(128B, C, 28, 28)$</p>
<p>代码为，</p>
 <pre class="line-numbers language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>predictor <span class="token operator">=</span> Conv2d<span class="token punctuation">(</span>cur_channels<span class="token punctuation">,</span> num_classes<span class="token punctuation">,</span> kernel_size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> stride<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> padding<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<p><strong>计算 mask head 的损失</strong></p>
<p>每个 proposal 均有自己的 box（由 RPN 预测得到），以及匹配的 gt box，而每个 gt box 均有一个 gt mask，其 shape 为 $(H, W)$ ，即 network 输入 image 的 size。相关代码片段为，</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># sampled_idxs: 当前 image 中选择的 512 个 proposals 的 idxs</span>
<span class="token comment"># matched_idxs: 当前 image 中所有的 proposals 对应的 gt boxes 的 idxs</span>
sampled_targets <span class="token operator">=</span> matched_idxs<span class="token punctuation">[</span>sampled_idxs<span class="token punctuation">]</span>	<span class="token comment"># 得到 512 个 proposals 对应的 gt boxes 的 idxs</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>trg_name<span class="token punctuation">,</span> trg_value<span class="token punctuation">)</span> <span class="token keyword">in</span> targets_per_image<span class="token punctuation">.</span>get_fields<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">if</span> trg_name<span class="token punctuation">.</span>startswith<span class="token punctuation">(</span><span class="token string">"gt_"</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token keyword">not</span> proposals_per_image<span class="token punctuation">.</span>has<span class="token punctuation">(</span>trg_name<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 例如 gt_masks</span>
		proposals_per_image<span class="token punctuation">.</span><span class="token builtin">set</span><span class="token punctuation">(</span>trg_name<span class="token punctuation">,</span> trg_value<span class="token punctuation">[</span>sampled_targets<span class="token punctuation">]</span><span class="token punctuation">)</span>	<span class="token comment"># 得到 512 个 proposals 对应的 gt_masks</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在每个 image 有 <code>128</code> 个正样本 proposals，所以其对应的 gt masks 的 shape 为 $(128, H, W)$。</p>
<ol>
<li>根据 proposal 的 boxes 坐标，从 gt masks 中抠出，然后 resize 到 <code>28x28</code> 的大小，得到单个 image 的 mask target，其 shape 为 $(128, 28, 28)$，每个 pixel 的 target 值为 <code>0</code> 或 <code>1</code> 。</li>
<li>每个 proposals 的预测得分为 $(128, C, 28, 28)$，根据每个 proposal 对应 gt box 的分类，取分类所对应的 channel map，那么所得数据的 shape 为 $(128, 28, 28)$</li>
<li>以上两者进行交叉熵计算，spatial map 上每个 pixel 处独立计算交叉熵损失。由于预测得分表示 logits，非归一化，所以先对预测得分使用 $\sigma$ 函数，然后计算 binary 交叉熵。</li>
</ol>
<p><strong>如何将 mask map 进行 crop and resize</strong></p>
<p>这里与前面 ROIAlign 原理完全相同，在 gt mask map 上将 proposal box 划分为 $28\times 28$ 个 bin，每个 bin 内完全采样，然后每个采样点所在 cell 的 4 个角点使用双线性插值得到这个采样点的值，bin 内所有采样点计算均值，然后判断均值是否 <code>&gt; 0.5</code>，如是，那么这个 bin 的 mask target 为 <code>1</code>，否则为 <code>0</code> 。</p>
<p>这里 gt mask map 的 size 为 $(H,W)$ 即网络的输入 image size，而 proposal 的坐标刚好也是基于输入 image size 的，所以无需将 proposal 坐标 rescale，如下方代码中的 ROIAlign 初始化参数 <code>1.0</code>（回顾前面对 scale level 的特征进行 ROIAlign 则需要非 1 的 <code>spatial_scale</code> 值），</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">output <span class="token operator">=</span> <span class="token punctuation">(</span>
	ROIAlign<span class="token punctuation">(</span><span class="token punctuation">(</span>mask_size<span class="token punctuation">,</span> mask_size<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> aligned<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>	<span class="token comment"># 这里参数 1.0 表示 spatial_scale</span>
	<span class="token punctuation">.</span>forward<span class="token punctuation">(</span>bit_masks<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token boolean">None</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rois<span class="token punctuation">)</span>
	<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
output <span class="token operator">=</span> output <span class="token operator">>=</span> <span class="token number">0.5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="inference">inference</h2>
<p>实力分割任务的推理阶段的流程：</p>
<ol>
<li>
<p>FPN 生成 multi scale 的输出特征</p>
</li>
<li>
<p>上一步的特征送入 RPN，得到基于 anchor 的 objectness 预测得分以及坐标回归预测。</p>
</li>
<li>
<p>每个 level 取 top $K _ 1 = 1000$ 的 proposals，然后每个 image 的 $5 K _ 2$ 个 proposals 进行 NMS，然后再取 top $K _ 2 = 1000$</p>
</li>
<li>
<p>上述 $BK _ 2$（其中 B 是 batch size）个 proposals 与 FPN 的输出特征一起送入 roi_head，roi_head 取 <code>P2,P3,P4,P5</code> 特征，然后使用 proposals 框定出区域特征</p>
</li>
<li>
<p>将 proposals 的区域特征使用 ROIPooling 得到 <code>7x7</code> 的 spatial size 特征，其 shape 为 $(BK _ 2, 256, 7, 7)$，flatten 之后送入两个 FC（即 box head）将输出 channel 调整为 <code>1024</code></p>
</li>
<li>
<p>上一步 box head 输出的 $(BK _ 2, 1024)$ 分别经过：一个 conv1x1 输出 $(BK _ 2, C+1)$ 的分类预测得分；一个 conv1x1 输出 $(BK _ 2, 4C)$ 的坐标回归预测</p>
</li>
<li>
<p>根据上一步的坐标回归预测，将这个偏差预测，应用到 proposals 上，得到最终的 boxes 坐标预测。将上一步的分类预测得分通过 softmax 进行归一化。于是，每个 image 的 boxes 坐标值 shape 为 $(K _ 2, 4C)$，分类概率预测的 shape 为 $(K _ 2, C+1)$</p>
</li>
<li>
<p>每个 image 中，上述坐标值 reshape 为 $(K _ 2, C, 4)$，分类得分预测去掉最后一列，因为最后一列是 bg 的概率，故所有前景的分类概率预测 shape 为 $(K _ 2, C)$，使用一个阈值 <code>0.05</code>，筛选出 <code>&gt; 0.05</code> 的分类概率预测，根据这个 mask，筛选出相应的预测坐标值，以及相应的分类概率预测值，记分类预测概率矩阵 $K _ 2 \times C$ 中有 $R$ 个元素值 <code>&gt; 0.05</code>，那么筛选出来的分类概率 shape 为 $(R, )$，相应的坐标 shape 为 $(R, 4)$</p>
</li>
<li>
<p>将上一步中的 boxes 进行 NMS，注意是每个分类独立进行 NMS，NMS 阈值为 <code>0.5</code> ，记 NMS 之后保留的 box 数量为 $r$。</p>
</li>
<li>
<p>上一步 NMS 之后保留下来的 boxes 中，再按分类预测得分，选择最多 top <code>100</code> 即 $r:=\min(r, 100)$ 个预测 boxes</p>
</li>
</ol>
<p>（以上步骤，就得到了每个 image 中的预测 box 坐标和所属分类。接下来看 mask 预测。）</p>
<ol start="11">
<li>
<p>根据上一步得到的 $r$ 个预测 boxes，将 FPN 的输出特征 <code>P2,P3,P4,P5</code> 使用 mask_head 的 ROIPooling，池化得到 $(r, 256, 14, 14)$ 的特征，对 <code>B</code> 个 images，则得到所有 proposals 的池化特征 shape 为 $(\sum _ {i=1} ^ B r _ i, 256, 14, 14)$ ，经过 4 个 conv3x3，以及 1 个 deconv，输出特征为 $(\sum _ {i=1} ^ B r _ i, 256, 28, 28)$，最后使用 1 个 conv1x1，调整输出 channel，得到 mask 的预测 logits，其 shape $(\sum _ {i=1} ^ B r _ i, C, 28, 28)$ 。</p>
</li>
<li>
<p>根据所有 images 的 $\sum _ {i=1} ^ B r _ i$ 个预测 boxes 的分类预测，从 mask 的预测 logits 中提取各个分类对应的 channel map，得到 logits 其 shape 为 $(\sum _ {i=1} ^ B r _ i, 1, 28, 28)$，然后应用 $\sigma$ 函数，就得到 mask 预测概率。</p>
</li>
</ol>
<p>现在，得到所有 $\sum _ {i=1} ^ B r _ i$ 预测 boxes 的分类，坐标，以及 mask 概率，但是需要注意每个 box 的 mask map 是 $28\times 28$ 大小的，而非输入 image $H \times W$ 大小，所以还需要将 mask size rescale 到 image size 。backbone 是全卷积网络，所以一个 batch 中各个 image size 可能也不同，并且同一 image 的宽度和高度也可能不等。</p>
<p>每个预测 box 的 mask map 为 $28\times 28$，注意其对应的应该是 box 自身，而非整个 image ，记 box 的预测坐标为 $(x _ 1, y _ 1, x _ 2, y _ 2)$， 所以常见的方法是将 mask map 通过双线性插值 resize 到 $(y _ 2 - y _ 1, x _ 2 - x _ 1)$ ，然后 paste 到 image 中，左上角顶点位置为 $(x _ 1, y _ 1)$ 。代码中使用 <code>torch.nn.functional.grid_sample</code> 这一函数同时实现 resize and paste 功能。</p>
<p><strong>grid_sample 函数简介</strong></p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>functional<span class="token punctuation">.</span>grid_sample<span class="token punctuation">(</span><span class="token builtin">input</span><span class="token punctuation">,</span> grid<span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'bilinear'</span><span class="token punctuation">,</span> padding_mode<span class="token operator">=</span><span class="token string">'zeros'</span><span class="token punctuation">,</span> align_corners<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>input</code> 为数据源，shape 为 $(N, C, H_{in}, W _ {in})$， 我们这里就是 $28 \times 28$ 大小的 mask map</p>
<p><code>grid</code> shape 为 $(N, H _ {out}, W _ {out}, 2)$，其值指定 <code>input</code> 中的数据位置。</p>
<p>输出：shape 为 $(N, C, H _ {out}, W _ {out})$</p>
<p>计算输出数据每个位置 $[n,:, h, w]$ 的值时，根据 grid 中相同位置 $[n, h, w]$ 的值，这个值是一个 length=2 的向量，记为 $z$ ，这个 $z$ 就指定了 <code>input</code> 中的 spatial location，数学表达式如下，</p>
<p>$$\begin{aligned} &amp; z = \text{grid}[n,h,w]<br>
\\ &amp; x = 0.5\times (z[0] + 1) \times W _ {in}, \quad y = 0.5\times (z[1]+1) \times H _ {in}<br>
\\ &amp; \text{output}[n,:,h, w] =\text{input}[n,:, y, x]\end{aligned}$$</p>
<p>注意上式中，</p>
<ol>
<li>如果 $z [i] \in [-1, 1], \ i =1,2$，那么 $x \in [0, W _ {in}]$，$y \in [0, H _ {in}]$，$x, y$ 不是整型数值，所以使用双线性插值</li>
<li>如果 $z[i] \notin [-1,1], \ i=1,2$，那么输出值使用指定的填充模式进行填充</li>
</ol>
<p>如此，就得到 image size 的 mask，最后根据 mask 的阈值例如 <code>0.5</code> 进行二值化。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">shajianjian</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://jianjiansha.github.io/2019/07/08/obj_det/mask-rcnn/">https://jianjiansha.github.io/2019/07/08/obj_det/mask-rcnn/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">shajianjian</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/object-detection/">
                                    <span class="chip bg-color">object detection</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/07/11/cpp/cpp-aux-tools/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/8.jpg" class="responsive-img" alt="cpp-aux-tools">
                        
                        <span class="card-title">cpp-aux-tools</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            来看一个 c++ 程序片段
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-07-11
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            shajianjian
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/c/">
                        <span class="chip bg-color">c++</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/07/08/obj_det/DSOD/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/4.jpg" class="responsive-img" alt="DSOD">
                        
                        <span class="card-title">DSOD</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            论文 DSOD: Learning Deeply Supervised Object Detectors from Scratch
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-07-08
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            shajianjian
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/object-detection/">
                        <span class="chip bg-color">object detection</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2024</span>
            
            <a href="/about" target="_blank">shajianjian</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/jianjiansha" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:501834524@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=501834524" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 501834524" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    
        <!-- <script src='https://unpkg.com/mermaid@latest/dist/mermaid.min.js'></script> -->
        <script src='/libs/mermaid/mermaid.min.js'></script>
        <script>
          if (window.mermaid) {
            mermaid.initialize({theme: 'forest'});
          }
        </script>
    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
