<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"shajianjian.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="SJJ">
<meta property="og:url" content="https://shajianjian.github.io/page/2/index.html">
<meta property="og:site_name" content="SJJ">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="shajianjian">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://shajianjian.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>SJJ</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SJJ</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/06/02/cpp/cmake_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/02/cpp/cmake_1/" class="post-title-link" itemprop="url">cmake tutorial</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-02 10:35:18" itemprop="dateCreated datePublished" datetime="2021-06-02T10:35:18+08:00">2021-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-04 11:55:05" itemprop="dateModified" datetime="2021-06-04T11:55:05+08:00">2021-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>记录 cmake 的各种用法。从一个简单的例子开始入手。</p>
<h1 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h1><p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CMakeLists.txt</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(hello_world)</span><br><span class="line"><span class="keyword">add_executable</span>(app main.cpp)</span><br></pre></td></tr></table></figure>
<p>以上两个文件在同一目录 <code>demo</code> 下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">demo</span><br><span class="line">| -- main.cpp</span><br><span class="line">| -- CMakeLists.txt</span><br></pre></td></tr></table></figure>
<p>在 <code>demo</code> 目录下，使用以下两个命令生成，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cmake .</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> cmake --build .</span></span><br></pre></td></tr></table></figure>
<p>第一个命令是 生成 Makefile，第二个命令是生成 可执行文件。这种生成方式会生成一些文件，扰乱源码，于是可以在 <code>demo</code> 下创建一个 <code>build</code> 目录，所有生成的文件均放在 <code>build</code> 目录下，这样不污染源码文件，命令如下，</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; mkdir build</span><br><span class="line">&gt; <span class="built_in">cd</span> build</span><br><span class="line">&gt; cmake ..</span><br><span class="line">&gt; cmake --build .</span><br></pre></td></tr></table></figure>

<h1 id="多个源文件的生成"><a href="#多个源文件的生成" class="headerlink" title="多个源文件的生成"></a>多个源文件的生成</h1><p>文件目录为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">demo</span><br><span class="line">| -- build</span><br><span class="line">| -- main.cpp</span><br><span class="line">| -- foo.h</span><br><span class="line">| -- foo.cpp</span><br><span class="line">| -- CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>各文件内容为，</p>
<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>foo.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>foo.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"foo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CMakeLists.txt</strong></p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(hello_world)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(app main.cpp foo.cpp)</span><br></pre></td></tr></table></figure>

<p>如果将头文件统一放入 <code>includes</code> 目标中，即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">demo</span><br><span class="line">| -- build</span><br><span class="line">| -- inlcude</span><br><span class="line">    |-- foo.h</span><br><span class="line">| -- main.cpp</span><br><span class="line">| -- foo.cpp</span><br><span class="line">| -- CMakeLists.txt</span><br></pre></td></tr></table></figure>
<p>那么还需要指定头文件搜索路径，否则找不到头文件，指定头文件搜索路径可使用</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">inlcude_directories(<span class="string">"$&#123;PROJECT_SOURCE_DIR&#125;/includes"</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(app main.cpp foo.cpp)</span><br></pre></td></tr></table></figure>
<p>其中 路径的引号可以去掉。</p>
<h1 id="生成库和链接库"><a href="#生成库和链接库" class="headerlink" title="生成库和链接库"></a>生成库和链接库</h1><p>修改 CMakeLists.txt 文件，其他不变，</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span> (hello_world)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">"$&#123;PROJECT_SOURCE_DIR&#125;/includes"</span>)</span><br><span class="line"><span class="keyword">add_library</span>(foo foo.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(app main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app foo)</span><br></pre></td></tr></table></figure>

<h1 id="添加头文件搜索路径"><a href="#添加头文件搜索路径" class="headerlink" title="添加头文件搜索路径"></a>添加头文件搜索路径</h1><p>语法：</p>
<ul>
<li><code>include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...])</code></li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>dirN</td>
<td>一个或多个相对路径或绝对路径</td>
</tr>
<tr>
<td>AFTER, BEFORE</td>
<td>搜索路径是添加到当前搜索路径列表的后面还是前面。默认行为由 CMAKE_INCLUDE_DIRECTORIES_BEFORE 指定</td>
</tr>
<tr>
<td>SYSTEM</td>
<td>添加的路径是否视作系统头文件路径</td>
</tr>
</tbody></table>
<p>由于可以是相对路径，故前面添加头文件路径也可以写作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include_directories(include)</span><br></pre></td></tr></table></figure>
<p>添加的头文件搜索路径，对当前 directory 中所有 targets 以及所有 subdirectories （由 add_subdirectory() 给定） 均有效。</p>
<h1 id="生成目标"><a href="#生成目标" class="headerlink" title="生成目标"></a>生成目标</h1><p>语法：</p>
<ul>
<li><code>add_executable(target_name [EXCLUDE_FROM_ALL] source1 [source2...])</code></li>
<li><code>add_library(lib_name [STATIC|SHARED|MODULE][EXCLUDE_FROM_ALL] source1 [source2...])</code></li>
</ul>
<p>例如，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_executable(my_ext main.cpp util.cpp)</span><br></pre></td></tr></table></figure>

<p>这会生成 <code>my_exe</code> 目标（例如 linux 上使用 <code>make my_exe</code>），默认情况下，所有的可执行目标均添加到 <code>all</code> 目标下，如果要从 <code>all</code> 下排除某个目标，可使用 <code>EXCLUDE_FROM_ALL</code> 参数，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_executable(my_exe EXCLUDE_FROM_ALL main.cpp)</span><br></pre></td></tr></table></figure>

<p><code>add_library</code> 用于生成库，<code>BUILD_SHARED_LIBS</code> BOOL 型变量控制生成一个 static 库还是 shared 库，例如 <code>cmake .. -DBUILD_SHARED_LIBS=ON</code>，也可以直接指定，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_library(my_lib SHARED lib.cpp)</span><br></pre></td></tr></table></figure>
<p><code>MODULE</code> 指定这个库在 runtime 时使用 <code>dlopen</code> 之类的函数进行动态加载。</p>
<h1 id="MACROS"><a href="#MACROS" class="headerlink" title="MACROS"></a>MACROS</h1><p>宏和函数的区别是，函数本身是一个新的 scope，而宏则在当前 context 中执行，因此，函数中定义的变量在函数结束后变得未知，而宏中的变量在宏结束后继续保持定义。<br>例子：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">macro</span>(set_my_variable _INPUT)</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">"$&#123;_INPUT&#125;"</span> <span class="keyword">STREQUAL</span> <span class="string">"Foo"</span>)</span><br><span class="line">    <span class="keyword">set</span>(my_output_variable <span class="string">"foo"</span>)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">set</span>(my_output_variable <span class="string">"bar"</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endmacro</span>(set_my_variable)</span><br></pre></td></tr></table></figure>
<p>使用宏，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_my_variable(&quot;Foo&quot;)</span><br><span class="line">message(STATUS $&#123;my_output_variable&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="多层级项目"><a href="#多层级项目" class="headerlink" title="多层级项目"></a>多层级项目</h1><p>项目目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CMakeLists.txt</span><br><span class="line">editor&#x2F;</span><br><span class="line">    CMakeLists.txt</span><br><span class="line">    src&#x2F;</span><br><span class="line">        editor.cpp</span><br><span class="line">highlight&#x2F;</span><br><span class="line">    CMakeLists.txt</span><br><span class="line">    include&#x2F;</span><br><span class="line">        highlight.h</span><br><span class="line">    src&#x2F;</span><br><span class="line">        highlight.cpp</span><br></pre></td></tr></table></figure>

<p>文件内容为，</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span> (example)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(highlight)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(editor)</span><br></pre></td></tr></table></figure>

<p>highlight 库，</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># highlight/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span> (highlight)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> src/highlight.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>
<p>使用 <code>target_include_directories()</code> 代替 <code>include_directories()</code>，那么头文件搜索路径可以传递到这个库的使用者那里。</p>
<p>可执行程序，</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># editor/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span> (editor)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> src/editor.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> PUBLIC highlight)</span><br></pre></td></tr></table></figure>
<p>cmake 自动处理 highlight 的库文件路径和头文件路径。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>指定安装时的所作的事情，即 <code>make install</code>，或者使用 <code>cmake --install .</code>。</p>
<h2 id="安装目标文件"><a href="#安装目标文件" class="headerlink" title="安装目标文件"></a>安装目标文件</h2><p><code>install(TARGETS &lt;target&gt;... [...])</code></p>
<p>target 指定被安装的目标，可以是多个，<code>[...]</code> 中指定安装选项，常见选项有，</p>
<ul>
<li>DESTINATION</li>
</ul>
<p>指定目标安装的路径，可以是绝对路径或者相对路径，如果是相对路径，那么路径是相对于 <code>CMAKE_INSTALL_PREFIX</code>，此值默认为 <code>/usr/local</code>（linux），可以在命令选项中更改 <code>cmake -DCMAKE_INSTALL_PREFIX=/my/path ..</code></p>
<ul>
<li>PERMISSIONS</li>
</ul>
<p>指定安装文件的权限，值可以是 <code>OWNER_READ, OWNER_WRITE, OWNER_EXECUTE, GROUP_READ, GROUP_WRITE, GROUP_EXECUTE, WORLD_READ, WORLD_WRITE, WORLD_EXECUTE, SETUID, SETGID</code> </p>
<p>多个目标可以是可执行文件，动态库，静态库，以及头文件等，可以通过选项 <code>RUNTIME, LIBRARY, ARCHIVE, PUBLIC_HEADER, PRIVATE_HEADER</code> 等分别指定，例如，</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSTALL</span>(TARGETS myapp, mylib, mystaticlib</span><br><span class="line">    RUNTIME DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span></span><br><span class="line">    LIBRARY DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span></span><br><span class="line">    ARCHIVE DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>CONFIGURATIONS</li>
</ul>
<p>指定安装规则所应用的生成配置，例如 Debug，Release，这仅适用于 <code>CONFIGURATIONS</code> 之后的选项上，例如，对于 Debug 和 Release 配置，分别指定不用的安装路径，</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS <span class="keyword">target</span></span><br><span class="line">    CONFIGURATIONS Debug</span><br><span class="line">    RUNTIME DESTINATION Debug/bin)</span><br><span class="line"><span class="keyword">install</span>(TARGETS <span class="keyword">target</span></span><br><span class="line">    CONFIGURATIONS Release</span><br><span class="line">    RUNTIME DESTINATION Release/bin)</span><br></pre></td></tr></table></figure>
<p>注：可通过 <code>-DCMAKE_BUILD_TYPE=Debug</code> 指定生成配置。</p>
<ul>
<li>RENAME</li>
</ul>
<p>重命名被安装的目标文件。这个选项仅在命令中只有一个文件被安装的时候可以用。</p>
<ul>
<li>OPTIONAL</li>
</ul>
<p>如果被安装的文件不存在，那么不会抛出错误。</p>
<ul>
<li>EXCLUDE_FROM_ALL</li>
</ul>
<p>从默认安装中排除此文件的安装。</p>
<ul>
<li>COMPONENT</li>
</ul>
<p>给安装规则指定一个组件名，于是可以安装指定的组件，而其他组件则不被安装。在全安装（不知道组件名）时，所有除了 EXCLUDE_FROM_ALL 的安装规则都将被执行。默认情况安装规则的组件名为 <code>Unspecified</code>。</p>
<p>完整的安装目标的命令如下，</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS targets... [<span class="keyword">EXPORT</span> &lt;<span class="keyword">export</span>-name&gt;]</span><br><span class="line">        [[ARCHIVE|LIBRARY|RUNTIME|OBJECTS|FRAMEWORK|BUNDLE|</span><br><span class="line">          PRIVATE_HEADER|PUBLIC_HEADER|RESOURCE]</span><br><span class="line">         [DESTINATION &lt;dir&gt;]</span><br><span class="line">         [PERMISSIONS permissions...]</span><br><span class="line">         [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">         [COMPONENT &lt;component&gt;]</span><br><span class="line">         [NAMELINK_COMPONENT &lt;component&gt;]</span><br><span class="line">         [OPTIONAL] [EXCLUDE_FROM_ALL]</span><br><span class="line">         [NAMELINK_ONLY|NAMELINK_SKIP]</span><br><span class="line">        ] [...]</span><br><span class="line">        [INCLUDES DESTINATION [&lt;dir&gt; ...]]</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<ul>
<li>EXPORT</li>
</ul>
<p>给安装的目标文件关联到一个导出上，导出名字为 <code>export-name</code>。EXPORT 必须出现在其他选项之前。</p>
<h2 id="安装普通文件"><a href="#安装普通文件" class="headerlink" title="安装普通文件"></a>安装普通文件</h2><p>命令如下，</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(&lt;FILES|PROGRAMS&gt; files...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [PERMISSIONS permissions...]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [COMPONENT &lt;component&gt;]</span><br><span class="line">        [RENAME &lt;name&gt;] [OPTIONAL] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure>
<p>如果给出的是文件相对路径，那么是相对于当前源目录 <code>CMAKE_SOURCE_DIR</code>。<br>FILES 表示普通文件，PROGRAMS 表示非目标文件的可执行程序，如脚本。</p>
<ul>
<li>TYPE</li>
</ul>
<p>不同的 TYPE 值，默认安装路径也不同。</p>
<h2 id="安装目录"><a href="#安装目录" class="headerlink" title="安装目录"></a>安装目录</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY dirs...</span><br><span class="line">        TYPE &lt;type&gt; | DESTINATION &lt;dir&gt;</span><br><span class="line">        [FILE_PERMISSIONS permissions...]</span><br><span class="line">        [DIRECTORY_PERMISSIONS permissions...]</span><br><span class="line">        [USE_SOURCE_PERMISSIONS] [OPTIONAL] [MESSAGE_NEVER]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [COMPONENT &lt;component&gt;] [EXCLUDE_FROM_ALL]</span><br><span class="line">        [FILES_MATCHING]</span><br><span class="line">        [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">         [EXCLUDE] [PERMISSIONS permissions...]] [...])</span><br></pre></td></tr></table></figure>

<ul>
<li>DIRECTORY</li>
</ul>
<p>此选项后面跟一个或多个目录，用于被安装到指定 <code>DESTINATION</code> 下。dirs 这个目录如果末尾没有 <code>/</code>，那么这个目录内容连同目录自身都将被安装，否则只安装目录的内容。</p>
<ul>
<li>USE_SOURCE_PERMISSIONS</li>
</ul>
<p><code>FILE_PERMISSIONS</code> 和 <code>DIRECTORY_PERMISSIONS</code> 用于指定目录中文件和目录的权限。如果指定了 <code>USE_SOURCE_PERMISSIONS</code> 且未指定 <code>FILE_PERMISSIONS</code>，那么从源目录结构中复制文件权限。</p>
<ul>
<li>PATTERN REGEX</li>
</ul>
<p>精细粒度的控制目录安装。PATTERN 匹配完整的文件名，REGEX 使用正则匹配。例子，</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY icons scripts/ DESTINATION share/myproj</span><br><span class="line">        PATTERN <span class="string">"CVS"</span> EXCLUDE</span><br><span class="line">        PATTERN <span class="string">"scripts/*"</span></span><br><span class="line">        PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ</span><br><span class="line">                    GROUP_EXECUTE GROUP_READ)</span><br></pre></td></tr></table></figure>
<p>将 <code>icons</code> 目录和 <code>scripts</code> 目录内容 安装到 <code>share/myproj</code>， 其中 <code>CVS</code> 子目录或文件不被安装。对于 <code>scripts/*</code> 中的文件，指定权限）。</p>
<p>在 <code>PATTERN &quot;CVS&quot; EXCLUDE</code> 中，如果去掉 <code>EXCLUDE</code>，那么 “CVS” 子目录或文件依然会被安装。</p>
<ul>
<li>FILES_MATCHING</li>
</ul>
<p>默认情况下，无论文件是否匹配中，都会被安装。如果在所有匹配模式前面增加 <code>FILES_MATCHING</code> 选项，那么那些未被任何模式匹配中的文件或目录则不会被安装。例如，</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY src/ DESTINATION <span class="keyword">include</span>/myproj</span><br><span class="line">        FILES_MATCHING PATTERN <span class="string">"*.h"</span>)</span><br></pre></td></tr></table></figure>
<p>仅安装源目录中的头文件。</p>
<h2 id="安装时脚本运行"><a href="#安装时脚本运行" class="headerlink" title="安装时脚本运行"></a>安装时脚本运行</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>([[SCRIPT &lt;<span class="keyword">file</span>&gt;] [CODE &lt;code&gt;]]</span><br><span class="line">        [COMPONENT &lt;component&gt;] [EXCLUDE_FROM_ALL] [...])</span><br></pre></td></tr></table></figure>
<p>SCRIPT 指定安装时需要执行的 CMAKE 脚本，如果脚本文件是相对路径，那么是相对于当前源路径。</p>
<p>CODE 指定安装时需要执行的 CMAKE 代码，例如，</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(CODE <span class="string">"MESSAGE(\"Sample install message.\")"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="安装导出"><a href="#安装导出" class="headerlink" title="安装导出"></a>安装导出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">install(EXPORT &lt;export-name&gt; DESTINATION &lt;dir&gt;</span><br><span class="line">        [NAMESPACE &lt;namespace&gt;] [[FILE &lt;name&gt;.cmake]|</span><br><span class="line">        [PERMISSIONS permissions...]</span><br><span class="line">        [CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">        [EXPORT_LINK_INTERFACE_LIBRARIES]</span><br><span class="line">        [COMPONENT &lt;component&gt;]</span><br><span class="line">        [EXCLUDE_FROM_ALL])</span><br><span class="line">install(EXPORT_ANDROID_MK &lt;export-name&gt; DESTINATION &lt;dir&gt; [...])</span><br></pre></td></tr></table></figure>
<p>安装导出。导出目标在 <code>install(TARGETS)</code> 中的 <code>EXPORT</code> 选项指定。<code>NAMESPACE</code> 指定导出目标名称的命令空间（相当于前缀），默认情况下安装的导出文件名为 <code>&lt;export-name&gt;.cmake</code>，但可以通过 <code>FILE</code> 进行重命名。<code>DESTINATION</code> 指定这个 .cmake 文件安装的路径。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/03/08/dl/norm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/08/dl/norm/" class="post-title-link" itemprop="url">Normalization</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-08 11:26:46" itemprop="dateCreated datePublished" datetime="2021-03-08T11:26:46+08:00">2021-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-12 15:39:48" itemprop="dateModified" datetime="2021-03-12T15:39:48+08:00">2021-03-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Batch-Norm"><a href="#Batch-Norm" class="headerlink" title="Batch Norm"></a>Batch Norm</h1><p>对 channel 之外的所有维度做归一化，即在 <code>(B,H,W)</code> 上做归一化，每个 channel 独立进行，<br>$$y=\frac {x-E[x]} {\sqrt{Var[x]+\epsilon}} \cdot \gamma + \beta$$<br>作用：</p>
<ol>
<li>防止过拟合。单个样本的输出依赖于整个 mini-batch，防止对某个样本过拟合</li>
<li>加快收敛。梯度下降过程中，每一层的 W 和 b 都会不断变化，导致输出结果分布也不断变化，后层网络需要不停地适应这种变化，而 BN 可使得每一层输入分布近似不变。</li>
<li>防止梯度消失。以 sigmoid 激活函数为例，经过 BN 使得输出在中心附近，梯度较大。</li>
</ol>
<h1 id="Layer-Norm"><a href="#Layer-Norm" class="headerlink" title="Layer Norm"></a>Layer Norm</h1><p>Layer Norm 对每个样本进行归一化，即在 <code>(C,H,W)</code> 上做归一化，每个样本独立进行。</p>
<h1 id="Instance-Norm"><a href="#Instance-Norm" class="headerlink" title="Instance Norm"></a>Instance Norm</h1><p>Instance Norm 对每个样本的每个 channel 进行归一化，即在 <code>(H,W)</code> 上做归一化。</p>
<h1 id="Group-Norm"><a href="#Group-Norm" class="headerlink" title="Group Norm"></a>Group Norm</h1><p>与 Layer Norm 类似，不同的是 Group Norm 将 <code>(C,H,W)</code> 在 channel 上分组，假设分为 <code>G</code> 组，那么在 <code>(C/G, H, W)</code> 上做归一化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/03/05/obj_det/lightweight/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/05/obj_det/lightweight/" class="post-title-link" itemprop="url">lightweight</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-05 16:18:13" itemprop="dateCreated datePublished" datetime="2021-03-05T16:18:13+08:00">2021-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-06 14:38:12" itemprop="dateModified" datetime="2021-03-06T14:38:12+08:00">2021-03-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ThunderNet"><a href="#ThunderNet" class="headerlink" title="ThunderNet"></a>ThunderNet</h1><p>(two-stage detector)</p>
<p>移动设备上计算能力有限，而现在的很多 CV 实现方式都需要较强的计算力，这导致这些任务难以在移动设备上 real-time 的实现。本文研究了 two-stage 目标检测 real-time 的有效性，并提出了一个轻量级的 two-stage 检测器，名为 ThunderNet。</p>
<p>简介：</p>
<ol>
<li>研究了先前轻量级 backbone 的缺点，并提出了一个新的为目标检测而设计的轻量级 backbone  <code>SNet</code></li>
<li>沿用 Light-Head R-CNN 的 detection head 结构</li>
<li>进一步压缩 RPN 和 R-CNN 两个 subnet，以加快计算速度。 </li>
<li>small backbone 会带来一定的性能降级，所以设计两个高效率模块 <code>Context Enhancement Module</code> 和 <code>Spatial Attention Module</code>。CEM 结合多个 scale 的 feature （backbone 中浅层到深层的 feature）以利用 local 和 global 信息。SAM 利用 RPN 学习到的信息来微调 RoI warping 中的特征。</li>
<li>input resolution：<code>320x320</code>，小 size 可以加快网络的 inference 速度。</li>
</ol>
<h2 id="backbone"><a href="#backbone" class="headerlink" title="backbone"></a>backbone</h2><p><strong>Receptive Field:</strong></p>
<p>大感受野可以利用更多的上下文信息，同时能有效地 encode 像素间的 long-range 关系，这对目标尤其大目标的定位非常关键。</p>
<p><strong>early &amp; late stage feature:</strong></p>
<p>高层特征具有更强的语义性，更具有辨别性，低层特征具有更丰富的空间细节信息，所以高低层特征都需要用到。</p>
<p><strong>SNet</strong></p>
<p>SNet 作为专为 real-time 目标检测而设计的轻量级的 backbone。SNet 以 ShuffleNetV2 为基础进行改造，将所有的 <code>3x3</code> depthwise conv 改为 <code>5x5</code> depthwise conv，以获取更大的感受野，同时保持差不多的计算速度。还有其他的一些改动这里不一一指出。</p>
<p>depthwise conv: 每个通道独立进行二维卷积，需要 $c_{in}$ 个 $k \times k$ 卷积，得到的 feature 的 shape 与输入 feature shape 相同，然后再执行 $1 \times 1 \times c_{in}\times c_{out}$ 的跨通道卷积，输出 feature 的channel 为 $c_{out}$。 </p>
<h2 id="Detection-Part"><a href="#Detection-Part" class="headerlink" title="Detection Part"></a>Detection Part</h2><p>压缩 RPN 和 Detection Head。Light-Head R-CNN 的 detection head 虽然是轻量级，但是配合小的 backbone 时，依然太过 heavy，导致 backbone 与 dection head 之间产生 imbalance。</p>
<p>压缩 RPN：将原来的 256-d <code>3x3</code> conv 替换为 <code>5x5</code> 的 depthwise 和 256-d <code>1x1</code> conv。anchor 的配置为 scale：<code>{32, 64, 128, 256, 512}</code>，aspect ratio：<code>{1:2, 3:4, 1:1, 4:3, 2:1}</code>。</p>
<p>detection head： Light-head R-CNN 中的 thin feature map $\alpha \times p \times p$，其中 $p=7, \ \alpha=10$，由于 thundernet 中 backbone 和 input image size 均较小，所以继续降低 $\alpha=5$。采用 PSRoI，由于 PSRoI 输出的 feature 仅 245-d，那么 R-CNN subnet 中的 fc 全连接层为 1024-d。</p>
<h2 id="CEM"><a href="#CEM" class="headerlink" title="CEM"></a>CEM</h2><p>context enhancement module。</p>
<p>Light-Head R-CNN 使用 global convolutional network（GCN） 生成 thin feature map，GCN 具有 large kernel，使得 Receptive Field 增大，从而可以 encode 更多的上下文信息，但是 GCN 会给 SNet 带来很多计算量，thundernet 不使用 GCN，而是使用 CEM 解决这个问题。</p>
<p>借鉴 FPN 的思想（FPN 本身结构比较复杂），聚合multi-scale 的 局部信息和全局信息，得到具有较强判别性的 feature。CEM merge 来自以下 layer 的 feature：$C_4, \ C_5, \ C_{glb}$，其中 $C_{glb}$ 表示 global feature，通过对 $C_5$ 执行 global average pooling 得到。对以上三个 scale 的 feature 使用 <code>1x1-245</code> conv，输出 channel 均为 245，且 $C_5$ 的输出特征还需要 <code>2x</code> upsample，使得与 $C_4$ 的输出 feature 具有相同的 size，而 $C_{glb}$ 的输出本质是是一个标量，所以经 broadcast 具有与 $C_4$ 输出 feature 具有相同的 size，然后这三组相同 spatial size 的 feature 再合并。</p>
<h2 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h2><p>spatial attention module。</p>
<p>在 RoI warping 的输入 feature （上面说讨论的 thin feature maps）上，我们希望 负例 region 内的 feature 值足够小，正例 region 内的 feature 足够大，但是 thundernet 比正常的检测网络小，所以会难以学习到正确的 feature 分布，本文使用 SAM 解决这个问题。</p>
<p>SAM 利用 RPN 得到的信息来微调 RoI warping 的输入 feature 分布。RPN 被训练用来区分正负例，那么 RPN 的输出 feature 可以利用起来，于是，SAM 的两个输入：1. RPN 的输出 feature；2. CEM 输出的 thin feature maps。SAM 的输出 feature 为，<br>$$\mathcal F^{SAM}=\mathcal F^{CEM} \cdot sigmoid[\theta(\mathcal F^{RPN})]$$<br>其中 $\theta$ 用于维度转换，使得 $\mathcal F^{RPN}$ 和 $\mathcal F^{CEM}$ 具有相同的维度，文中使用 <code>1x1</code> conv 来执行这个维度转换。</p>
<p>SAM 的输出将作为原先 RoI warping 的输入。</p>
<p>thunernet 整个网络结构如图 1，</p>
<p><img src="/images/obj_det/lightweight_fig1.png" alt=""><center>图 1</center></p>
<h1 id="Light-Head-R-CNN"><a href="#Light-Head-R-CNN" class="headerlink" title="Light-Head R-CNN"></a>Light-Head R-CNN</h1><p>(two-stage detector)</p>
<p>设计了一个轻量级的 detection head，有如下两种设计：</p>
<ol>
<li>L：配合 large backbone，文中采用 ResNet101</li>
<li>S：配合 small backbone，文中采用 Xception</li>
</ol>
<p>backbone 最后一个 conv block 记为 $C_5$，$C_5$ 之后使用一个 separable conv（依次为 <code>kx1</code> 和 <code>1xk</code> 两个 conv），最终输出 channel 为 $10 \times p \times p$，而 R-FCN 中对应的 channel 为 $(C+1) \times p \times p$（$p \times p$ 表示 bin，因为是 positive-sensitive），所以相对 R-FCN，这里的设计更加 small。</p>
<p><strong>R-CNN subnet</strong></p>
<p>PSRoI pooling 之后，使用一个 2048-d 的全连接层，然后分两支，一支用于分类预测，一支用于box 回归预测，其中分类分支使用一个 C-d 的全连接，回归分支使用 4-d 的全连接层。</p>
<p><strong>RPN</strong></p>
<p>RPN 作用于 $C_4$ 之上，根据 anchor box 预测出一组 proposals，anchor 的 scale 为 <code>{32,64,128,256,512}</code>，aspect ratio 为 <code>{1:2,1:1,2:1}</code>。</p>
<p>整个网络的结构图如下，<br><img src="/images/obj_det/lightweight_fig2.png" alt=""><center>图 2 </center></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/02/25/obj_det/anchor_free/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/25/obj_det/anchor_free/" class="post-title-link" itemprop="url">Anchor-free Object Detection</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-25 12:31:28" itemprop="dateCreated datePublished" datetime="2021-02-25T12:31:28+08:00">2021-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-06 15:18:07" itemprop="dateModified" datetime="2021-03-06T15:18:07+08:00">2021-03-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FCOS"><a href="#FCOS" class="headerlink" title="FCOS"></a>FCOS</h1><p>每个 scale 的 detection head 输出的 feature maps 上的每一 location 处预测 <code>C</code> 个分类和 <code>4</code> 个坐标，以及一个 center 得分，对每种分类采用二值分类。某个 location 位于 gt box 内，则为正例样本，否则为负例样本，box 回归 target 记为 $\mathbf t^{<em>}=(l^{</em>}, t^{<em>}, r^{</em>}, b^{<em>})$，某一 location <code>(x,y)</code> 位于 gt box $B_i=(x_0^{(i)}, y_0^{(i)}, x_1^{(i)}, y_1^{(i)})$ 内部，那么有<br>$$l^{</em>}=x-x_0^{(i)}, \quad t^{<em>}=y-y_0^{(i)}$$<br>$$r^{</em>}=x_1^{(i)} - x, \quad b^{*}=y_1^{(i)} - y$$</p>
<p>损失为<br>$$\begin{aligned} L({\mathbf p_{x,y}}, {\mathbf t_{x,y}})&amp;=\frac 1 {N_{pos}} \sum_{x,y} L_{cls}(\mathbf p_{x,y}, c_{x,y}^{<em>}) \ &amp;+ \frac {\lambda} {N_{pos}} \sum_{x,y} \mathbb I(c_{x,y}^{</em>}&gt;0) \cdot L_{reg}(\mathbf t_{x,y}, t_{x,y}^{*})\end{aligned}$$</p>
<p>其中，$c_{x,y}^{<em>}$ 表示 location <code>(x,y)</code> 处所属分类，如果是负例，$c_{x,y}^{</em>}=0$，如果是正例，那么 $c_{x,y}^{*}$ 为fg 分类id。分类损失 $L_{cls}$ 使用 Focal Loss。坐标损失 $L_{reg}$ 使用 IOU Loss。</p>
<p>如果某个 location 位于多个 gt box 交叠的区域，那么这个 location 该回归哪个 gt box 呢？ 答案是使用 multi-level 预测，见如下。</p>
<h2 id="FPN-for-FCOS"><a href="#FPN-for-FCOS" class="headerlink" title="FPN for FCOS"></a>FPN for FCOS</h2><p>引入 FPN，使用 multi-level 的 feature maps，分别记为 ${P_3, P_4, P_5, P_6, P_7}$，其中 $P_3, P_4, P_5$ 由 backbone 中的 $C_3, C_4, C_5$ 经 <code>1x1</code> conv 输出得到。$P_6, p_7$ 则分别在 $P_5, P_6$ 上使用 stride=2 的 conv 得到，各 level feature 上的 stride 分别为 <code>8,16,32,64,128</code>。</p>
<p>在不同 scale 的 feature 上限制所预测的 box 的回归值范围，具体而言，对于 $P_i$，如果某 location 满足 $\max(l^{<em>},t^{</em>},r^{<em>},b^{</em>})&gt;m_i$ 或者 $\max(l^{<em>},t^{</em>},r^{<em>},b^{</em>}) &lt; m_{i-1}$，那么这个 location 为负例，不计入坐标回归损失 $L_{reg}$。本文中 $m_2=0, \ m_3=64, \ m_4=128, \ m_5=256, \ m_6=512, \ m_7=\infty$（这是借鉴了 anchor based 中的 anchor 的 base scale 为 8）。</p>
<p>这样，不同的 level 的 feature 负责预测不同 size 范围的目标。同一 location 如果有多个目标，通常，这些交叠的目标大小不在同一个范围，于是降低了 ambiguous location，如果仍然存在 location 属于多个大小差不多目标，那么人为的将此 location 用来预测 size/area 最小的那个目标。</p>
<p>与其他基于 FPN 的目标检测器一样，不同 level 的 检测 head 分支上参数共享。观察到不同 level<br>的 feature 回归不同范围的目标（例如 $P_3$ 回归范围为 $[0,64]$），那么不同 level 的检测 head 如果完全相同，会显得不合理，所以，比起 single scale FCOS 中使用的 $exp(x)$（因为回归 target 为正，所以需要使用 $exp(x)$ 处理一下），在 multi scale FCOS 中，改为 $exp(s_i x)$，这里的 $s_i$ 是需要训练学习的参数，以自动调整其大小。</p>
<h2 id="Center-ness-for-FCOS"><a href="#Center-ness-for-FCOS" class="headerlink" title="Center-ness for FCOS"></a>Center-ness for FCOS</h2><p>实验发现，有大量低质量的预测 box，这是有距目标中心较远的 location 预测出来的结果。如何抑制它们？</p>
<p>增加一个 single-layer 分支，与分类分支并列，如图 1，</p>
<p><img src="/images/obj_det/anchor_free_fig1.png" alt=""><center>图 1</center></p>
<p>新增分支用于预测 location 的中心度 “center-ness”：是目标中心的置信度，用 location 与所属目标中心的归一化距离来表示，记回归目标为 $\mathbf t^{<em>}=(l^{</em>},t^{<em>},r^{</em>},b^{<em>})$，center-ness 目标为<br>$$\text{centerness}^{</em>}=\sqrt{\frac {\min(l^<em>, r^</em>)} {\max(l^<em>,r^</em>)} \times \frac {\min(t^<em>, b^</em>)} {\max(t^<em>,b^</em>)}}$$<br>使用平方根是为了降低 center-ness 值的衰减速度，center-ness 值范围位于 $[0,1]$，使用 BCE loss 进行训练。</p>
<p>测试阶段，<strong>最终的得分计算为 center-ness 与分类得分 相乘</strong>，以最终得分进行预测 box 的 ranking，然后经 NMS，过滤掉那些低质量的预测结果。</p>
<p>另一种 center-ness 的替换方案是，仅仅使用 gt box 中心区域的 location 作为正例，代价是需要引入一个额外参数来指定中心区域的大小。当然，也可以两者结合使用。</p>
<h1 id="CornerNet"><a href="#CornerNet" class="headerlink" title="CornerNet"></a>CornerNet</h1><p>anchor based 目标检测的缺点：1. 需要大量的 anchor，导致正负例不均衡，训练速度慢。2. 需要很多超参数（例如，anchor 数量、大小以及 aspect ratio 等），在 multi-scale feature 情况下，超参数更多。</p>
<p>本文介绍了一个 anchor free 的目标检测方法，检测目标的左上和右下两个角点。为什么检测角点呢？</p>
<ol>
<li>box 中心难以定位，因为中心依赖于目标的 4 个边坐标，而定位一个角点仅需要两个边坐标，加上本文提出的另一个设计 <code>corner pooling</code>，利用角点的定义，例如左上角，<code>corner pooling</code> encoding 当前某 location 右侧的 feature vector，以及下方的 feature vector，这种 encoding 使得角点预测更加准确。</li>
<li>密集离散化 box 时，记 feature 的 size 为 <code>(w,h)</code>，那么所有可能的角点的数量为 O(wh)，而 anchor box 的可能性则非常大，根据排列组合原理， anchor 的宽有 w 种可能，高有 h 种可能，故 anchor 的 size 有 wh 种可能，然后分布在 feature 上时，每个 anchor 有 wh 种可能，故一共 $O(w^2h^2)$。当然如果考虑到 anchor 不要超出 feature map 之外，那么 anchor 的宽为 1 时，有 w 种可能，宽为 2 时，有 w-1 种可能，… 宽为 w 时，有 1 种可能，一共有 $w+(w-1)+\cdots +1$，同样地，高也一样，所以分布在 feature 上各种 anchor 的可能性一共有 $(1+2+\cdots+w)(1+2+\cdots+h)=\frac {w(w+1)h(h+1)} 4$。当然，anchor based 检测方法为了缩减 anchor 数量，在 feature 上每个 location 使用不同 scale 和 aspect ratio 的 anchor 共 K 个，故此时一共有 $Kwh$ 个。</li>
</ol>
<h2 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h2><p>base ConvNet 采用 hourglass network，后接两个模块，分别用于左上角点和右下角点。每个模块有独立的 corner pooling 模块（因为左上和右下角点的 corner pooling 的方向不同），hourglass network 的 feature 经过 pooling 之后，得到 heatmaps，embeddings 和 offsets。</p>
<p><strong>heatmap:</strong></p>
<p>两组 heatmaps，每组 heatmap 有 C channels，其中 C 为分类数量，heatmap 的大小为 $H \times W$，heatmap 表示某个 location 是角点且属于某个分类的得分，可见 heatmap 是 binary mask。</p>
<p>对某个 corner 而言，只有一个 location 对应到它，这个 location 作为正例，其他 location 相对这个 corner 而言均为负例，这里不对所有负例等值惩罚，而是对这个 corner 一定半径范围的负例 location 降低惩罚，这是考虑到，即使是负例 location，如果很靠近对应的 corner，这些负例构成的预测 box 依然可以很好的覆盖 gt box。半径大小由对应的 gt box 确定，根据 IOU 的阈值下限 t（文中 t 设为 0.3）。如何降低惩罚？</p>
<p>使用一个二维高斯函数，随着距离增大平滑的递减，<br>$$f_{cij}=\begin{cases} e^{-\frac {x^2+y^2}{2 \sigma^2}} &amp; x^2+y^2 \le r^2 \ 0 &amp; \text{otherwise} \end{cases}$$<br>其中，下标 <code>(i,j)</code> 表示 location （样本）的坐标，$x, y$ 表示 location 据对应 corner 的横纵坐标差，$c$ 表示 gt 的分类。$\sigma=r/3$ 用于控制衰减速度。$r$ 为半径。</p>
<p>heatmap 表示 location 是 corner 且属于某一分类的得分，采用 focal loss，考虑以上二维高斯函数作为惩罚因子，<br>$$L_{det}=-\frac 1 N \sum_{c=1}^C\sum_{i=1}^H \sum_{j=1}^W \begin{cases} (1-p_{cij})^{\alpha} \log p_{cij} &amp; y_{cij}=1 \ (1-f_{cij})^{\beta}p_{cij}^{\alpha} \log (1-p_{cij}) &amp; o.w. \end{cases}$$<br>其中，$p_{cij}$ 表示 heatmap 上某 location 预测值。$y_{cij}$ 表示 heatmap 上某处的 gt target 值。N 表示一个 image 上 object 的数量。$\alpha=2, \ \beta=4$ 为超参数，控制各项损失贡献。从上式可见，仅对 corner 一定半径范围内的 negative location 降低了惩罚。</p>
<p><strong>offset:</strong></p>
<p>由于下采样，hourglass 的 feature size 较原 image size 小，记下采样率为 n，那么 gt corner $(x,y)$ 到 heatmap 上的位置为 $(\lfloor x/n, y/n \rfloor)$，再映射回 image 上是，坐标精度有所损失，损失范围为 $[0,n)$，当目标size 较小时，影响 IOU，所以增加一个坐标偏差的预测，gt offset 为<br>$$\mathbf o_k=\left(\frac {x_k} n - \lfloor \frac {x_k} n \rfloor, \frac {y_k} n - \lfloor \frac {y_k} n \rfloor \right)$$<br>其中 $k$ 表示第 k 个 gt corner，预测的 offset 记为 $\hat \mathbf o_k$，使用 smooth L1 损失。</p>
<p><strong>embedding:</strong></p>
<p>左上 corner 和右下 corner 是分开预测的，如何确定哪个左上和哪个右下是一对呢（来自同一个 gt box）？</p>
<p>为每个 corner 生成 embedding vector，如果某一对 corner 来自同一个 gt box，那么它们的 embedding 应该相似，例如 vector 的 L1 范数足够小。</p>
<p>由于 embedding 没有 target 值，作者使用 <code>pull</code> 和 <code>push</code> 两种损失来学习，记 $e_{tk}$ 为第 k 个目标左上 corner 的 embedding，$e_{bk}$ 为第 k 个目标右下 corner 的 embedding，那么损失为<br>$$L_{pull}=\frac 1 N \sum_{k=1}^N [(e_{tk}-e_k)^2+(e_{bk}-e_k)^2]$$<br>$$L_{push}=\frac 1 {N(N-1)} \sum_{k=1}^N \sum_{j=1, j\ne k}^N \max (0, \Delta-|e_k-e_j|)$$<br>$$e_k=\frac {e_{tk}+e_{bk}} 2$$<br>其中，N 为 image 中目标数量，$\Delta=1$ 表示两个来自不同目标的 corner 的 embeding 的最大区分度。</p>
<p>测试阶段，分别得到 K 个 top-left 角点和 K 个 bottom-right 角点，一共 $K^2$ 个 pair 的可能组合，计算每个 pair 的 embedding 的 L1 范数，如果超过一个阈值（设为 0.5），那么这个 pair 不成立，当然还有其他筛选条件，例如来自 heatmap 的得分筛选等，然后使用 soft nms，去除冗余检测结果。</p>
<h2 id="Corner-Pooling"><a href="#Corner-Pooling" class="headerlink" title="Corner Pooling"></a>Corner Pooling</h2><p>这个模块比较关键，从 hourglass 的输出特征到上面说的三个 feature <code>heatmap, offset, embedding</code>，中间经过了 Corner Pooling 模块。</p>
<p>hourglass 输出为 $f_t, f_l, f_b, f_r$ 分别表示 上左下右 四个 side，其中 $f_t, f_l$ 经过左上角点预测分支，$f_b, f_r$ 经过右下角点预测分支。以左上角点预测分支为例，记 corner pooling 的输入 feature size 为 $H \times W$，某一 location <code>(i,j)</code> 在 $f_t$ 上，经 corner pooling 后，从 <code>(i,j)</code> 到 <code>(H,j)</code> 之间的特征向量（从这个 location 开始垂直向下看）执行 max 操作得到输出值 $t_{ij}$，同理，从这个 location 向右看的特征向量经过 max 操作得到输出值 $l_{ij}$，<br>$$t_{ij}=\begin{cases} \max[f_t(i,j), t_{(i+1)j}] &amp; i &lt; H \ f_t(H,j) &amp; i=H \end{cases}$$<br>$$l_{ij}=\begin{cases} \max[f_l(i,j), l_{i(j+1)}] &amp; i &lt; H \ f_l(i,W) &amp; i=H \end{cases}$$<br>对于 $f_t$，从下到上递归执行，对于 $f_l$，从右到左递归执行。</p>
<p>预测模块的网络结构如图 2，<br><img src="/images/obj_det/anchor_free_fig2.png" alt=""><center>图 2. backbone 后接一个修改过的 residule module，下方是 shortcut 分支，上方是 2x conv，分别表示 left-most 和 top most，然后分别经 corner pooling 后，再 element-wise add，然后经 conv ，再与 shortcut 分支进行 merge（element-wise add)，然后经过右边的网络</center></p>
<h2 id="Hourglass-Network"><a href="#Hourglass-Network" class="headerlink" title="Hourglass Network"></a>Hourglass Network</h2><p>之前的 backbone 都是 VGG，ResNet 比较常见，也有用 densenet 的，但是 hourglass 网络还没见过，所以这里简单介绍一下。</p>
<p>Hourglass network 是由一个或多个 hourglass 模块组成的全卷积网络。Hourglass 模块先将 input feature 下采样，然后在上采样到原来的 resolution，由于下采样中的 maxpooling 损失了一些细节信息，所以使用 skip layer 将信息带到上采样的 feature 中。堆叠多个 hourglass 模块可捕获更高 level 的信息（这些信息的语义性更强）。</p>
<p>本文中，下采样使用 stride=2 的 conv 代替 maxpooling。</p>
<p>总损失为<br>$$L=L_{det}+\alpha L_{pull} + \beta L_{push} + \gamma L_{off}$$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/02/23/obj_det/one_stage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/23/obj_det/one_stage/" class="post-title-link" itemprop="url">One-stage Object Detection</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-23 10:36:44" itemprop="dateCreated datePublished" datetime="2021-02-23T10:36:44+08:00">2021-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-26 15:41:20" itemprop="dateModified" datetime="2021-02-26T15:41:20+08:00">2021-02-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="YOLOv1"><a href="#YOLOv1" class="headerlink" title="YOLOv1"></a>YOLOv1</h1><ol>
<li><p>one-stage detector</p>
</li>
<li><p>unified detection：image 经过网络得到 <code>SxS</code> 大小的 feature map，相当于把 image 划分为 <code>SxS</code> 的 grid，如果其中目标中心落于某个 grid cell，那么这个 grid cell 负责预测这个目标，网络最终的输出为 <code>S*S*(C+B*5)</code>，其中 C 表示分类数量，最多 B 个目标中心落于同一个 grid cell，每个 box 有 4 个坐标和 1 个 conf，这个 conf 表示预测 box 包含目标的置信度，也可以认为是预测 box 与 gt box 的 IOU。C 个预测值表示在此处有目标时的条件概率值，<code>Pr(Classi|Object)</code>，这里分类条件概率与 box 数量 <code>B</code> 无关。测试阶段，分类类型相关的 conf 值则为<br> $$Pr(Class_i|Object) * P(conf)$$</p>
</li>
<li><p>没有 SSD 中的 default box，也没有 Faster R-CNN 中的 anchor/proposal，YOLO 直接在 feature map 上每个点预测 box 坐标和分类概率，所以还需要一个 conf，表示预测 box 包含目标的置信度</p>
</li>
<li><p>文中input image size 为 <code>448x448</code>，经过6次下采样，得到<code>7x7</code>的feature，通过一个 fully connection（输出unit数量 <code>1470=7*7*30</code>），得到feature 上所有 box 的预测坐标、conf 以及分类得分</p>
</li>
<li><p>在 feature map 上使用 fully connection生成每个 grid cell 的预测数据，其中 (x,y) 表示预测目标中心坐标，这是归一化的，且表示<b>距所在 cell 的左端和上端的距离</b>。</p>
</li>
</ol>
<h1 id="YOLOv2"><a href="#YOLOv2" class="headerlink" title="YOLOv2"></a>YOLOv2</h1><p>YOLOv1 虽然是 fast 的，但是比起 SOTA 检测系统，缺点在于定位错误较明显，相较于 region proposal-based 的检测方法，YOLOv1 的 recall 低。YOLOv2 中对其进行改善，使用了：</p>
<ol>
<li><p>Batch Normalization。</p>
</li>
<li><p>High Resolution<br> <br> YOLOv1 中baseline 分类预训练时 image size 为 <code>224x224</code>，然后迁移到检测数据集上训练时，image size 为 <code>448x448</code>，这种输入大小的突变对目标检测不友好，所以训练过程中一直调整输入大小，使得网络适应以增加稳定性，具体策略为：每隔 10 个训练 batch，调整输入大小为</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int dim &#x3D; (rand() % 10 + 10) * 32</span><br></pre></td></tr></table></figure>
<p> 保证输入大小是 32 的整数倍，YOLOv2 中有 5 次下采样，这是匹配的。YOLOv1 有 6 次下采样，这里去掉一次下采样，为了使feature 具有 higher resolution，而这又是为了配合下面的 anchor box，在feature 上每个 position 使用一组 anchor box 来预测，可以降低定位误差。</p>
</li>
<li><p>Convolution with Anchor Boxes<br> <br> 参考 Faster R-CNN 中的 RPN，使用 anchor box。feature 上每个 position 使用大小形状不同的 k 个 anchor 进行预测，k 的取值以及各 anchor 的大小形状，根据数据集中gt box 聚类（k-means）计算得到，聚类使用的距离采用 IOU，</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d(anchor, cluster-center)&#x3D;1-IOU(anchor, cluster-center)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Direct location prediction<br> <br> 基于 region proposal 的位置预测过程为：记位置预测值 $(t_x, t_y)$ 为相对offset，根据anchor box坐标，计算最终预测box 中心坐标为<br> $$x=t_x \cdot w_a+x_a, \quad y=t_y \cdot h_a + y_a$$<br> 在训练开始阶段，由于是随机初始化模型参数，上式会导致预测 box 位置与 anchor 偏差很大，这会使得训练要花很长一段时间才能使得 box 的预测位置稳定下来（<b>注意：不使用上式</b>）。YOLOv2 沿用 YOLOv1 中预测中心坐标与所在 cell 的左边线和上边线的距离，这样偏差就不会很大，设cell <code>(i,j)</code> 处的某个 anchor 对应的坐标预测值记为 $t_x, t_y, t_w, t_h$，feature 大小为 $(w_f, h_f)$，anchor 基于 feature 的宽高为 $(w_a,h_a)$，那么计算预测 box 的实际归一化坐标为<br> $$x=(i+t_x)/w_f$$<br> $$y=(j+t_y)/h_f$$<br> $$w=\exp(t_w) \cdot w_a/w_f$$<br> $$h=\exp(t_h) \cdot h_a/h_f$$</p>
</li>
</ol>
<p>每个 box 均有 5 个坐标预测值（包括 4 个坐标偏差和 1 个是否包含目标的 conf）和 C 个分类得分预测值，最终输出大小则为 $k \cdot s \cdot s \cdot (5+C)$，其中 k 为 anchor 数量。</p>
<h1 id="YOLOv3"><a href="#YOLOv3" class="headerlink" title="YOLOv3"></a>YOLOv3</h1><p>主要是借鉴别的好的 idea 整合到 YOLO 里面来。</p>
<ol>
<li><p>沿用 YOLOv2 中 anchor box，使用聚类得到 k 个 anchor，每个 anchor 预测 4 个坐标 offset，1 个 objectness conf，以及 C 个分类概率。坐标 offset 的计算与 YOLOv2 中相同</p>
</li>
<li><p>与 gt box 有最大 IOU 的 anchor 的 conf target 值为 1，而其他非最佳 IOU 但是 IOU 大于某个阈值（0.5）的 anchor 则被忽略。IOU 低于 0.5 的则为负例 anchor，负例 anchor 只需要计算 conf 损失，不需要计算坐标 offset 损失和分类损失。</p>
</li>
<li><p>YOLOv3 在三个 scale 的 feature 上进行预测，YOLOv1 和 YOLOv2 均只有单个 scale 的 feature。这是为了借鉴 FPN 的思想。由于有了 multi-scale 的 features，每个 feature 上的每个 position 处只预测 3 个 anchor boxes，假设某个 feature size 为 <code>NxN</code>，那么预测 tensor 为 <code>NxNx[3*(4+1+C)]</code>，其中 C 为 foreground 分类数量。</p>
</li>
<li><p>Baseline 结构如 darknet-53 所示，用于抽取 feature，在 ImageNet 上预训练。目标检测网络结构如 yolov3.cfg 配置文件中所示。借鉴了 ResNet 中 shortcut 技巧（主要也是因为网络更 deep 了）。聚类得到 9 个 anchor size，然后按大小排序，每 3 个一组作为对应 scale feature 上所用的 anchor。</p>
</li>
</ol>
<h1 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h1><ol>
<li>baseline: VGG 等</li>
<li>one-stage detector。与 Faster R-CNN 相比，省去了 proposals 生成过程，而是在 feature map 上每个 position 有一组 prior box（k 个），然后 feature maps 上使用具有 <code>(c+4)k</code> filters 的 conv，而非 fully connection，进行预测输出，每个position 输出 <code>(c+4)k</code> 个值，表示预 c 个分类得分，和此处 box 的坐标 offsets。同时，使用 multi scale 的 feature maps，以覆盖多个不同大小级别的目标预测。</li>
<li>论文中针对 300x300 的输入图像，一共使用了 6 个不同 scale 的 feature，每个 feature 上的各点生成 prior box 的数量为 <code>4,6,6,6,4,4</code>，因为认为数据集中，中间 scale 的目标数量要多一些。各 feature 的边长为 <code>38, 19, 10, 5, 3, 1</code>，单个 image 上所有 prior box 数量为 <code>(38*38+3*3+1*1)*4+(19*19+10*10+5*5)+6=8732</code></li>
<li>由于使用 multi scale feature maps，所以不同 level 的 feature 负责不同大小的目标检测，假设共 m 个不同 scale 的 feature（文中 m=6），那么每个 level 的 feature 上的 default box 的基础边长为<br> $$s_k=s_{min}+\frac {s_{max}-s_{min}}{m-1}(k-1), \ k \in [1,m]$$<br> 其中最小最大边长为 <code>[min, max]=[0.2, 0.9]</code>，所有不同 scale 的边长 s 均匀散落在这个区间上</li>
<li>一个image上的 default box 数量非常多（第3点中指出高达 8732个），其中匹配的 default box是指与 gt 有最大 IOU 或者 IOU &gt; 0.5 的那些，称为正例，其余的为负例，显然负例会特别多，导致数据 unbalanced，所以将负例按 conf 预测损失倒序排列，选择 top N 的负例，这里 N 取正例数量的 3 倍，每个 level 的 feature 独立进行这种 hard negative mining</li>
</ol>
<h1 id="DSSD"><a href="#DSSD" class="headerlink" title="DSSD"></a>DSSD</h1><p>在 SSD 的基础上增加 deconvolution layer，具体是对 SSD 中用于预测所有 level 的 feautre，自顶向下，最顶 level 的 feature 上使用一个 prediction module 进行预测，然后这个 feature 经过 deconvolution，再与 SSD 中 resolution 更大一级的 feature 进行融合，然后使用 prediction module 进行预测，上一个融合后的 feature 再经 deconvolution，与 SSD 中 resolution 更大一级的 feature 进行融合，递归进行这个过程，直到原 SSD 中所有 level 的 feature 均进行了融合和预测，整个网络形成一个 hour-glass 结构，也就是 “encoder-decoder”。这与 FPN 其实很类似，只是这个 top-down 模块中的 upsample 换成了 deconvolution。</p>
<h1 id="RetinaNet-Focal-Loss"><a href="#RetinaNet-Focal-Loss" class="headerlink" title="RetinaNet(Focal Loss)"></a>RetinaNet(Focal Loss)</h1><h2 id="Loss"><a href="#Loss" class="headerlink" title="Loss"></a>Loss</h2><p>one-stage 速度更快，结构更简单，但是比起 two-stage，准确率还差的不少，其中一个原因是 one-stage 使用了密集 location 采样，这就导致 fg-bg 分类不均衡，本文使用 Focal Loss，通过附加低权重，降低已经分类好的样本的对 loss 的贡献，从而 focus on hard examples。</p>
<blockquote>
<p>他方法如 OHEM 等也可以解决 one-stage 中的分类不平衡问题</p>
</blockquote>
<h3 id="Balanced-Cross-Entropy"><a href="#Balanced-Cross-Entropy" class="headerlink" title="Balanced Cross Entropy"></a>Balanced Cross Entropy</h3><p>$$CE(p,y)=\begin{cases} - \alpha \log p &amp; y=1 \ -(1-\alpha) \log(1-p) &amp; y=0\end{cases}$$<br>其中 $\alpha \in [0, 1]$，其值可取类频数的倒数，例如数据集大小 N，fg 数量为 $N_1$，bg 数量为 $N_0$（$N=N_1+N_0$），那么<br>$\alpha=\frac {N_0} N$，表示增大正例的损失贡献。</p>
<h3 id="Focal-Loss"><a href="#Focal-Loss" class="headerlink" title="Focal Loss"></a>Focal Loss</h3><p>$$FL(p,y)=\begin{cases} - （1-p)^{\gamma} \log p &amp; y=1 \ -p^{\gamma} \log(1-p) &amp; y=0\end{cases}$$<br>其中 $\gamma&gt;0$。</p>
<p>记<br>$$p_t=\begin{cases} p &amp; y=1 \ 1-p &amp; y=0\end{cases}$$<br>$$\alpha_t=\begin{cases} \alpha &amp; y=1 \ 1-\alpha &amp; y=0\end{cases}$$</p>
<p>于是 $\alpha$ balanced CE 损失为<br>$$CE(p_t)=-\alpha_t \log(p_t)$$</p>
<p>Base Focal Loss 为<br>$$FL(p_t)=-(1-p_t)^{\gamma} \log (p_t)$$</p>
<p>$\alpha$ balanced Focal Loss 为<br>$$FL(p_t)=-\alpha_t (1-p_t)^{\gamma} \log (p_t)$$</p>
<h2 id="RetinaNet"><a href="#RetinaNet" class="headerlink" title="RetinaNet"></a>RetinaNet</h2><p>为了验证 Focal Loss 的有效性，设计了这个 RetinaNet。Focal Loss 用在 Classification Subnet 中。</p>
<p><strong>backbone:</strong> FPN on ResNet。使用 $P_3 \sim P_7$ level 的 feature，其中 $P_3 \sim P_5$ 由 ResNet 的 $C_3 \sim C_5$ 获得，然后再使用一个 $3 \times 3$-s2 的 conv（无 ReLU） 得到 $P_6$，最后使用 ReLU + $3 \times 3$-s2 conv 得到 $P_7$。$P_l$ feature 的 stride 是 $2^l$，每个 feature 均为 C=256 channels。feature 上 anchor 的 base size 为 $2^{l+2}$，每个 position 有 9 个 anchors，aspect ratio 由配置给出，每个 anchor 均有 K 个分类得分（包含了背景），4 个位置坐标。</p>
<p>$IOU \ge 0.5$ 的为 正 anchor，$IOU &lt; 0.4$ 的为负 anchor，$0.4 \le IOU &lt; 0.5$ 的 anchor 忽略，不参加训练。正 anchor 与 对应的 gt box 之间计算 offset，作为 box regression target，classification target 则为 one-hot vector，向量中 anchor 所对应的目标分类的 entry 为 1， 其余 entry 为 0。</p>
<p>backbone 后接两个 subnetworks：用于分类和 box 回归（每个 level 的 feature 上均如此）。</p>
<p><strong>Classification Subnet:</strong> 这是一个 FCN 子网络，参数在所有 pyramid level 之间共享。在 pyramid feature 上，使用 4 个 <code>3x3</code> conv，每个 conv 均有 C=256 个 filters，且每个 conv 后跟一个 ReLU，然后是一个 <code>3x3</code> 的 conv，有 <code>KA</code> 个 filters，其中 K 为分类数量，A 为 anchor 数量。这个子网络比 RPN 有更 deep 的结构，文中发现，这种设计比某些超参数的选择还要重要。</p>
<p><strong>Box Regression Subnet:</strong> 与 Classification Subnet 结构类似，只是最后一个 conv 的 filters 数量为 <code>4A</code>。</p>
<p>这两个 subnet 的结构就像天线一样位于 FPN 之上，故称 RetinaNet。</p>
<p>以前使用 heuristic sampling（RPN）或 hard example mining(OHEM, SSD) 来选择 mini-batch（数量为 256）的 anchors，但是这里使用 Focal Loss，单个 image 上的 anchor 数量达到 ~100k（正例 anchor 与 负例 anchor 之和），总的 focal loss 则是这所有 anchor 上 Focal Loss 之和，并除以正例 anchor 数量。</p>
<h1 id="STDN"><a href="#STDN" class="headerlink" title="STDN"></a>STDN</h1><p>Scale-Transferrable Detection Network，为了解决目标 scale 多样性的问题。</p>
<p>主流的目标检测方法中， Faster RCNN 中只有单一 scale 的 feature，其 receptive field 是固定的，而目标的 scale 和 aspect ratio 则是各不相同的，所以存在不一致问题。 SSD 在不同 depth 的 layer 的 feature 上预测，anchor 的 scale 与 feature 的 scale 有关，这一定程度上解决了目标 scale 多样性的问题，但是在小目标上表现并不好，因为 low feature 用于预测小目标，而 low feature 的语义性较弱，于是使用 FPN，通过径向连接和 top-down 模块，将高层 feature 与低层 feature 融合，使得低层特征在保持更多细节信息的同时，兼具语义特征，FPN 缺点在于需要谨慎地构建 feature pyramids，并且 FPN 网络结构带来了一定的计算负担（FPN 是在 Faster RCNN 基础上将 baseline 增加 FPN 结构，所以是一个 two-stage 检测器）。</p>
<p>STDN 以 DenseNet 为 baseline，利用了 DenseNet 中高低层 feature concatenation 的特性，使得 feature 具有更强的表征能力。在 DenseNet 最后一个 DenseBlock 的最后一个 Layer 之上， 使用Scale-Transfer Module（STM），获得 multi scale features，用于预测，STM 没有参数，不会引入很多计算负担。</p>
<ol>
<li><p>使用 DenseNet-169 为 baseline (growth rate=32)</p>
</li>
<li><p>将 stem block 改为 3 个 <code>3x3</code> 的 conv 和一个 <code>2x2</code> 的 mean-pooling，其中第一个 <code>3x3</code> conv 的 stride=2。原来 DenseNet 中采用 <code>7x7-s2</code> 和 <code>3x3-s2</code> 的 conv，我们认为大卷积核和连续的下采样对检测小目标的准确性不利。</p>
</li>
<li><p>当 input size 为 <code>300x300</code>，DenseNet 的 输出 feature size 为 <code>9x9</code>。</p>
</li>
<li><p>网络结构为 stem –&gt; DB1 –&gt; T1 –&gt; DB2 –&gt; T2 –&gt; DB3 –&gt; T3 –&gt; DB4 =&gt; STM，其中 DB 表示 DenseBlock，T 表示 Transition Layer。T3 输出为 <code>640x9x9</code>，STM 包含 6 个 scale 的 features，如下表所示</p>
<table>
<thead>
<tr>
<th>output size</th>
<th>layer</th>
</tr>
</thead>
<tbody><tr>
<td>800x1x1</td>
<td>9x9 mean-pool, stride 9 (Input DB4_concat5)</td>
</tr>
<tr>
<td>960x3x3</td>
<td>3x3 mean-pool, stride 3 (Input DB4_concat10)</td>
</tr>
<tr>
<td>1120x5x5</td>
<td>2x2 mean-pool, stride 2 (Input DB4_concat15)</td>
</tr>
<tr>
<td>1280x9x9</td>
<td>Identity layer (Input DB4_concat20)</td>
</tr>
<tr>
<td>360x18x18</td>
<td>2x scale-transfer layer (Input DB4_concat25)</td>
</tr>
<tr>
<td>104x36x36</td>
<td>4x scale-transfer layer (Input DB4_concat32)</td>
</tr>
</tbody></table>
<p> 已知 DenseBlock 中第 $l$ 个 layer 的 output channen 为 $k_0+l*32$，那么上表中第一个 layer 为 <code>9x9</code> 的均值池化层，输出为最小 scale 的 feature，输出 size 为 <code>800x1x1</code>，这个 layer 的输入为 DB4 中第 5 个 layer 的 output，根据公式其输出 channel 为 $640+5\times 32=800$。其他 layer 的输入也是 DB4 中某个 layer 的输出。</p>
<ul>
<li>Identity layer 表示输出就是输入本身</li>
<li>scale-transfer layer 表示将输入的 channel 压缩 $r^2$ 倍（$r \times$ scale-transfer layer），而 $W, H$ 则均增大 $r$ 倍，rearrange 公式为，<br>  $$I_{x,y,c}^{SR}=I_{\lfloor x/r \rfloor,\lfloor y/r \rfloor, r\cdot mod(y,r)+mod(x,r)+c\cdot r^2}^{LR}$$</li>
</ul>
</li>
<li><p>每个 scale 的 feature 分别根据 dense anchor 进行预测，anchor 与 gt box 匹配标准为：有最大 IOU 或者 IOU &gt; 0.5，其余 anchor 为负例，根据 hard negative mining 使得正负例数量比为 <code>1:3</code>。</p>
</li>
<li><p>抽取的 feature 分两路，分别到分类分支和 box 回归分支。分类分支由一个 <code>1x1</code> conv 和两个 <code>3x3</code> conv 组成，每个 conv 后接 BN+ReLU，最后一个 conv 的 channel 为 <code>KA</code>，其中 K 为分类数量（fg 数量 + 一个 bg），A 为每个 position 预测的 anchor 数量。回归分支的结构与分类分支相同，只是最后一个 conv 的 channel 为 <code>4A</code>。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/02/20/obj_det/two_stage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/20/obj_det/two_stage/" class="post-title-link" itemprop="url">Two-stage Object Detection</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-20 14:50:40" itemprop="dateCreated datePublished" datetime="2021-02-20T14:50:40+08:00">2021-02-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-05 19:00:19" itemprop="dateModified" datetime="2021-03-05T19:00:19+08:00">2021-03-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a>Faster R-CNN</h1><ol>
<li>baseline: VGG, resnet</li>
<li>RPN: 生成 proposals</li>
<li>ROIPooling: RPN 生成的 proposals 在 conv5_3 上对应的 feature region 被 Pooling 成固定的 <code>7x7</code> 大小，然后在经 FC layer</li>
<li>detection head: 与 Fast R-CNN 中一样，两个分支，分别预测分类和坐标</li>
<li>从一个图中取 top 256 个 proposals 作为 mini-batch，送入 detection subnetwork</li>
<li>多个 scale 和 aspect ratio 组合，以应对不同尺寸和形状的目标检测</li>
</ol>
<h1 id="FPN"><a href="#FPN" class="headerlink" title="FPN"></a>FPN</h1><ol start="0">
<li>在 Faster R-CNN 基础上，将 baseline 由 ResNet/VGG 换成 FPN（multi-scale + top-down feature fused)</li>
<li>in-network feature pyramids，每个 level 的 feature 独立做检测</li>
<li>low-level feature 有利于小目标检测，但是单纯的 low-level feature 还不够，因为其特征表达能力不够强，所以使用 top-down 和 径向连接，合并了 high-level feature。这对检测多种 scale 的目标非常有用。</li>
<li>backbone 选用 resnet，利用 FPN 生成 feature pyramids，而原来 faster rcnn 中为 single feature，故给每个 level 的 feature 配备 RPN 和 rcnn head 分支，这些分支在所有 level feature 上共享参数。resnet 有 conv2，conv3，conv4，conv5，这里在 conv5 之上增加一个 1x1 conv（有 subsampling），专门用于检测大目标，这样共 5 个 level。</li>
<li>feature level 为 P2，P3，P4，P5，P6，每个 level 上的 anchor 使用一个 scale <code>8</code>，由于stride 分别为 4，8，16，32，64，故 anchor 在 input image 上实际 size 为 32，64，128，256，512，分别作为每个 level 上的 base anchor，每个 anchor 的 aspect ratio 为 <code>[0.5, 1, 2]</code>。</li>
<li>RPN 生成的 proposals，根据不同的尺寸，使用不同的 level 分支来负责检测，分支 <code>Pk</code> 的下标确定方法为<br> $$k=\lfloor 4 + \log_2(\sqrt {wh} / 224) \rfloor$$</li>
</ol>
<h1 id="Deformable-ConvNet"><a href="#Deformable-ConvNet" class="headerlink" title="Deformable ConvNet"></a>Deformable ConvNet</h1><p>可变形卷积网络提出两个模块。</p>
<h2 id="Deformable-Conv"><a href="#Deformable-Conv" class="headerlink" title="Deformable Conv"></a>Deformable Conv</h2><p>为卷积操作的 feature grid 中每一个 position 增加 2-d offset（横纵坐标偏差）。记输出 feature map 上某一点位置 $p_0$，输入 feature 上的 grid sampling 根据感受野<br>$$\mathcal R={(-1,-1),(-1,0),…,(0,1),(1,1)}$$<br>确定，那么这一点的常规卷积输出为<br>$$y(p_0)=\sum_{p_n \in \mathcal R} w(p_n) \cdot x(p_0+p_n)$$</p>
<p>输入 feature grid 每一点 $p_n$ 增加一个坐标偏差 $\Delta p_n$，于是可变形卷积为<br>$$y(p_0)=\sum_{p_n \in \mathcal R} w(p_n) \cdot x(p_0+p_n+\Delta p_n)$$</p>
<p>在这个输入 feature 上使用一个 conv，得到 resolution 相同，但是 channal 为 2N 的输出，表示没一点的 offset，显然 offset 不是整数。</p>
<p>记 $p=p_0+p_n+\Delta p_n$，使用双线性插值计算 $p$ 点的像素值，<br>$$x(p)=\sum_{q} G(q,p) \cdot x(p)$$<br>其中 $q$ 是输入 feature 上任意一点，$G(q,p)$ 表示关联权重，<br>$$G(q,p)=g(q_x, p_x) \cdot g(q_y, p_y)$$<br>$$g(a,b)=\max(0, 1-|a-b|)$$<br>显然最多只用到 p 周围最近的 4 个点来做双线性插值。也就是说，p和 q 的坐标相差不超过 1，但是注意，$\Delta p_n$ 表示的坐标偏差可能会超过 1。</p>
<p>得到 offset 后，再在原来的 input feature 上进行变形卷积，得到 output feature map。</p>
<h2 id="Deformable-ROI-Pooling"><a href="#Deformable-ROI-Pooling" class="headerlink" title="Deformable ROI Pooling"></a>Deformable ROI Pooling</h2><p>Region proposal-based 目标检测均采样 ROI Pooling 将输入特征 池化到一个固定大小的 feature（例如 7x7）。先来看常规 ROI Pooling 操作，记 ROI Pooling 将 <code>wxh</code> 大小的输入特征池化为一个 <code>kxk</code> 的特征，输入特征的左上角记为 <code>p_0</code>，那么 output feature map 上一点 <code>(i,j)</code> 的值为<br>$$y(i,j)=\sum_{p \in bin(i,j)} x(p_0+p)/n_{ij}$$<br>其中 $n_{ij}=|bin(i,j)|$，$bin(i,j)$ 表示输出上一点 <code>(i,j)</code> 对应到输入平面上一个 bin 中的各点（相对于左上角）的位置，这个 bin 由下式确定，<br>$$\lfloor i \cdot w /k \rfloor \le p_x &lt; \lceil (i+1) \cdot w / k \rceil$$<br>$$\lfloor j \cdot h /k \rfloor \le p_y &lt; \lceil (j+1) \cdot h / k \rceil$$</p>
<p>现在同样地，我们需要为这个 bin 生成坐标偏差，每一个 bin 对应一个 2-d offset，记 $bin(i,j)$ 的 2-d offset 为 $\Delta p_{ij}$，得到变形 ROI Pooling 为<br>$$y(i,j)=\sum_{p \in bin(i,j)} x(p_0+p+\Delta p_{ij}) / n_{ij}$$</p>
<p>如何得到这个 bin 的坐标偏差呢?</p>
<p>在 input feature 上使用 ROI Pooling 得到池化后的 feature，然后再经过一个 fc（全连接层）生成归一化后的 offset，记为 $\Delta \hat p_{ij}$，再 element-wise 乘上 ROI 的 w 和 h，得到 bin 的坐标偏差 offset<br>$$\Delta p_{ij}=\gamma \cdot \Delta \hat p_{ij} \ \circ \ (w,h)$$<br>其中 $\gamma$ 是一个预定义标量值，用于调节 offset 的幅度。文中取 $\gamma=0.1$。</p>
<p><b>offset 的归一化是必须的，这样使得 offset 的学习不受 ROI size 的影响。</b></p>
<h3 id="Position-Sentive-PS-ROI-Pooling"><a href="#Position-Sentive-PS-ROI-Pooling" class="headerlink" title="Position-Sentive(PS) ROI Pooling"></a>Position-Sentive(PS) ROI Pooling</h3><p>这里的 Position-Sentive 是指与 bin 的位置 <code>(i,j)</code> 有关。分类 subnet 和 box 回归 subnet 情况不同。</p>
<ol>
<li>分类分支。input feature 经过 conv 后得到 channel 为 $k^2(C+1)$，其中 k 为 池化后特征平面边长，C 为分类 fg 数量，每个分类每个 bin 有自己独立的 feature，池化时，使用这个独立的 feature，而上面的池化过程，对每个 bin 均采用同一个 feature（即 input feature）。</li>
<li>box 回归分支。同分类分支类似，input feature 经过 conv 得到 channel 为 $2k^2(C+1)$ 的 feature，同样特征值表示归一化后的 offset，element-wise 乘上 ROI 的 w 和 h，得到实际的 offset 值。</li>
</ol>
<h1 id="Deformable-ConvNet-v2"><a href="#Deformable-ConvNet-v2" class="headerlink" title="Deformable ConvNet v2"></a>Deformable ConvNet v2</h1><p>可变形卷积网络 v1 的缺点是对目标边界信息的捕获不够准确，在可变形卷积网络 v2（DCNv2）中，使用更多的 conv layer 学习 offset，且每个样本不仅学习 offset，还学习 feature 的幅值调整。</p>
<p>为了更好的理解可变形卷积，文中给出了如下视图：</p>
<ol>
<li>有效感受野</li>
<li>有效取样点位置</li>
<li>有界误差（小误差）的显著性区域</li>
</ol>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p>Baseline 组成：Faster R-CNN + ResNet + aligned RoIPooling</p>
<p>应用 <strong>可变形：</strong><br>RPN 加在 stage4 的输出特征之上，conv5 中的 conv 则采用可变性卷积，RoIPooling 采用可变形 RoIPooling。conv5 中的 stride=16，而非原来的 32，这是为了提高 feature map 的 resolution，将 conv5_1 的 stride 改为 1 即可实现。</p>
<p>conv5 的输出特征之上，采用 Fast R-CNN 检测head，其他包括 RoIPooling 和两个 fc（全连接层），然后是两个并列的分类分支和回归分支。</p>
<h2 id="提升可变形能力"><a href="#提升可变形能力" class="headerlink" title="提升可变形能力"></a>提升可变形能力</h2><p>可变形卷积应用到 conv3，conv4 和 conv5 中所有的 3x3 conv 上（DCNv1 中仅 conv5 中的 3x3 conv 应用了可变形卷积）</p>
<p><strong>调整可变形 conv:</strong></p>
<p>引入一个调制机制，使得可变形卷积不但可以调整 offset，还可以调整 feature 的各 location 处的幅值。极端情况下，这个模块可以通过设置 feature 某处幅值为 0 从而决定不再注意这个 location 处的信号。</p>
<p>记卷积核卷积采样点（location）为 $K$，其中第 $k$ 个 location 的权值和 offset 分别为 $w_k, \ p_k$，例如 <code>3x3</code> 卷积的采样点数量为 $K=9$，且<br>$$p_k \in {(-1,-1), (-1,0),…,(1,1)}$$</p>
<p>输入特征 x 和输出特征 y 上一点 p 处的特征值分别记为 $x(p), \ y(p)$，调整后的可变形卷积为<br>$$y(p)=\sum_{k=1}^K w_k \cdot x(p+p_k+\Delta p_k)\cdot \Delta m_k$$<br>其中 $\Delta p_k$ 是可学习的 offset，$\Delta p_k$ 是非归一化的。$\Delta m_k \in [0,1]$ 是幅值修正系数。$x(p+p_k+\Delta p_k)$ 使用双线性插值求得。</p>
<p>$\Delta p_k, \ \Delta m_k$ 通过输入 feature map 上使用另一 conv layer 获得 <code>3K</code> channel 的输出，前 2K 表示 $\Delta p_k$，后 K channel 的数据继续经 sigmoid，得到 $\Delta m_k$。</p>
<p><strong>调整可变形RoIPooling:</strong></p>
<p>RoIPooling 将 RoI 划分为 <strong>K</strong> 个 bins（例如 <code>7x7</code>），每个 bin 中，取若干个采样点（例如 <code>2x2</code>），采样点的平均作为这个 bin 的输出。对 RoIPooling 赋予调整后的可变形能力，同可变形卷积一样，除了 offset 还有幅值，分别记为 $\Delta p_k$ 和 $\Delta m_k$，表示第 <code>k</code> 个 bin，那么这个 bin 的输出改为，<br>$$y(k)=\sum_{j=1}^n x(p_{kj}+\Delta p_k) \cdot \Delta m_k / n$$<br>其中 $n$ 表示 bin 中采样点数量，$p_{kj}$ 表示第 <code>k</code> 个 bin 中第 <code>j</code> 个采样点坐标。与 DCNv1 中类似，针对每个 bin 有 offset 和幅值变化。$x(p_{kj}+\Delta p_K)$ 采样双线性插值计算该处特征值。</p>
<p><strong>分支结构：</strong></p>
<p>RoIPooling 从 feature maps 上得到 RoI feature patch，后跟 2x fc（两个全连接层），dimension 均为 1024，然后是一个 3K channel 的 fc，其他前 2K 表示归一化的 offset，乘以 RoI 的宽高得到实际的坐标 offset ${\Delta p_k}<em>{k=1}^K$。剩余的 K 通过 sigmoid layer 得到幅值伸缩系数 ${\Delta m_k}</em>{k=1}^K$。</p>
<h2 id="R-CNN-特征模拟"><a href="#R-CNN-特征模拟" class="headerlink" title="R-CNN 特征模拟"></a>R-CNN 特征模拟</h2><p>可视化显示，对于常规 ConvNet 和可变形 ConvNet，分类 node 对应的 error-bounded saliency region 超出 RoI 区域，导致 RoI 之外的 Image 内容影响了目标检测结果的准确性。R-CNN 论文中，分类预测集中在根据 RoI 来 crop 得到的 image 上，这使得分类准确性得到提升。我们这里的可变形 ConvNet 基于 Faster R-CNN，而直接结合 Faster R-CNN 和 R-CNN，使得训练和推断均变得缓慢。另一方面，可变形 ConvNet 可调整 bin 输出的幅值，通过令 幅值放缩系数为 0，可屏蔽范围之外多余的 context，但是实验效果并不理想，猜想这可能是因为传统的 Faster R-CNN 训练损失无法有效驱动这种表征（指可变形 RoIPooling）的学习过程。</p>
<p>于是，引进一个 feature 模拟的损失，与 R-CNN 从 cropped image 中抽取的特征类似，可以驱动可变形 Faster R-CNN 学习如何着重于特征表示。这种特征模拟仅用于正例 RoI 上，对负例 RoI 效果不好。<br>下图是网络结构，<br><img src="/images/obj_det/two_stage_fig2.png" alt=""></p>
<center>图2. 基于 Faster R-CNN 的可变形卷积和 R-CNN 特征模拟</center>

<p>给定一个 RoI <code>b</code>，在 feature 模拟分支上，<code>b</code> 对应的原输入 image 上的部分 crop 出来，并 resize 到 <code>224x224</code> 大小，经调整后的可变形卷积网络后得到 <code>14x14</code> 的 feature，然后使用调整的 RoIPooling 得到 <code>7x7</code>（这里的 <code>7x7</code> 是一个示例，其他情况下可修改），然后经 2x fc 得到最终的 RCNN 分支 1024-D 的特征，记为 $f_{RCNN}(b)$，这个特征经过 <code>C+1</code>-way 的 softmax 分类（这里笔者觉得应该再使用一个 <code>C+1</code>-D 的 fc 层后使用 softmax）。另外，Faster R-CNN 分支的输出特征也是 1024-D（由 Fast R-CNN head 输出得到），记为 $f_{FRCNN}(b)$，那么 feature 模拟损失定义如下，<br>$$L_{mimic}=\sum_{b \in \Omega}[1-\cos (f_{RCNN}(b), f_{FRCNN}(b))]$$<br>其中，$\Omega$ 表示图中的 RoI 集，$\cos(\cdot, \cdot)$ 表示向量的余弦相似度。</p>
<h1 id="Mask-R-CNN"><a href="#Mask-R-CNN" class="headerlink" title="Mask R-CNN"></a>Mask R-CNN</h1><p>在 Faster R-CNN 基础上，增加一个预测目标 mask 的分支，实现 instance segmentation。</p>
<p>mask 分支为每个 ROI 生成 binary mask。Mask R-CNN 与其他系统不同，其他系统将 classification 和 segmentation 耦合起来（生成 K+1 dimension 的 mask）。</p>
<p><strong>损失</strong><br>$$L=L_{cls}+L_{box}+L_{mask}$$<br>其中，前两项与 Faster R-CNN 中一致。mask 分支的输出为 $Km^2$ 维度，K 表示 foreground 分类数量 ，<code>mxm</code> 表示 resolution，每个 pixel 上应用 sigmoid，于是 $L_{mask}$ 为 binary cross-entropy 损失平均，$L_{mask}$ 中仅对 resolution 每个 position 实际所属分类 <code>k</code> 的那一项，相当于 $L_{mask}$ 实际是 $m^2$ 个 binary cross-entropy loss 的平均。</p>
<p>每个 ROI 经 mask 分支得到 <code>mxm</code> 的 mask，mask 分支是 FCN（全卷积网络），其中每个 layer 均可保留目标的空间信息，比起使用 fc（全连接层），FCN 使用更少的参数，预测也更准确。</p>
<h2 id="RoIAlign"><a href="#RoIAlign" class="headerlink" title="RoIAlign"></a>RoIAlign</h2><p>Faster R-CNN 中利用 RoIPool 从 RoI feature（例如在 conv4 上根据 RoI 抠出）抽取得到一个更小的固定的 feature map（例如 <code>7x7</code>），而在 conv4 的输出 feature 上抠出 RoI，这就带来了不对齐问题，因为 conv4 的 feature 上 stride=16，那么 RoI 在 conv4 的 feature 上的坐标为 $[x/16]$，其中 $[\cdot]$ 表示四舍五入，浮点数被离散化处理，同样地，RoI feature 映射到 <code>7x7</code> 上（相当于在 RoI feature 上划分得到 <code>7x7</code> bins）时，也进行了这种离散化处理，这就使得原 input image 上的 RoI 与最终抽取的feature 之间不对齐，这个问题对分类没有影响，但是对 pixel 级别的 mask 预测则有很大的影响。</p>
<p>解决办法就是去掉离散化处理，使用 $x/16$ 浮点数代替 $[x /16]$ 整数，在 conv4 feature 上得到准确的浮点数 RoI 的坐标，如图 1，<br><img src="/images/obj_det/two_stage_fig1.png" alt=""><center>fig1. RoIAlign 示意图</center></p>
<p>图1 中示例为 <code>2x2</code> bins，虽然与我们的 <code>7x7</code> bins 不同，但是这不影响，原理都差不多，那么，如何得到每个 bin 中 的 feature patch 呢？（得到每个 bin 的 feature patch，才能做 pooling）</p>
<p>对每个 bin，取 4 个采样点，每个采样点坐标不一定是整数，所以使用双线性插值计算每个点处的特征值，然后使用 max 或 average 进行 pooling，如图 1。</p>
<h2 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h2><p><strong>backbone:</strong></p>
<p>backbone 采样两种：1. <code>ResNet-50-C4</code>，其中 <code>C4</code> 表示 ResNet stage 4 的输出 feature；2. <code>ResNet-FPN</code>。ResNet 可以替换为 ResNeXt。</p>
<p><strong>detection head:</strong></p>
<p>将 C4 中 RoI 对应的 feature 区域经过 RoIAlign 得到 <code>7x7x1024</code> 的输出，然后经 <code>res5</code>（ResNet 中的 stage 5，共 9 个 layer），输出 feature  tensor 的大小不变，然后分两路，其中一路用于分类预测和 box 坐标回归预测，另一路用于生成 mask。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>resize image，使得短边固定在 800，训练时，每个 mini-batch 有 2 个 images，每个 image 有 N 个 RoIs，正负例比为 <code>1:3</code>。</p>
<h1 id="R-FCN"><a href="#R-FCN" class="headerlink" title="R-FCN"></a>R-FCN</h1><p>region-based fully convolutional networks</p>
<p>目标检测的 backbone 通常都是来自分类网络，而分类问题中 translation invariance 与目标检测中 translation variance 是不一致的，目标检测中，移动 proposal box 将会影响与 gt box 的 IOU。</p>
<p>R-FCN 中使用共享的全卷积网络，为了使 FCN 具有 translation variance，设计了一组 position-sensitive score maps，每个 score map encode 位置信息，如下图，<br><img src="/images/obj_det/two_stage_fig3.png" alt=""></p>
<p>RPN 网络用于生成 proposal box（RoI），RoI 被划分为 <code>kxk</code> grid，每个 cell 对于一个 score map（包含 C+1 个 channel，每个 channel 对应一个分类），执行 RoIPooling 时，不同的 cell 区域使用不同的 score maps。</p>
<p>Backbone 使用 ResNet-101，由于最后一个 conv 为 2048-d，为了降低 dimension，增加一个 <code>1x1</code> 1024-d 的 conv，然后再用 $k^2(C+1)$-d 的 conv 生成 positive-sensitive score maps。</p>
<h2 id="position-sensitive-roi-pooling"><a href="#position-sensitive-roi-pooling" class="headerlink" title="position-sensitive roi pooling"></a>position-sensitive roi pooling</h2><p>得到 positive-sensitive score maps 后，根据 RPN 生成的每个 RoI，划分出 <code>kxk</code> bin，每个 bin 对应一个 score map，在其上使用 pooling，记 RoI size 为 <code>wxh</code>，每个 bin 的 size 为 $\frac w k \times \frac h k$，对于第 <code>(i,j)</code> 个 bin， RoI pooling 在第 <code>(i,j)</code> 个 score map 上执行 average pooling，得到 <code>kxkx(C+1)</code> 的输出，然后进行 <strong>vote</strong> （averaging），得到 <code>C+1</code> 的 vector（对单个 RoI 而言），然后使用 softmax 计算分类得分。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/02/20/dl/Metrics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/20/dl/Metrics/" class="post-title-link" itemprop="url">Metrics</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-20 10:09:36 / 修改时间：12:04:21" itemprop="dateCreated datePublished" datetime="2021-02-20T10:09:36+08:00">2021-02-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>总结机器学习/深度学习中常用的一些指标</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/02/20/dl/Metrics/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/02/19/dl/Training-Operations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/19/dl/Training-Operations/" class="post-title-link" itemprop="url">Training Operations</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-02-19 14:16:51 / 修改时间：14:18:41" itemprop="dateCreated datePublished" datetime="2021-02-19T14:16:51+08:00">2021-02-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>深度学习中的训练有很多技巧，这里总结一些常用的操作技巧。</p>
<h1 id="Weight-Decay"><a href="#Weight-Decay" class="headerlink" title="Weight Decay"></a>Weight Decay</h1><p>权重衰减</p>
<h1 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/02/19/dl/conv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/19/dl/conv/" class="post-title-link" itemprop="url">Convolution</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-19 09:27:01" itemprop="dateCreated datePublished" datetime="2021-02-19T09:27:01+08:00">2021-02-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-06 18:23:39" itemprop="dateModified" datetime="2021-03-06T18:23:39+08:00">2021-03-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="膨胀卷积"><a href="#膨胀卷积" class="headerlink" title="膨胀卷积"></a>膨胀卷积</h1><p>膨胀卷积在卷积核中引入 空洞（holes），将卷积核变大，记膨胀率为 $\alpha$，卷积核大小为 $k$，那么膨胀后卷积核大小变为 $\alpha(k-1)+1$，使用膨胀后的卷积核来做卷积计算。</p>
<p>膨胀卷积在图像（实例）分割中应用较多，为了扩大感知区域，同时减少计算量，膨胀卷积效果较好。</p>
<p>Dilated Convolution 的设计是为了获取 long-range information，故对大物体比较适用，对小物体则不太适用。Dilated Convolution 一个明显的缺点是 kernel 不连续，产生栅格效应，所以又提出了 Hybrid Dilated Convolution（HDC）混合膨胀卷积。</p>
<p>HDC 的一般设计原则：</p>
<ol>
<li>各膨胀卷积的膨胀率不能有大于 1 的公约数（例如 [2,4,6] 公约数为 2），否则会有栅格效应</li>
<li>膨胀率设计为锯齿状结构，例如 [1,2,5,1,2,5] 这样的循环结构</li>
<li>膨胀率满足如下关系<br>$$M_i=\max[M_{i+1}-2r_i, 2r_i-M_{i+1}, r_i]$$<br>其中 $r_i$ 为第 <code>i</code> 层的膨胀率，$M_i$ 为第 <code>i</code> 层的最大 dilated rate，网络总共 <code>L</code> 层，$M_L=r_L$。</li>
</ol>
<h1 id="分组卷积"><a href="#分组卷积" class="headerlink" title="分组卷积"></a>分组卷积</h1><p>假设输入 feature shape 为 $(c_0,h,w)$，original filter 为 $(k,k,c_0,c_1)$，输出 feature shape 为 $(c_1,h,w)$。对于分组卷积，假设分 n 组，那么每一组输入 feature shape 为 $(c_0/n, h, w)$，每一组使用独立的卷积核， filter shape 为 $(k,k,c_0/n, c_1/n)$，于是每一组的输出 feature shape 为 $(c_1/n, h, w)$，最后所有组的输出沿着 channel 进行 concatenate，得到最终输出 feature shape $(c_1, h, w)$，这个过程中，卷积核参数数量为<br>$$k \times k \times \frac {c_0} n \times \frac {c_1} n \times n$$<br>参数数量减小。</p>
<h1 id="Bottleneck"><a href="#Bottleneck" class="headerlink" title="Bottleneck"></a>Bottleneck</h1><p>假设输入 shape 为 $(c_0, h, w)$，输出 shape 为 $(c_1, h, w)$，那么 filter 为 $k \times k \times c_0 \times c_1$，参数数量较大，改用 bottleneck 可以缩减参数数量，即：先使用 $1\times 1 \times c_0 \times c_2$ 的 filter，然后使用 $k \times k \times c_2 \times c_2$ 的 filter，最后使用 $1 \times 1 \times c_2 \times c_1$ 的 filter，其中 $c_2 &lt; c_1, c_0$。</p>
<h1 id="Depthwise-Conv"><a href="#Depthwise-Conv" class="headerlink" title="Depthwise Conv"></a>Depthwise Conv</h1><p>假设输入 shape 为 $(c_0, h, w)$，每个 channel 独立进行（二维卷积），卷积 filter 为 $k \times k \times c_0$（注意这里 filter shape 中没有 $c_1$），得到 $(c_0, h, w)$ 的中间输出，然后再使用 $1 \times 1 \times c_0 \times c_1$，得到 $(c_1, h, w)$ 的最终输出。</p>
<h1 id="可变形卷积"><a href="#可变形卷积" class="headerlink" title="可变形卷积"></a>可变形卷积</h1><p>略（参考 <a href="/obj_det/two_stage">deformable conv</a>）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/02/18/dl/receptive_field/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/18/dl/receptive_field/" class="post-title-link" itemprop="url">Receptive Field</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-18 10:51:00" itemprop="dateCreated datePublished" datetime="2021-02-18T10:51:00+08:00">2021-02-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-19 10:18:58" itemprop="dateModified" datetime="2021-02-19T10:18:58+08:00">2021-02-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Size"><a href="#Size" class="headerlink" title="Size"></a>Size</h1><p>对于一个 fully CNN 的网络，第 <code>k</code> layer 的 receptive field 大小为，<br>$$l_k=l_{k-1} + ((f_k-1)*\prod_{i=1}^{k-1} s_i)$$<br>其中，$l_{k-1}$ 表示第 <code>k-1</code> layer 上的 receptive field 大小，$f_k$ 是第 <code>k</code> layer 的 filter 大小，$s_i$ 是第 <code>i</code> layer 上的 stride 大小。这是自底向上计算，从 $l_1$ 开始，$l_1=f_1$。</p>
<p>还有一种自顶向下的计算方法。假设总共有 <code>L</code> 个 layer，每个 layer 的输出 feature map 记为 $f_l, \ l=1,…,L$，每个 layer 的 filter 大小为 $k_l$，stride 大小记为 $s_l$，记 $r_l$ 为最后一个 layer 关于 feature map $f_l$ 的 receptive field 大小，也就是说，$r_l$ 表示 $f_l$ 上多少个像素点对 $f_L$ 的一个像素点有贡献（这里仅考虑一维 feature map，如果是多维，那么分别独立考虑即可）。那么易知，$r_L=1$，</p>
<p>$r_{L-1}=k_L$，这个也很好理解，上一层 feature map 中，$k_L$ 个像素点对应本层（最后一层）一个像素点。考虑一般情况，已知 $r_l$，求 $r_{l-1}$。</p>
<p>首先假设 $k_l=1$，这样情况就简单些，若 $s_l=1$，那么 $r_{l-1}=r_l$，若 $s_l&gt;1$，那么 $r_{l-1}=s_l \cdot r_l -(s_l-1)$，因为 $r_l$ 中每两个像素点之间对应到 $f_{l-1}$ 上有 $s_l-1$ 个点，所以 $r_{l-1}=(s_l-1)\cdot(r_l-1)+ r_l=s_l \cdot r_l-s_l+1$。</p>
<p>然后当 $k_l&gt;1$，那么需要在 $f_{l-1}$ 上增加 $k_l-1$ 个像素点，于是<br>$$r_{l-1}=s_l \cdot r_l + (k_l-s_l)$$<br>其中，$r_L=1, \ r_{L-1}=k_L$。求解上式过程如下：<br>$$r_{L-2}=s_{L-1} r_{L-1}+(k_{L-1}-s_{L-1})=s_{L-1}(k_L-1)+k_{L-1}$$<br>$$r_{L-3}=s_{L-2} r_{L-2}+(k_{L-2}-s_{L-2})=s_{L-2}s_{L-1}(k_L-1)+s_{L-2}(k_{L-1}-1)+k_{L-2}$$<br>$$\cdots$$<br>$$r_{l}=s_{l+1}\cdots s_{L-1}(k_L-1)+s_{l+1}\cdots s_{L-2}(k_{L-1}-1)+ \cdots s_{l+1}(k_{l+2}-1)+k_{l+1}=1+\sum_{j=l+1}^{L} \left[(k_{j}-1) \prod_{i=l+1}^{j-1}s_i \right]$$<br>其中令 $$\prod_{l+1}^{l}s_i=1$$</p>
<p>于是，<br>$$\begin{aligned} r_{l-1}&amp;=1+\sum_{j=l}^{L} \left[(k_{j}-1) \prod_{i=l}^{j-1}s_i \right] \ &amp;=1+(k_l-1)+\sum_{j=l+1}^{L} \left[(k_{j}-1) \prod_{i=l+1}^{j-1}s_i \cdot s_l \right] \&amp;=k_l-s_l+s_l \left(1+\sum_{j=l+1}^{L} \left[(k_{j}-1) \prod_{i=l+1}^{j-1}s_i \right] \right) \&amp;=s_l \cdot r_l +k_l-s_l\end{aligned}$$<br>与前面递推式一致，说明通项式计算正确。</p>
<p>output feature size 的计算为，<br>$$w_l=\frac {w_{l-1}+2p_l-k_l} {s_l}+1$$<br>其中 $w$ 表示宽，高 $h$ 的计算类似（以 2D image 数据为例）。</p>
<h1 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h1><p>对输出 feature map 上一点有贡献的 region （Receptive Field）大小计算如上，还有一个参数也很重要：定位这个 region 的位置。例如输出 feature map 上一点 $f_L(i,j)$，产生这个特征的输入图像上的 region 位置如何求得。</p>
<p>记在特征平面 $f_l$ 上这个 region 的左端和右端的坐标分别为 $u_l, \ v_l$，这里的<b>坐标从 0 开始</b>，即，第一个像素点的坐标为 <code>0</code>，在输出特征平面 $f_L$ 上有 $u_L=v_L=i$，同样地，仅考虑一维情况，对于二维情况，另一维度独立地进行类似计算可得。</p>
<p>同样使用递推的思想，已知 $u_l, \ v_l$，求 $u_{l-1}, v_{l-1}$。</p>
<p>首先从一个简单的情况开始，假设 $u_l=0$，这表示 $f_l$ 中的 region 左侧位于第一个像素点，此时 $u_{l-1}=-p_l$，即$f_{l-1}$ 左侧填充 $p_l$ 个像素；如果 $u_l=1$，那么 $u_{l-1}=s_l-p_l$，这也很好理解，从 $f_{l-1}$ 最左侧第一个像素点（填充之后为 $-p_l$）向右移动 $s_l$；如果 $u_l=2$，那么继续向右移动 $s_l$，即 $u_{l-1}=2s_l-p_l$，于是一般地，<br>$$u_{l-1}=u_l \cdot s_l -p_l$$<br>$$v_{l-1}=v_l \cdot s_l - p_l + k_l-1$$<br>完全式的计算过程如下：<br>$$u_{L-1}=u_L \cdot s_L - p_L$$<br>$$u_{L-2}=u_{L-1} \cdot s_{L-1}-p_{L-1}=s_{L-1}s_L u_L-s_{L-1}p_L-p_{L-1}$$<br>$$u_{L-3}=u_{L-2} \cdot s_{L-2}-p_{L-2}=s_{L-2}s_{L-1}s_L u_L-s_{L-2}s_{L-1}p_L-s_{L-2}p_{L-1}-p_{L-2}$$<br>$$\cdots$$<br>$$u_l=s_{l+1}\cdots s_L u_L-s_{l+1}\cdots s_{L-1} p_{L}-\cdots-s_{l+1} p_{l+2}-p_{l+1}=u_L\prod_{i=l+1}^L s_i-\sum_{j=l+1}^L p_j \prod_{i=l+1}^{j-1} s_i$$</p>
<p>其中，$\prod_{i=l+1}^l s_i=1$, 类似地，<br>$$v_l=v_L \prod_{i=l+1}^L s_i - \sum_{j=l+1}^L(1+p_j-k_j)\prod_{i=l+1}^{j-1} s_i$$</p>
<h1 id="Relation"><a href="#Relation" class="headerlink" title="Relation"></a>Relation</h1><p>Receptive Field size 与 region 之间的联系，<br>$$r_l=v_l-u_l+1$$</p>
<h1 id="Stride-amp-Padding"><a href="#Stride-amp-Padding" class="headerlink" title="Stride &amp; Padding"></a>Stride &amp; Padding</h1><p>定义两个变量，有效 stride 和 有效 padding，这两者分别定义如下：</p>
<p>$$S_l=\prod_{i=l+1}^L s_i$$</p>
<p>$$P_l=\sum_{j=l+1}^L p_j \prod_{i=l+1}^{j-1}s_i$$</p>
<p>他们的递推公式为，<br>$$S_{l-1}=s_l \cdot S_l$$<br>$$P_{l-1}=p_l+s_l \cdot P_l$$</p>
<p>有着这两个定义变量，region 位置公式可表示为，<br>$$u_l=u_L \cdot S_l - P_l$$</p>
<h1 id="Center"><a href="#Center" class="headerlink" title="Center"></a>Center</h1><p>receptive field 的中心可由 region 位置计算得到，在第 <code>l</code> layer 上为，<br>$$c_l=\frac {u_l+v_l} 2$$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">shajianjian</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shajianjian</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
