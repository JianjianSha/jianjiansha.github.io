<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"shajianjian.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="SJJ">
<meta property="og:url" content="https://shajianjian.github.io/page/2/index.html">
<meta property="og:site_name" content="SJJ">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="shajianjian">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://shajianjian.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>SJJ</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">SJJ</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/06/08/cpp/cmake_target/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/08/cpp/cmake_target/" class="post-title-link" itemprop="url">cmake TARGET</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-08 17:15:50" itemprop="dateCreated datePublished" datetime="2021-06-08T17:15:50+08:00">2021-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-15 10:09:04" itemprop="dateModified" datetime="2021-09-15T10:09:04+08:00">2021-09-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>cmake 的目标 TARGET。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/08/cpp/cmake_target/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/06/08/cpp/cmake_find/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/08/cpp/cmake_find/" class="post-title-link" itemprop="url">cmake 查找</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-08 14:08:47" itemprop="dateCreated datePublished" datetime="2021-06-08T14:08:47+08:00">2021-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-15 10:07:40" itemprop="dateModified" datetime="2021-09-15T10:07:40+08:00">2021-09-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>cmake 的包查找。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/08/cpp/cmake_find/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/06/08/cpp/link/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/08/cpp/link/" class="post-title-link" itemprop="url">链接</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-08 11:06:44" itemprop="dateCreated datePublished" datetime="2021-06-08T11:06:44+08:00">2021-06-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-11 14:32:07" itemprop="dateModified" datetime="2021-08-11T14:32:07+08:00">2021-08-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="动态库目录"><a href="#动态库目录" class="headerlink" title="动态库目录"></a>动态库目录</h2><ol>
<li>加入 <code>/lib</code>, <code>/usr/lib</code> 等默认搜索路径</li>
<li>设置 <code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&lt;YOUR LIB PATH&gt;</code></li>
<li>修改配置文件 <code>/etc/ld.so.conf</code>，然后执行 <code>ldconfig</code></li>
<li><code>gcc</code> 添加选项 <code>-Wl,-rpath=&lt;YOUR LIB PATH&gt;</code>。这个路径会保存到程序中。<br>以上是动态（运行时）链接器（也可称为加载器）寻找动态库的搜索目录。</li>
</ol>
<h3 id="Wl"><a href="#Wl" class="headerlink" title="-Wl"></a>-Wl</h3><p>这个参数表示后面的参数传递给链接器 <code>ld</code></p>
<h3 id="rpath"><a href="#rpath" class="headerlink" title="-rpath"></a>-rpath</h3><p>添加一个目录到运行库搜索路径，可以使用 <code>$ORIGIN</code>，它表示执行文件所在的目录，注意在 Makefile 中需要写为 <code>$$ORIGIN</code>。</p>
<h3 id="–as-needed"><a href="#–as-needed" class="headerlink" title="–as-needed"></a>–as-needed</h3><p>链接器参数，表示仅链接其 symbol 在 binary 中用到的库。默认是开启这个 flag，若要关闭，使用 <code>--no-as-needed</code>，例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/foo.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"foo\n"</span>); &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/bar.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="built_in">printf</span>(<span class="string">"bar\n"</span>); &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile</span></span><br><span class="line"><span class="section">main: main.c lib/libfoo.so lib/libbar.so</span></span><br><span class="line">    gcc -o main main.c -Wl,--no-as-needed,-rpath='$$ORIGIN/lib' -L. -lfoo -lbar</span><br><span class="line"></span><br><span class="line"><span class="section">lib/libfoo.so: lib/foo.c</span></span><br><span class="line">    gcc -fPIC -shared -o lib/libfoo.so lib/foo.c</span><br><span class="line"></span><br><span class="line"><span class="section">lib/libbar.so: lib/bar.c</span></span><br><span class="line">    gcc -fPIC -shared -o lib/libbar.so lib/bar.c</span><br></pre></td></tr></table></figure>

<p>查看 <code>main</code> 链接的库，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ldd main</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/06/04/cpp/cmake_cmds_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/04/cpp/cmake_cmds_1/" class="post-title-link" itemprop="url">cmake 常用命令（一）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-04 18:50:48" itemprop="dateCreated datePublished" datetime="2021-06-04T18:50:48+08:00">2021-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-15 10:08:34" itemprop="dateModified" datetime="2021-09-15T10:08:34+08:00">2021-09-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>cmake 的几个常用命令。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/04/cpp/cmake_cmds_1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/06/03/cpp/cmake_im_ex/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/03/cpp/cmake_im_ex/" class="post-title-link" itemprop="url">cmake import export</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-03 13:59:06" itemprop="dateCreated datePublished" datetime="2021-06-03T13:59:06+08:00">2021-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-15 10:08:47" itemprop="dateModified" datetime="2021-09-15T10:08:47+08:00">2021-09-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>cmake 的导入导出机制。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/03/cpp/cmake_im_ex/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/06/02/cpp/cmake_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/06/02/cpp/cmake_1/" class="post-title-link" itemprop="url">cmake tutorial</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-06-02 10:35:18" itemprop="dateCreated datePublished" datetime="2021-06-02T10:35:18+08:00">2021-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-09-15 10:08:08" itemprop="dateModified" datetime="2021-09-15T10:08:08+08:00">2021-09-15</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>cmake 的使用示例。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/06/02/cpp/cmake_1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/03/08/dl/norm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/08/dl/norm/" class="post-title-link" itemprop="url">Normalization</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-08 11:26:46" itemprop="dateCreated datePublished" datetime="2021-03-08T11:26:46+08:00">2021-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-12 15:39:48" itemprop="dateModified" datetime="2021-03-12T15:39:48+08:00">2021-03-12</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Batch-Norm"><a href="#Batch-Norm" class="headerlink" title="Batch Norm"></a>Batch Norm</h1><p>对 channel 之外的所有维度做归一化，即在 <code>(B,H,W)</code> 上做归一化，每个 channel 独立进行，<br>$$y=\frac {x-E[x]} {\sqrt{Var[x]+\epsilon}} \cdot \gamma + \beta$$<br>作用：</p>
<ol>
<li>防止过拟合。单个样本的输出依赖于整个 mini-batch，防止对某个样本过拟合</li>
<li>加快收敛。梯度下降过程中，每一层的 W 和 b 都会不断变化，导致输出结果分布也不断变化，后层网络需要不停地适应这种变化，而 BN 可使得每一层输入分布近似不变。</li>
<li>防止梯度消失。以 sigmoid 激活函数为例，经过 BN 使得输出在中心附近，梯度较大。</li>
</ol>
<h1 id="Layer-Norm"><a href="#Layer-Norm" class="headerlink" title="Layer Norm"></a>Layer Norm</h1><p>Layer Norm 对每个样本进行归一化，即在 <code>(C,H,W)</code> 上做归一化，每个样本独立进行。</p>
<h1 id="Instance-Norm"><a href="#Instance-Norm" class="headerlink" title="Instance Norm"></a>Instance Norm</h1><p>Instance Norm 对每个样本的每个 channel 进行归一化，即在 <code>(H,W)</code> 上做归一化。</p>
<h1 id="Group-Norm"><a href="#Group-Norm" class="headerlink" title="Group Norm"></a>Group Norm</h1><p>与 Layer Norm 类似，不同的是 Group Norm 将 <code>(C,H,W)</code> 在 channel 上分组，假设分为 <code>G</code> 组，那么在 <code>(C/G, H, W)</code> 上做归一化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/03/05/obj_det/lightweight/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/05/obj_det/lightweight/" class="post-title-link" itemprop="url">lightweight</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-05 16:18:13" itemprop="dateCreated datePublished" datetime="2021-03-05T16:18:13+08:00">2021-03-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-06 14:38:12" itemprop="dateModified" datetime="2021-03-06T14:38:12+08:00">2021-03-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ThunderNet"><a href="#ThunderNet" class="headerlink" title="ThunderNet"></a>ThunderNet</h1><p>(two-stage detector)</p>
<p>移动设备上计算能力有限，而现在的很多 CV 实现方式都需要较强的计算力，这导致这些任务难以在移动设备上 real-time 的实现。本文研究了 two-stage 目标检测 real-time 的有效性，并提出了一个轻量级的 two-stage 检测器，名为 ThunderNet。</p>
<p>简介：</p>
<ol>
<li>研究了先前轻量级 backbone 的缺点，并提出了一个新的为目标检测而设计的轻量级 backbone  <code>SNet</code></li>
<li>沿用 Light-Head R-CNN 的 detection head 结构</li>
<li>进一步压缩 RPN 和 R-CNN 两个 subnet，以加快计算速度。 </li>
<li>small backbone 会带来一定的性能降级，所以设计两个高效率模块 <code>Context Enhancement Module</code> 和 <code>Spatial Attention Module</code>。CEM 结合多个 scale 的 feature （backbone 中浅层到深层的 feature）以利用 local 和 global 信息。SAM 利用 RPN 学习到的信息来微调 RoI warping 中的特征。</li>
<li>input resolution：<code>320x320</code>，小 size 可以加快网络的 inference 速度。</li>
</ol>
<h2 id="backbone"><a href="#backbone" class="headerlink" title="backbone"></a>backbone</h2><p><strong>Receptive Field:</strong></p>
<p>大感受野可以利用更多的上下文信息，同时能有效地 encode 像素间的 long-range 关系，这对目标尤其大目标的定位非常关键。</p>
<p><strong>early &amp; late stage feature:</strong></p>
<p>高层特征具有更强的语义性，更具有辨别性，低层特征具有更丰富的空间细节信息，所以高低层特征都需要用到。</p>
<p><strong>SNet</strong></p>
<p>SNet 作为专为 real-time 目标检测而设计的轻量级的 backbone。SNet 以 ShuffleNetV2 为基础进行改造，将所有的 <code>3x3</code> depthwise conv 改为 <code>5x5</code> depthwise conv，以获取更大的感受野，同时保持差不多的计算速度。还有其他的一些改动这里不一一指出。</p>
<p>depthwise conv: 每个通道独立进行二维卷积，需要 $c_{in}$ 个 $k \times k$ 卷积，得到的 feature 的 shape 与输入 feature shape 相同，然后再执行 $1 \times 1 \times c_{in}\times c_{out}$ 的跨通道卷积，输出 feature 的channel 为 $c_{out}$。 </p>
<h2 id="Detection-Part"><a href="#Detection-Part" class="headerlink" title="Detection Part"></a>Detection Part</h2><p>压缩 RPN 和 Detection Head。Light-Head R-CNN 的 detection head 虽然是轻量级，但是配合小的 backbone 时，依然太过 heavy，导致 backbone 与 dection head 之间产生 imbalance。</p>
<p>压缩 RPN：将原来的 256-d <code>3x3</code> conv 替换为 <code>5x5</code> 的 depthwise 和 256-d <code>1x1</code> conv。anchor 的配置为 scale：<code>{32, 64, 128, 256, 512}</code>，aspect ratio：<code>{1:2, 3:4, 1:1, 4:3, 2:1}</code>。</p>
<p>detection head： Light-head R-CNN 中的 thin feature map $\alpha \times p \times p$，其中 $p=7, \ \alpha=10$，由于 thundernet 中 backbone 和 input image size 均较小，所以继续降低 $\alpha=5$。采用 PSRoI，由于 PSRoI 输出的 feature 仅 245-d，那么 R-CNN subnet 中的 fc 全连接层为 1024-d。</p>
<h2 id="CEM"><a href="#CEM" class="headerlink" title="CEM"></a>CEM</h2><p>context enhancement module。</p>
<p>Light-Head R-CNN 使用 global convolutional network（GCN） 生成 thin feature map，GCN 具有 large kernel，使得 Receptive Field 增大，从而可以 encode 更多的上下文信息，但是 GCN 会给 SNet 带来很多计算量，thundernet 不使用 GCN，而是使用 CEM 解决这个问题。</p>
<p>借鉴 FPN 的思想（FPN 本身结构比较复杂），聚合multi-scale 的 局部信息和全局信息，得到具有较强判别性的 feature。CEM merge 来自以下 layer 的 feature：$C_4, \ C_5, \ C_{glb}$，其中 $C_{glb}$ 表示 global feature，通过对 $C_5$ 执行 global average pooling 得到。对以上三个 scale 的 feature 使用 <code>1x1-245</code> conv，输出 channel 均为 245，且 $C_5$ 的输出特征还需要 <code>2x</code> upsample，使得与 $C_4$ 的输出 feature 具有相同的 size，而 $C_{glb}$ 的输出本质是是一个标量，所以经 broadcast 具有与 $C_4$ 输出 feature 具有相同的 size，然后这三组相同 spatial size 的 feature 再合并。</p>
<h2 id="SAM"><a href="#SAM" class="headerlink" title="SAM"></a>SAM</h2><p>spatial attention module。</p>
<p>在 RoI warping 的输入 feature （上面说讨论的 thin feature maps）上，我们希望 负例 region 内的 feature 值足够小，正例 region 内的 feature 足够大，但是 thundernet 比正常的检测网络小，所以会难以学习到正确的 feature 分布，本文使用 SAM 解决这个问题。</p>
<p>SAM 利用 RPN 得到的信息来微调 RoI warping 的输入 feature 分布。RPN 被训练用来区分正负例，那么 RPN 的输出 feature 可以利用起来，于是，SAM 的两个输入：1. RPN 的输出 feature；2. CEM 输出的 thin feature maps。SAM 的输出 feature 为，<br>$$\mathcal F^{SAM}=\mathcal F^{CEM} \cdot sigmoid[\theta(\mathcal F^{RPN})]$$<br>其中 $\theta$ 用于维度转换，使得 $\mathcal F^{RPN}$ 和 $\mathcal F^{CEM}$ 具有相同的维度，文中使用 <code>1x1</code> conv 来执行这个维度转换。</p>
<p>SAM 的输出将作为原先 RoI warping 的输入。</p>
<p>thunernet 整个网络结构如图 1，</p>
<p><img src="/images/obj_det/lightweight_fig1.png" alt=""><center>图 1</center></p>
<h1 id="Light-Head-R-CNN"><a href="#Light-Head-R-CNN" class="headerlink" title="Light-Head R-CNN"></a>Light-Head R-CNN</h1><p>(two-stage detector)</p>
<p>设计了一个轻量级的 detection head，有如下两种设计：</p>
<ol>
<li>L：配合 large backbone，文中采用 ResNet101</li>
<li>S：配合 small backbone，文中采用 Xception</li>
</ol>
<p>backbone 最后一个 conv block 记为 $C_5$，$C_5$ 之后使用一个 separable conv（依次为 <code>kx1</code> 和 <code>1xk</code> 两个 conv），最终输出 channel 为 $10 \times p \times p$，而 R-FCN 中对应的 channel 为 $(C+1) \times p \times p$（$p \times p$ 表示 bin，因为是 positive-sensitive），所以相对 R-FCN，这里的设计更加 small。</p>
<p><strong>R-CNN subnet</strong></p>
<p>PSRoI pooling 之后，使用一个 2048-d 的全连接层，然后分两支，一支用于分类预测，一支用于box 回归预测，其中分类分支使用一个 C-d 的全连接，回归分支使用 4-d 的全连接层。</p>
<p><strong>RPN</strong></p>
<p>RPN 作用于 $C_4$ 之上，根据 anchor box 预测出一组 proposals，anchor 的 scale 为 <code>{32,64,128,256,512}</code>，aspect ratio 为 <code>{1:2,1:1,2:1}</code>。</p>
<p>整个网络的结构图如下，<br><img src="/images/obj_det/lightweight_fig2.png" alt=""><center>图 2 </center></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/02/25/obj_det/anchor_free/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/25/obj_det/anchor_free/" class="post-title-link" itemprop="url">Anchor-free Object Detection</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-25 12:31:28" itemprop="dateCreated datePublished" datetime="2021-02-25T12:31:28+08:00">2021-02-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-06 15:18:07" itemprop="dateModified" datetime="2021-03-06T15:18:07+08:00">2021-03-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="FCOS"><a href="#FCOS" class="headerlink" title="FCOS"></a>FCOS</h1><p>每个 scale 的 detection head 输出的 feature maps 上的每一 location 处预测 <code>C</code> 个分类和 <code>4</code> 个坐标，以及一个 center 得分，对每种分类采用二值分类。某个 location 位于 gt box 内，则为正例样本，否则为负例样本，box 回归 target 记为 $\mathbf t^{<em>}=(l^{</em>}, t^{<em>}, r^{</em>}, b^{<em>})$，某一 location <code>(x,y)</code> 位于 gt box $B_i=(x_0^{(i)}, y_0^{(i)}, x_1^{(i)}, y_1^{(i)})$ 内部，那么有<br>$$l^{</em>}=x-x_0^{(i)}, \quad t^{<em>}=y-y_0^{(i)}$$<br>$$r^{</em>}=x_1^{(i)} - x, \quad b^{*}=y_1^{(i)} - y$$</p>
<p>损失为<br>$$\begin{aligned} L({\mathbf p_{x,y}}, {\mathbf t_{x,y}})&amp;=\frac 1 {N_{pos}} \sum_{x,y} L_{cls}(\mathbf p_{x,y}, c_{x,y}^{<em>}) \ &amp;+ \frac {\lambda} {N_{pos}} \sum_{x,y} \mathbb I(c_{x,y}^{</em>}&gt;0) \cdot L_{reg}(\mathbf t_{x,y}, t_{x,y}^{*})\end{aligned}$$</p>
<p>其中，$c_{x,y}^{<em>}$ 表示 location <code>(x,y)</code> 处所属分类，如果是负例，$c_{x,y}^{</em>}=0$，如果是正例，那么 $c_{x,y}^{*}$ 为fg 分类id。分类损失 $L_{cls}$ 使用 Focal Loss。坐标损失 $L_{reg}$ 使用 IOU Loss。</p>
<p>如果某个 location 位于多个 gt box 交叠的区域，那么这个 location 该回归哪个 gt box 呢？ 答案是使用 multi-level 预测，见如下。</p>
<h2 id="FPN-for-FCOS"><a href="#FPN-for-FCOS" class="headerlink" title="FPN for FCOS"></a>FPN for FCOS</h2><p>引入 FPN，使用 multi-level 的 feature maps，分别记为 ${P_3, P_4, P_5, P_6, P_7}$，其中 $P_3, P_4, P_5$ 由 backbone 中的 $C_3, C_4, C_5$ 经 <code>1x1</code> conv 输出得到。$P_6, p_7$ 则分别在 $P_5, P_6$ 上使用 stride=2 的 conv 得到，各 level feature 上的 stride 分别为 <code>8,16,32,64,128</code>。</p>
<p>在不同 scale 的 feature 上限制所预测的 box 的回归值范围，具体而言，对于 $P_i$，如果某 location 满足 $\max(l^{<em>},t^{</em>},r^{<em>},b^{</em>})&gt;m_i$ 或者 $\max(l^{<em>},t^{</em>},r^{<em>},b^{</em>}) &lt; m_{i-1}$，那么这个 location 为负例，不计入坐标回归损失 $L_{reg}$。本文中 $m_2=0, \ m_3=64, \ m_4=128, \ m_5=256, \ m_6=512, \ m_7=\infty$（这是借鉴了 anchor based 中的 anchor 的 base scale 为 8）。</p>
<p>这样，不同的 level 的 feature 负责预测不同 size 范围的目标。同一 location 如果有多个目标，通常，这些交叠的目标大小不在同一个范围，于是降低了 ambiguous location，如果仍然存在 location 属于多个大小差不多目标，那么人为的将此 location 用来预测 size/area 最小的那个目标。</p>
<p>与其他基于 FPN 的目标检测器一样，不同 level 的 检测 head 分支上参数共享。观察到不同 level<br>的 feature 回归不同范围的目标（例如 $P_3$ 回归范围为 $[0,64]$），那么不同 level 的检测 head 如果完全相同，会显得不合理，所以，比起 single scale FCOS 中使用的 $exp(x)$（因为回归 target 为正，所以需要使用 $exp(x)$ 处理一下），在 multi scale FCOS 中，改为 $exp(s_i x)$，这里的 $s_i$ 是需要训练学习的参数，以自动调整其大小。</p>
<h2 id="Center-ness-for-FCOS"><a href="#Center-ness-for-FCOS" class="headerlink" title="Center-ness for FCOS"></a>Center-ness for FCOS</h2><p>实验发现，有大量低质量的预测 box，这是有距目标中心较远的 location 预测出来的结果。如何抑制它们？</p>
<p>增加一个 single-layer 分支，与分类分支并列，如图 1，</p>
<p><img src="/images/obj_det/anchor_free_fig1.png" alt=""><center>图 1</center></p>
<p>新增分支用于预测 location 的中心度 “center-ness”：是目标中心的置信度，用 location 与所属目标中心的归一化距离来表示，记回归目标为 $\mathbf t^{<em>}=(l^{</em>},t^{<em>},r^{</em>},b^{<em>})$，center-ness 目标为<br>$$\text{centerness}^{</em>}=\sqrt{\frac {\min(l^<em>, r^</em>)} {\max(l^<em>,r^</em>)} \times \frac {\min(t^<em>, b^</em>)} {\max(t^<em>,b^</em>)}}$$<br>使用平方根是为了降低 center-ness 值的衰减速度，center-ness 值范围位于 $[0,1]$，使用 BCE loss 进行训练。</p>
<p>测试阶段，<strong>最终的得分计算为 center-ness 与分类得分 相乘</strong>，以最终得分进行预测 box 的 ranking，然后经 NMS，过滤掉那些低质量的预测结果。</p>
<p>另一种 center-ness 的替换方案是，仅仅使用 gt box 中心区域的 location 作为正例，代价是需要引入一个额外参数来指定中心区域的大小。当然，也可以两者结合使用。</p>
<h1 id="CornerNet"><a href="#CornerNet" class="headerlink" title="CornerNet"></a>CornerNet</h1><p>anchor based 目标检测的缺点：1. 需要大量的 anchor，导致正负例不均衡，训练速度慢。2. 需要很多超参数（例如，anchor 数量、大小以及 aspect ratio 等），在 multi-scale feature 情况下，超参数更多。</p>
<p>本文介绍了一个 anchor free 的目标检测方法，检测目标的左上和右下两个角点。为什么检测角点呢？</p>
<ol>
<li>box 中心难以定位，因为中心依赖于目标的 4 个边坐标，而定位一个角点仅需要两个边坐标，加上本文提出的另一个设计 <code>corner pooling</code>，利用角点的定义，例如左上角，<code>corner pooling</code> encoding 当前某 location 右侧的 feature vector，以及下方的 feature vector，这种 encoding 使得角点预测更加准确。</li>
<li>密集离散化 box 时，记 feature 的 size 为 <code>(w,h)</code>，那么所有可能的角点的数量为 O(wh)，而 anchor box 的可能性则非常大，根据排列组合原理， anchor 的宽有 w 种可能，高有 h 种可能，故 anchor 的 size 有 wh 种可能，然后分布在 feature 上时，每个 anchor 有 wh 种可能，故一共 $O(w^2h^2)$。当然如果考虑到 anchor 不要超出 feature map 之外，那么 anchor 的宽为 1 时，有 w 种可能，宽为 2 时，有 w-1 种可能，… 宽为 w 时，有 1 种可能，一共有 $w+(w-1)+\cdots +1$，同样地，高也一样，所以分布在 feature 上各种 anchor 的可能性一共有 $(1+2+\cdots+w)(1+2+\cdots+h)=\frac {w(w+1)h(h+1)} 4$。当然，anchor based 检测方法为了缩减 anchor 数量，在 feature 上每个 location 使用不同 scale 和 aspect ratio 的 anchor 共 K 个，故此时一共有 $Kwh$ 个。</li>
</ol>
<h2 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h2><p>base ConvNet 采用 hourglass network，后接两个模块，分别用于左上角点和右下角点。每个模块有独立的 corner pooling 模块（因为左上和右下角点的 corner pooling 的方向不同），hourglass network 的 feature 经过 pooling 之后，得到 heatmaps，embeddings 和 offsets。</p>
<p><strong>heatmap:</strong></p>
<p>两组 heatmaps，每组 heatmap 有 C channels，其中 C 为分类数量，heatmap 的大小为 $H \times W$，heatmap 表示某个 location 是角点且属于某个分类的得分，可见 heatmap 是 binary mask。</p>
<p>对某个 corner 而言，只有一个 location 对应到它，这个 location 作为正例，其他 location 相对这个 corner 而言均为负例，这里不对所有负例等值惩罚，而是对这个 corner 一定半径范围的负例 location 降低惩罚，这是考虑到，即使是负例 location，如果很靠近对应的 corner，这些负例构成的预测 box 依然可以很好的覆盖 gt box。半径大小由对应的 gt box 确定，根据 IOU 的阈值下限 t（文中 t 设为 0.3）。如何降低惩罚？</p>
<p>使用一个二维高斯函数，随着距离增大平滑的递减，<br>$$f_{cij}=\begin{cases} e^{-\frac {x^2+y^2}{2 \sigma^2}} &amp; x^2+y^2 \le r^2 \ 0 &amp; \text{otherwise} \end{cases}$$<br>其中，下标 <code>(i,j)</code> 表示 location （样本）的坐标，$x, y$ 表示 location 据对应 corner 的横纵坐标差，$c$ 表示 gt 的分类。$\sigma=r/3$ 用于控制衰减速度。$r$ 为半径。</p>
<p>heatmap 表示 location 是 corner 且属于某一分类的得分，采用 focal loss，考虑以上二维高斯函数作为惩罚因子，<br>$$L_{det}=-\frac 1 N \sum_{c=1}^C\sum_{i=1}^H \sum_{j=1}^W \begin{cases} (1-p_{cij})^{\alpha} \log p_{cij} &amp; y_{cij}=1 \ (1-f_{cij})^{\beta}p_{cij}^{\alpha} \log (1-p_{cij}) &amp; o.w. \end{cases}$$<br>其中，$p_{cij}$ 表示 heatmap 上某 location 预测值。$y_{cij}$ 表示 heatmap 上某处的 gt target 值。N 表示一个 image 上 object 的数量。$\alpha=2, \ \beta=4$ 为超参数，控制各项损失贡献。从上式可见，仅对 corner 一定半径范围内的 negative location 降低了惩罚。</p>
<p><strong>offset:</strong></p>
<p>由于下采样，hourglass 的 feature size 较原 image size 小，记下采样率为 n，那么 gt corner $(x,y)$ 到 heatmap 上的位置为 $(\lfloor x/n, y/n \rfloor)$，再映射回 image 上是，坐标精度有所损失，损失范围为 $[0,n)$，当目标size 较小时，影响 IOU，所以增加一个坐标偏差的预测，gt offset 为<br>$$\mathbf o_k=\left(\frac {x_k} n - \lfloor \frac {x_k} n \rfloor, \frac {y_k} n - \lfloor \frac {y_k} n \rfloor \right)$$<br>其中 $k$ 表示第 k 个 gt corner，预测的 offset 记为 $\hat \mathbf o_k$，使用 smooth L1 损失。</p>
<p><strong>embedding:</strong></p>
<p>左上 corner 和右下 corner 是分开预测的，如何确定哪个左上和哪个右下是一对呢（来自同一个 gt box）？</p>
<p>为每个 corner 生成 embedding vector，如果某一对 corner 来自同一个 gt box，那么它们的 embedding 应该相似，例如 vector 的 L1 范数足够小。</p>
<p>由于 embedding 没有 target 值，作者使用 <code>pull</code> 和 <code>push</code> 两种损失来学习，记 $e_{tk}$ 为第 k 个目标左上 corner 的 embedding，$e_{bk}$ 为第 k 个目标右下 corner 的 embedding，那么损失为<br>$$L_{pull}=\frac 1 N \sum_{k=1}^N [(e_{tk}-e_k)^2+(e_{bk}-e_k)^2]$$<br>$$L_{push}=\frac 1 {N(N-1)} \sum_{k=1}^N \sum_{j=1, j\ne k}^N \max (0, \Delta-|e_k-e_j|)$$<br>$$e_k=\frac {e_{tk}+e_{bk}} 2$$<br>其中，N 为 image 中目标数量，$\Delta=1$ 表示两个来自不同目标的 corner 的 embeding 的最大区分度。</p>
<p>测试阶段，分别得到 K 个 top-left 角点和 K 个 bottom-right 角点，一共 $K^2$ 个 pair 的可能组合，计算每个 pair 的 embedding 的 L1 范数，如果超过一个阈值（设为 0.5），那么这个 pair 不成立，当然还有其他筛选条件，例如来自 heatmap 的得分筛选等，然后使用 soft nms，去除冗余检测结果。</p>
<h2 id="Corner-Pooling"><a href="#Corner-Pooling" class="headerlink" title="Corner Pooling"></a>Corner Pooling</h2><p>这个模块比较关键，从 hourglass 的输出特征到上面说的三个 feature <code>heatmap, offset, embedding</code>，中间经过了 Corner Pooling 模块。</p>
<p>hourglass 输出为 $f_t, f_l, f_b, f_r$ 分别表示 上左下右 四个 side，其中 $f_t, f_l$ 经过左上角点预测分支，$f_b, f_r$ 经过右下角点预测分支。以左上角点预测分支为例，记 corner pooling 的输入 feature size 为 $H \times W$，某一 location <code>(i,j)</code> 在 $f_t$ 上，经 corner pooling 后，从 <code>(i,j)</code> 到 <code>(H,j)</code> 之间的特征向量（从这个 location 开始垂直向下看）执行 max 操作得到输出值 $t_{ij}$，同理，从这个 location 向右看的特征向量经过 max 操作得到输出值 $l_{ij}$，<br>$$t_{ij}=\begin{cases} \max[f_t(i,j), t_{(i+1)j}] &amp; i &lt; H \ f_t(H,j) &amp; i=H \end{cases}$$<br>$$l_{ij}=\begin{cases} \max[f_l(i,j), l_{i(j+1)}] &amp; i &lt; H \ f_l(i,W) &amp; i=H \end{cases}$$<br>对于 $f_t$，从下到上递归执行，对于 $f_l$，从右到左递归执行。</p>
<p>预测模块的网络结构如图 2，<br><img src="/images/obj_det/anchor_free_fig2.png" alt=""><center>图 2. backbone 后接一个修改过的 residule module，下方是 shortcut 分支，上方是 2x conv，分别表示 left-most 和 top most，然后分别经 corner pooling 后，再 element-wise add，然后经 conv ，再与 shortcut 分支进行 merge（element-wise add)，然后经过右边的网络</center></p>
<h2 id="Hourglass-Network"><a href="#Hourglass-Network" class="headerlink" title="Hourglass Network"></a>Hourglass Network</h2><p>之前的 backbone 都是 VGG，ResNet 比较常见，也有用 densenet 的，但是 hourglass 网络还没见过，所以这里简单介绍一下。</p>
<p>Hourglass network 是由一个或多个 hourglass 模块组成的全卷积网络。Hourglass 模块先将 input feature 下采样，然后在上采样到原来的 resolution，由于下采样中的 maxpooling 损失了一些细节信息，所以使用 skip layer 将信息带到上采样的 feature 中。堆叠多个 hourglass 模块可捕获更高 level 的信息（这些信息的语义性更强）。</p>
<p>本文中，下采样使用 stride=2 的 conv 代替 maxpooling。</p>
<p>总损失为<br>$$L=L_{det}+\alpha L_{pull} + \beta L_{push} + \gamma L_{off}$$</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://shajianjian.github.io/2021/02/23/obj_det/one_stage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="shajianjian">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SJJ">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/02/23/obj_det/one_stage/" class="post-title-link" itemprop="url">One-stage Object Detection</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-23 10:36:44" itemprop="dateCreated datePublished" datetime="2021-02-23T10:36:44+08:00">2021-02-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-26 15:41:20" itemprop="dateModified" datetime="2021-02-26T15:41:20+08:00">2021-02-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="YOLOv1"><a href="#YOLOv1" class="headerlink" title="YOLOv1"></a>YOLOv1</h1><ol>
<li><p>one-stage detector</p>
</li>
<li><p>unified detection：image 经过网络得到 <code>SxS</code> 大小的 feature map，相当于把 image 划分为 <code>SxS</code> 的 grid，如果其中目标中心落于某个 grid cell，那么这个 grid cell 负责预测这个目标，网络最终的输出为 <code>S*S*(C+B*5)</code>，其中 C 表示分类数量，最多 B 个目标中心落于同一个 grid cell，每个 box 有 4 个坐标和 1 个 conf，这个 conf 表示预测 box 包含目标的置信度，也可以认为是预测 box 与 gt box 的 IOU。C 个预测值表示在此处有目标时的条件概率值，<code>Pr(Classi|Object)</code>，这里分类条件概率与 box 数量 <code>B</code> 无关。测试阶段，分类类型相关的 conf 值则为<br> $$Pr(Class_i|Object) * P(conf)$$</p>
</li>
<li><p>没有 SSD 中的 default box，也没有 Faster R-CNN 中的 anchor/proposal，YOLO 直接在 feature map 上每个点预测 box 坐标和分类概率，所以还需要一个 conf，表示预测 box 包含目标的置信度</p>
</li>
<li><p>文中input image size 为 <code>448x448</code>，经过6次下采样，得到<code>7x7</code>的feature，通过一个 fully connection（输出unit数量 <code>1470=7*7*30</code>），得到feature 上所有 box 的预测坐标、conf 以及分类得分</p>
</li>
<li><p>在 feature map 上使用 fully connection生成每个 grid cell 的预测数据，其中 (x,y) 表示预测目标中心坐标，这是归一化的，且表示<b>距所在 cell 的左端和上端的距离</b>。</p>
</li>
</ol>
<h1 id="YOLOv2"><a href="#YOLOv2" class="headerlink" title="YOLOv2"></a>YOLOv2</h1><p>YOLOv1 虽然是 fast 的，但是比起 SOTA 检测系统，缺点在于定位错误较明显，相较于 region proposal-based 的检测方法，YOLOv1 的 recall 低。YOLOv2 中对其进行改善，使用了：</p>
<ol>
<li><p>Batch Normalization。</p>
</li>
<li><p>High Resolution<br> <br> YOLOv1 中baseline 分类预训练时 image size 为 <code>224x224</code>，然后迁移到检测数据集上训练时，image size 为 <code>448x448</code>，这种输入大小的突变对目标检测不友好，所以训练过程中一直调整输入大小，使得网络适应以增加稳定性，具体策略为：每隔 10 个训练 batch，调整输入大小为</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int dim &#x3D; (rand() % 10 + 10) * 32</span><br></pre></td></tr></table></figure>
<p> 保证输入大小是 32 的整数倍，YOLOv2 中有 5 次下采样，这是匹配的。YOLOv1 有 6 次下采样，这里去掉一次下采样，为了使feature 具有 higher resolution，而这又是为了配合下面的 anchor box，在feature 上每个 position 使用一组 anchor box 来预测，可以降低定位误差。</p>
</li>
<li><p>Convolution with Anchor Boxes<br> <br> 参考 Faster R-CNN 中的 RPN，使用 anchor box。feature 上每个 position 使用大小形状不同的 k 个 anchor 进行预测，k 的取值以及各 anchor 的大小形状，根据数据集中gt box 聚类（k-means）计算得到，聚类使用的距离采用 IOU，</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d(anchor, cluster-center)&#x3D;1-IOU(anchor, cluster-center)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Direct location prediction<br> <br> 基于 region proposal 的位置预测过程为：记位置预测值 $(t_x, t_y)$ 为相对offset，根据anchor box坐标，计算最终预测box 中心坐标为<br> $$x=t_x \cdot w_a+x_a, \quad y=t_y \cdot h_a + y_a$$<br> 在训练开始阶段，由于是随机初始化模型参数，上式会导致预测 box 位置与 anchor 偏差很大，这会使得训练要花很长一段时间才能使得 box 的预测位置稳定下来（<b>注意：不使用上式</b>）。YOLOv2 沿用 YOLOv1 中预测中心坐标与所在 cell 的左边线和上边线的距离，这样偏差就不会很大，设cell <code>(i,j)</code> 处的某个 anchor 对应的坐标预测值记为 $t_x, t_y, t_w, t_h$，feature 大小为 $(w_f, h_f)$，anchor 基于 feature 的宽高为 $(w_a,h_a)$，那么计算预测 box 的实际归一化坐标为<br> $$x=(i+t_x)/w_f$$<br> $$y=(j+t_y)/h_f$$<br> $$w=\exp(t_w) \cdot w_a/w_f$$<br> $$h=\exp(t_h) \cdot h_a/h_f$$</p>
</li>
</ol>
<p>每个 box 均有 5 个坐标预测值（包括 4 个坐标偏差和 1 个是否包含目标的 conf）和 C 个分类得分预测值，最终输出大小则为 $k \cdot s \cdot s \cdot (5+C)$，其中 k 为 anchor 数量。</p>
<h1 id="YOLOv3"><a href="#YOLOv3" class="headerlink" title="YOLOv3"></a>YOLOv3</h1><p>主要是借鉴别的好的 idea 整合到 YOLO 里面来。</p>
<ol>
<li><p>沿用 YOLOv2 中 anchor box，使用聚类得到 k 个 anchor，每个 anchor 预测 4 个坐标 offset，1 个 objectness conf，以及 C 个分类概率。坐标 offset 的计算与 YOLOv2 中相同</p>
</li>
<li><p>与 gt box 有最大 IOU 的 anchor 的 conf target 值为 1，而其他非最佳 IOU 但是 IOU 大于某个阈值（0.5）的 anchor 则被忽略。IOU 低于 0.5 的则为负例 anchor，负例 anchor 只需要计算 conf 损失，不需要计算坐标 offset 损失和分类损失。</p>
</li>
<li><p>YOLOv3 在三个 scale 的 feature 上进行预测，YOLOv1 和 YOLOv2 均只有单个 scale 的 feature。这是为了借鉴 FPN 的思想。由于有了 multi-scale 的 features，每个 feature 上的每个 position 处只预测 3 个 anchor boxes，假设某个 feature size 为 <code>NxN</code>，那么预测 tensor 为 <code>NxNx[3*(4+1+C)]</code>，其中 C 为 foreground 分类数量。</p>
</li>
<li><p>Baseline 结构如 darknet-53 所示，用于抽取 feature，在 ImageNet 上预训练。目标检测网络结构如 yolov3.cfg 配置文件中所示。借鉴了 ResNet 中 shortcut 技巧（主要也是因为网络更 deep 了）。聚类得到 9 个 anchor size，然后按大小排序，每 3 个一组作为对应 scale feature 上所用的 anchor。</p>
</li>
</ol>
<h1 id="SSD"><a href="#SSD" class="headerlink" title="SSD"></a>SSD</h1><ol>
<li>baseline: VGG 等</li>
<li>one-stage detector。与 Faster R-CNN 相比，省去了 proposals 生成过程，而是在 feature map 上每个 position 有一组 prior box（k 个），然后 feature maps 上使用具有 <code>(c+4)k</code> filters 的 conv，而非 fully connection，进行预测输出，每个position 输出 <code>(c+4)k</code> 个值，表示预 c 个分类得分，和此处 box 的坐标 offsets。同时，使用 multi scale 的 feature maps，以覆盖多个不同大小级别的目标预测。</li>
<li>论文中针对 300x300 的输入图像，一共使用了 6 个不同 scale 的 feature，每个 feature 上的各点生成 prior box 的数量为 <code>4,6,6,6,4,4</code>，因为认为数据集中，中间 scale 的目标数量要多一些。各 feature 的边长为 <code>38, 19, 10, 5, 3, 1</code>，单个 image 上所有 prior box 数量为 <code>(38*38+3*3+1*1)*4+(19*19+10*10+5*5)+6=8732</code></li>
<li>由于使用 multi scale feature maps，所以不同 level 的 feature 负责不同大小的目标检测，假设共 m 个不同 scale 的 feature（文中 m=6），那么每个 level 的 feature 上的 default box 的基础边长为<br> $$s_k=s_{min}+\frac {s_{max}-s_{min}}{m-1}(k-1), \ k \in [1,m]$$<br> 其中最小最大边长为 <code>[min, max]=[0.2, 0.9]</code>，所有不同 scale 的边长 s 均匀散落在这个区间上</li>
<li>一个image上的 default box 数量非常多（第3点中指出高达 8732个），其中匹配的 default box是指与 gt 有最大 IOU 或者 IOU &gt; 0.5 的那些，称为正例，其余的为负例，显然负例会特别多，导致数据 unbalanced，所以将负例按 conf 预测损失倒序排列，选择 top N 的负例，这里 N 取正例数量的 3 倍，每个 level 的 feature 独立进行这种 hard negative mining</li>
</ol>
<h1 id="DSSD"><a href="#DSSD" class="headerlink" title="DSSD"></a>DSSD</h1><p>在 SSD 的基础上增加 deconvolution layer，具体是对 SSD 中用于预测所有 level 的 feautre，自顶向下，最顶 level 的 feature 上使用一个 prediction module 进行预测，然后这个 feature 经过 deconvolution，再与 SSD 中 resolution 更大一级的 feature 进行融合，然后使用 prediction module 进行预测，上一个融合后的 feature 再经 deconvolution，与 SSD 中 resolution 更大一级的 feature 进行融合，递归进行这个过程，直到原 SSD 中所有 level 的 feature 均进行了融合和预测，整个网络形成一个 hour-glass 结构，也就是 “encoder-decoder”。这与 FPN 其实很类似，只是这个 top-down 模块中的 upsample 换成了 deconvolution。</p>
<h1 id="RetinaNet-Focal-Loss"><a href="#RetinaNet-Focal-Loss" class="headerlink" title="RetinaNet(Focal Loss)"></a>RetinaNet(Focal Loss)</h1><h2 id="Loss"><a href="#Loss" class="headerlink" title="Loss"></a>Loss</h2><p>one-stage 速度更快，结构更简单，但是比起 two-stage，准确率还差的不少，其中一个原因是 one-stage 使用了密集 location 采样，这就导致 fg-bg 分类不均衡，本文使用 Focal Loss，通过附加低权重，降低已经分类好的样本的对 loss 的贡献，从而 focus on hard examples。</p>
<blockquote>
<p>他方法如 OHEM 等也可以解决 one-stage 中的分类不平衡问题</p>
</blockquote>
<h3 id="Balanced-Cross-Entropy"><a href="#Balanced-Cross-Entropy" class="headerlink" title="Balanced Cross Entropy"></a>Balanced Cross Entropy</h3><p>$$CE(p,y)=\begin{cases} - \alpha \log p &amp; y=1 \ -(1-\alpha) \log(1-p) &amp; y=0\end{cases}$$<br>其中 $\alpha \in [0, 1]$，其值可取类频数的倒数，例如数据集大小 N，fg 数量为 $N_1$，bg 数量为 $N_0$（$N=N_1+N_0$），那么<br>$\alpha=\frac {N_0} N$，表示增大正例的损失贡献。</p>
<h3 id="Focal-Loss"><a href="#Focal-Loss" class="headerlink" title="Focal Loss"></a>Focal Loss</h3><p>$$FL(p,y)=\begin{cases} - （1-p)^{\gamma} \log p &amp; y=1 \ -p^{\gamma} \log(1-p) &amp; y=0\end{cases}$$<br>其中 $\gamma&gt;0$。</p>
<p>记<br>$$p_t=\begin{cases} p &amp; y=1 \ 1-p &amp; y=0\end{cases}$$<br>$$\alpha_t=\begin{cases} \alpha &amp; y=1 \ 1-\alpha &amp; y=0\end{cases}$$</p>
<p>于是 $\alpha$ balanced CE 损失为<br>$$CE(p_t)=-\alpha_t \log(p_t)$$</p>
<p>Base Focal Loss 为<br>$$FL(p_t)=-(1-p_t)^{\gamma} \log (p_t)$$</p>
<p>$\alpha$ balanced Focal Loss 为<br>$$FL(p_t)=-\alpha_t (1-p_t)^{\gamma} \log (p_t)$$</p>
<h2 id="RetinaNet"><a href="#RetinaNet" class="headerlink" title="RetinaNet"></a>RetinaNet</h2><p>为了验证 Focal Loss 的有效性，设计了这个 RetinaNet。Focal Loss 用在 Classification Subnet 中。</p>
<p><strong>backbone:</strong> FPN on ResNet。使用 $P_3 \sim P_7$ level 的 feature，其中 $P_3 \sim P_5$ 由 ResNet 的 $C_3 \sim C_5$ 获得，然后再使用一个 $3 \times 3$-s2 的 conv（无 ReLU） 得到 $P_6$，最后使用 ReLU + $3 \times 3$-s2 conv 得到 $P_7$。$P_l$ feature 的 stride 是 $2^l$，每个 feature 均为 C=256 channels。feature 上 anchor 的 base size 为 $2^{l+2}$，每个 position 有 9 个 anchors，aspect ratio 由配置给出，每个 anchor 均有 K 个分类得分（包含了背景），4 个位置坐标。</p>
<p>$IOU \ge 0.5$ 的为 正 anchor，$IOU &lt; 0.4$ 的为负 anchor，$0.4 \le IOU &lt; 0.5$ 的 anchor 忽略，不参加训练。正 anchor 与 对应的 gt box 之间计算 offset，作为 box regression target，classification target 则为 one-hot vector，向量中 anchor 所对应的目标分类的 entry 为 1， 其余 entry 为 0。</p>
<p>backbone 后接两个 subnetworks：用于分类和 box 回归（每个 level 的 feature 上均如此）。</p>
<p><strong>Classification Subnet:</strong> 这是一个 FCN 子网络，参数在所有 pyramid level 之间共享。在 pyramid feature 上，使用 4 个 <code>3x3</code> conv，每个 conv 均有 C=256 个 filters，且每个 conv 后跟一个 ReLU，然后是一个 <code>3x3</code> 的 conv，有 <code>KA</code> 个 filters，其中 K 为分类数量，A 为 anchor 数量。这个子网络比 RPN 有更 deep 的结构，文中发现，这种设计比某些超参数的选择还要重要。</p>
<p><strong>Box Regression Subnet:</strong> 与 Classification Subnet 结构类似，只是最后一个 conv 的 filters 数量为 <code>4A</code>。</p>
<p>这两个 subnet 的结构就像天线一样位于 FPN 之上，故称 RetinaNet。</p>
<p>以前使用 heuristic sampling（RPN）或 hard example mining(OHEM, SSD) 来选择 mini-batch（数量为 256）的 anchors，但是这里使用 Focal Loss，单个 image 上的 anchor 数量达到 ~100k（正例 anchor 与 负例 anchor 之和），总的 focal loss 则是这所有 anchor 上 Focal Loss 之和，并除以正例 anchor 数量。</p>
<h1 id="STDN"><a href="#STDN" class="headerlink" title="STDN"></a>STDN</h1><p>Scale-Transferrable Detection Network，为了解决目标 scale 多样性的问题。</p>
<p>主流的目标检测方法中， Faster RCNN 中只有单一 scale 的 feature，其 receptive field 是固定的，而目标的 scale 和 aspect ratio 则是各不相同的，所以存在不一致问题。 SSD 在不同 depth 的 layer 的 feature 上预测，anchor 的 scale 与 feature 的 scale 有关，这一定程度上解决了目标 scale 多样性的问题，但是在小目标上表现并不好，因为 low feature 用于预测小目标，而 low feature 的语义性较弱，于是使用 FPN，通过径向连接和 top-down 模块，将高层 feature 与低层 feature 融合，使得低层特征在保持更多细节信息的同时，兼具语义特征，FPN 缺点在于需要谨慎地构建 feature pyramids，并且 FPN 网络结构带来了一定的计算负担（FPN 是在 Faster RCNN 基础上将 baseline 增加 FPN 结构，所以是一个 two-stage 检测器）。</p>
<p>STDN 以 DenseNet 为 baseline，利用了 DenseNet 中高低层 feature concatenation 的特性，使得 feature 具有更强的表征能力。在 DenseNet 最后一个 DenseBlock 的最后一个 Layer 之上， 使用Scale-Transfer Module（STM），获得 multi scale features，用于预测，STM 没有参数，不会引入很多计算负担。</p>
<ol>
<li><p>使用 DenseNet-169 为 baseline (growth rate=32)</p>
</li>
<li><p>将 stem block 改为 3 个 <code>3x3</code> 的 conv 和一个 <code>2x2</code> 的 mean-pooling，其中第一个 <code>3x3</code> conv 的 stride=2。原来 DenseNet 中采用 <code>7x7-s2</code> 和 <code>3x3-s2</code> 的 conv，我们认为大卷积核和连续的下采样对检测小目标的准确性不利。</p>
</li>
<li><p>当 input size 为 <code>300x300</code>，DenseNet 的 输出 feature size 为 <code>9x9</code>。</p>
</li>
<li><p>网络结构为 stem –&gt; DB1 –&gt; T1 –&gt; DB2 –&gt; T2 –&gt; DB3 –&gt; T3 –&gt; DB4 =&gt; STM，其中 DB 表示 DenseBlock，T 表示 Transition Layer。T3 输出为 <code>640x9x9</code>，STM 包含 6 个 scale 的 features，如下表所示</p>
<table>
<thead>
<tr>
<th>output size</th>
<th>layer</th>
</tr>
</thead>
<tbody><tr>
<td>800x1x1</td>
<td>9x9 mean-pool, stride 9 (Input DB4_concat5)</td>
</tr>
<tr>
<td>960x3x3</td>
<td>3x3 mean-pool, stride 3 (Input DB4_concat10)</td>
</tr>
<tr>
<td>1120x5x5</td>
<td>2x2 mean-pool, stride 2 (Input DB4_concat15)</td>
</tr>
<tr>
<td>1280x9x9</td>
<td>Identity layer (Input DB4_concat20)</td>
</tr>
<tr>
<td>360x18x18</td>
<td>2x scale-transfer layer (Input DB4_concat25)</td>
</tr>
<tr>
<td>104x36x36</td>
<td>4x scale-transfer layer (Input DB4_concat32)</td>
</tr>
</tbody></table>
<p> 已知 DenseBlock 中第 $l$ 个 layer 的 output channen 为 $k_0+l*32$，那么上表中第一个 layer 为 <code>9x9</code> 的均值池化层，输出为最小 scale 的 feature，输出 size 为 <code>800x1x1</code>，这个 layer 的输入为 DB4 中第 5 个 layer 的 output，根据公式其输出 channel 为 $640+5\times 32=800$。其他 layer 的输入也是 DB4 中某个 layer 的输出。</p>
<ul>
<li>Identity layer 表示输出就是输入本身</li>
<li>scale-transfer layer 表示将输入的 channel 压缩 $r^2$ 倍（$r \times$ scale-transfer layer），而 $W, H$ 则均增大 $r$ 倍，rearrange 公式为，<br>  $$I_{x,y,c}^{SR}=I_{\lfloor x/r \rfloor,\lfloor y/r \rfloor, r\cdot mod(y,r)+mod(x,r)+c\cdot r^2}^{LR}$$</li>
</ul>
</li>
<li><p>每个 scale 的 feature 分别根据 dense anchor 进行预测，anchor 与 gt box 匹配标准为：有最大 IOU 或者 IOU &gt; 0.5，其余 anchor 为负例，根据 hard negative mining 使得正负例数量比为 <code>1:3</code>。</p>
</li>
<li><p>抽取的 feature 分两路，分别到分类分支和 box 回归分支。分类分支由一个 <code>1x1</code> conv 和两个 <code>3x3</code> conv 组成，每个 conv 后接 BN+ReLU，最后一个 conv 的 channel 为 <code>KA</code>，其中 K 为分类数量（fg 数量 + 一个 bg），A 为每个 position 预测的 anchor 数量。回归分支的结构与分类分支相同，只是最后一个 conv 的 channel 为 <code>4A</code>。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">shajianjian</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shajianjian</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    

  

</body>
</html>
